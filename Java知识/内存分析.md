## 1. 内存泄漏排查工具详细使用指南

内存泄漏情况：

| 内存区域                 | 泄漏类型        | GC 能否回收？                            | 举例                                                                                |
| :------------------- | :---------- | :---------------------------------- | :-------------------------------------------------------------------------------- |
| **堆 (Heap)**         | 逻辑泄漏        | **不能** (因为对象在逻辑上仍被引用)               | `static` 集合、未移除的监听器、`ThreadLocal` 未清理                                             |
| **元数据区 (Metaspace)** | 类/类加载器泄漏    | **可以，但条件苛刻** (需回收所有实例和 ClassLoader) | 动态代理库滥用                                                                           |
| **堆外内存 (Off-heap)**  | Native 内存泄漏 | **完全不能** (GC 不管理这部分内存)              | `DirectByteBuffer` 未释放、JNI 调用 `malloc` 后未 `free`、文章中的 `GZIPInputStream` 未 `close` |

因此，GC 触发时也回收不了的泄漏，主要是指**堆中的逻辑泄漏**和**堆外内存的物理泄漏**。前者需要开发者优化代码逻辑，断开不再需要的引用；后者则需要开发者遵循“谁申请，谁释放”的原则，进行严格的资源管理。

### 1.1. 系统级初步排查工具

#### 1.1.1. 系统内存监控

##### 1.1.1.1. top/htop - 实时内存监控

```bash
# 基础命令
top -p <PID>
htop -p <PID>

# 持续监控并保存到文件
top -b -n1 -p <PID> >> memory_monitor.log
```

**结果分析：**
- **VIRT**：虚拟内存大小
- **RES**：物理内存使用（RSS）
- **SHR**：共享内存
- **%MEM**：内存使用百分比

**关键指标：**

```
VIRT持续增长 → 可能存在内存泄漏
RES/VIRT比值过小 → 可能有大量虚拟内存未实际使用
%MEM持续上升 → 确认存在内存泄漏
```

**无法定位时下一步：**

- 如果 RES 稳定，VIRT 增长 → 使用**pmap**分析虚拟内存分布
- 如果 RES 持续增长 → 使用**jstat**检查 JVM 内存

VIRT 的值会高于 RES 的值，程序启动时，JVM 为堆申请的内存是虚拟内存，如 4.8G，但在启动后 JVM 一开始可能实际只使用了 3G 内存，导致 Linux 实际只分配了 3G。

gc 时，由于会复制存活对象到堆的空闲部分，如果正好复制到了以前未使用过的区域，就又会触发 Linux 进行内存分配，故一段时间内内存占用会越来越多，直到堆的所有区域都被 touch 到。

![image.png](https://r2.129870.xyz/img/2025/37de334d91b4b7d1ddd0d19cd664aeab.png)

通过添加 JVM 参数 `-XX:+AlwaysPreTouch`，可以让 JVM 为堆申请虚拟内存后，立即把堆全部 touch 一遍，使得堆区域全都被分配物理内存，而由于 Java 进程主要活动在堆内，故后续内存就不会有很大变化了。

##### 1.1.1.2. ps - 进程内存详情

```bash
# 查看进程内存统计
ps -o pid,ppid,rss,vsz,comm -p <PID>

# 查看进程内存映射概要
ps -eo pid,rss,vsz,comm | grep java

# 持续监控
watch -n 5 'ps -o pid,rss,vsz,comm -p <PID>'
```

**结果分析：**

```
RSS: 物理内存使用量（KB）
VSZ: 虚拟内存使用量（KB）

正常情况：RSS稳定或周期性波动
异常情况：RSS持续线性增长
```

#### 1.1.2. JVM 进程识别

```bash
# 找到Java进程PID
jps -v | grep YourAppName
# 或
ps aux | grep java | grep YourAppName
```

### 1.2. JVM 堆内存分析工具

#### 1.2.1. jstat - JVM 内存统计

##### 1.2.1.1. 基础内存监控

```bash
# 查看堆内存使用情况（每5秒一次，共10次）
jstat -gc <PID> 5s 10

# 查看堆内存详细信息
jstat -gccapacity <PID>

# 查看GC统计
jstat -gcutil <PID> 5s
```

**结果分析：**

```
S0C, S1C: 年轻代中两个Survivor区的容量
S0U, S1U: 年轻代中Survivor区的使用量
EC, EU: Eden区的容量和使用量  
OC, OU: 老年代的容量和使用量
MC, MU: 元空间的容量和使用量

关键指标：
- OU持续增长且不下降 → 老年代内存泄漏
- EU频繁接近EC → 年轻代内存压力大
- MU持续增长 → 可能是类加载导致的元空间泄漏
```

**无法定位时下一步：**
- 如果 OU 持续增长 → 生成**heap dump**进行 MAT 分析
- 如果各项指标正常 → 检查**DirectMemory**

##### 1.2.1.2. 持续监控脚本

```bash
#!/bin/bash
PID=$1
LOG_FILE="gc_monitor_$(date +%Y%m%d_%H%M%S).log"

echo "开始监控PID: $PID"
echo "监控时间: $(date)" > $LOG_FILE

while true; do
    echo "$(date): " >> $LOG_FILE
    jstat -gcutil $PID >> $LOG_FILE
    echo "" >> $LOG_FILE
    sleep 60
done
```

#### 1.2.2. 生成 Heap Dump

```bash
# 生成heap dump文件
jcmd <PID> GC.run_finalization
jcmd <PID> GC.run
jmap -dump:live,format=b,file=heapdump_$(date +%Y%m%d_%H%M%S).hprof <PID>

# 如果jmap失败，使用jcmd
jcmd <PID> GC.run_finalization
jcmd <PID> GC.run  
jcmd <PID> VM.gc
jcmd <PID> Heap.dump /path/to/heapdump.hprof
```

#### 1.2.3. MAT (Memory Analyzer Tool) 分析

##### 1.2.3.1. MAT 安装和启动

```bash
# 下载MAT
wget https://eclipse.org/downloads/download.php?file=/mat/1.14.0/rcp/MemoryAnalyzer-1.14.0.20230315-linux.gtk.x86_64.zip

# 解压并启动
unzip MemoryAnalyzer-*.zip
./MemoryAnalyzer/MemoryAnalyzer -vmargs -Xmx4g -data ./workspace
```

##### 1.2.3.2. MAT 命令行分析

```bash
# 生成泄漏报告
./ParseHeapDump.sh heapdump.hprof org.eclipse.mat.api:suspects

# 生成直方图
./ParseHeapDump.sh heapdump.hprof org.eclipse.mat.api:overview

# 查找大对象
./ParseHeapDump.sh heapdump.hprof org.eclipse.mat.api:top_consumers
```

**MAT 分析要点：**
1. **泄漏嫌疑报告**：自动识别可能的内存泄漏
2. **支配树分析**：找到占用内存最大的对象
3. **直方图分析**：按类统计对象数量
    除了观察堆内的对象情况外，还需要观察方法区的对象分布情况。当[[一次完整的 JVM 堆外内存泄漏故障排查记录 _ HeapDump 性能社区 - Cubox|方法区中的类信息膨胀]]时也会导致内存不断增加，同时[[JVM#1.2.1.5. 方法区的回收|方法区的回收]]又是比较苛刻的。因此对于需要通过程序加载创建类的地方或者对于使用了 ASM 等字节码增强工具的类库要特别注意。
4. **GC Root 分析**：找到对象无法回收的根因

**无法定位时下一步：**
- MAT 显示堆内存正常 → 检查**堆外内存**
- 发现大量 DirectByteBuffer → 使用**Arthas**分析

### 1.3. 堆外内存分析工具

使用 ps 查看到的进程内存占用和 JVM 相关工具追踪到的内存可能并不完全一致，主要有以下方面的差异：

- 第三方本地库（Native Libraries）内存占用
    当 Java 代码通过 JNI（Java Native Interface）调用 C/C++ 等语言编写的本地库时，这些本地库内部使用 malloc、new 等方式申请的内存，完全不受 JVM 的 NMT 系统追踪。然而，这部分内存确实是属于该 Java 进程的，因此会被操作系统计入 RSS。
- 直接内存
    通过 `java.nio.ByteBuffer.allocateDirect()` 分配的内存虽然是堆外内存，但现代的 JDK 版本中，NMT 通常能将其统计在 Internal 或 Other 类别下。

    ```
    Other (malloc=67369KB ...)
    Internal (malloc=16291KB ...)
    ```

- 加载的共享库 / 动态库
    Java 进程本身依赖于大量的共享库（`.so` 文件），例如：`libc.so` (C 标准库)、`libpthread.so` (线程库) 、`libjvm.so` (JVM 核心库) 、应用依赖的其他任何原生库文件

    操作系统会将这些库的代码段和数据段映射到进程的地址空间。这部分内存也会被计入 RSS，而 NMT 不会统计它们。虽然多个进程可以共享同一个库的物理内存页，但 RSS 的计算方式仍会将这部分计入。

- JNI 本身的开销
- 内存分配器的碎片化
    JVM 向操作系统申请内存时，底层通常使用 glibc 的 malloc。malloc 本身为了性能，可能会预先分配比请求稍大的内存块，并且在释放后可能会持有这些内存以备将来使用（形成内存池），而不是立即归还给操作系统。这就导致了 RSS（OS 看到的）会比 JVM 实际使用的（NMT 看到的）要高。

    ![image.png](https://r2.129870.xyz/img/2025/4aa8fdb30c15a3c7555cd53bb960686e.png)

    查看 glibc 内存分配情况：

    ```shell
    # 查看glibc内存分配情况，会输出到进程标准错误中
    gdb -q -batch -ex 'call malloc_stats()' -p 1
    ```

    触发 glibc 缓存回收：

    ```shell
    gdb -q -batch -ex 'call malloc_trim(0)' -p 1
    ```

#### 1.3.1. Arthas - 运行时 Java 诊断

##### 1.3.1.1. Arthas 安装和连接

```bash
# 下载并启动Arthas
curl -O https://arthas.aliyun.com/arthas-boot.jar
java -jar arthas-boot.jar

# 选择目标Java进程
# 或者直接连接指定PID
java -jar arthas-boot.jar <PID>
```

##### 1.3.1.2. 内存分析命令

```bash
# 查看JVM内存使用详情
memory

# 实时监控面板
dashboard

# 查看JVM信息
jvm

# 查看DirectByteBuffer使用情况
mbean java.nio:type=BufferPool,name=direct

# 强制GC
ognl '#runtime=@java.lang.Runtime@getRuntime(), #runtime.gc()'

# 查看某个类的实例数
sc -d java.nio.DirectByteBuffer

# 查看DirectByteBuffer实例
vmtool --action getInstances --className java.nio.DirectByteBuffer --limit 10
```

**结果分析要点：**

```bash
# memory命令输出分析
heap: 堆内存使用情况
nonheap: 非堆内存使用情况  
direct: 直接内存使用量 ← 重点关注
mapped: 内存映射文件大小

# 异常情况
direct内存持续增长 → DirectBuffer泄漏
nonheap持续增长 → 元空间或其他非堆区域泄漏
```

**无法定位时下一步：**
- direct 内存异常 → 分析 **Netty** 等框架的 DirectBuffer 使用
- 所有 JVM 指标正常 → 使用 **NMT** 分析 native 内存

#### 1.3.2. NMT (Native Memory Tracking)

##### 1.3.2.1. 启用 NMT

```bash
# 启动JVM时添加参数
-XX:NativeMemoryTracking=detail

# 或者修改启动脚本
JAVA_OPTS="$JAVA_OPTS -XX:NativeMemoryTracking=detail"
```

##### 1.3.2.2. NMT 命令详解

```bash
# 查看内存概览
jcmd <PID> VM.native_memory summary

# 查看详细内存分配
jcmd <PID> VM.native_memory detail

# 建立基线（应用启动后执行）
jcmd <PID> VM.native_memory baseline

# 与基线对比（运行一段时间后执行）
jcmd <PID> VM.native_memory summary.diff
jcmd <PID> VM.native_memory detail.diff

# 按内存分类查看
jcmd <PID> VM.native_memory summary scale=MB

# 关闭NMT
jcmd <PID> VM.native_memory shutdown
```

NMT 结果示例：

![image.png](https://r2.129870.xyz/img/2025/a3f6572b37aca7cd6179b82af06e0ee3.png)

##### 1.3.2.3. NMT 结果分析脚本

```bash
#!/bin/bash
PID=$1
OUTPUT_DIR="nmt_analysis_$(date +%Y%m%d_%H%M%S)"
mkdir -p $OUTPUT_DIR

echo "=== NMT内存分析开始 ===" 
echo "PID: $PID"
echo "时间: $(date)"

# 生成基线
echo "生成基线..."
jcmd $PID VM.native_memory baseline

# 等待一段时间让应用运行
echo "等待5分钟后进行对比分析..."
sleep 300

# 生成对比报告
echo "生成对比报告..."
jcmd $PID VM.native_memory summary.diff > $OUTPUT_DIR/memory_diff.txt
jcmd $PID VM.native_memory detail.diff > $OUTPUT_DIR/memory_detail_diff.txt

# 解析关键指标
echo "=== 关键内存增长分析 ===" > $OUTPUT_DIR/analysis.txt
grep -E "(Total|Java Heap|Class|Thread|Code|GC|Compiler|Internal|Other|Symbol|Native Memory Tracking|Arena Chunk|Tracing|Logging|Arguments|Module|Synchronizer|Serviceability)" $OUTPUT_DIR/memory_diff.txt >> $OUTPUT_DIR/analysis.txt

echo "分析完成，结果保存在: $OUTPUT_DIR"
```

**NMT 结果分析要点：**

```
Java Heap: 堆内存使用
Class: 类加载器相关内存  
Thread: 线程栈内存
Code: 编译代码内存
GC: 垃圾收集器内存
Internal: JVM内部结构
Other: 其他（通常包含DirectBuffer）
Symbol: 符号表
Arena Chunk: 内存块管理

关键指标：
- Total committed持续增长 → 确认存在native内存泄漏
- Other大幅增长 → 可能是DirectBuffer或JNI调用
- Thread增长 → 线程泄漏
- Class增长 → 类加载器泄漏
```

**无法定位时下一步：**
- NMT 显示 Other 或 Unknown 增长 → 使用 **pmap** 定位具体内存区域
- NMT 无法追踪的内存增长 → 使用 **async-profiler** 分析

### 1.4. 高级分析工具

#### 1.4.1. async-profiler

##### 1.4.1.1. 下载和安装

```bash
# 下载async-profiler
wget https://github.com/jvm-profiling-tools/async-profiler/releases/download/v2.9/async-profiler-2.9-linux-x64.tar.gz
tar -xzf async-profiler-2.9-linux-x64.tar.gz
cd async-profiler-2.9-linux-x64
```

##### 1.4.1.2. 内存分析命令

```bash
# CPU火焰图
./profiler.sh -e cpu -d 60 -f cpu_profile.html <PID>

# 内存分配火焰图  
./profiler.sh -e alloc -d 60 -f alloc_profile.html <PID>

# Native内存分析（新版本支持）
./profiler.sh -e malloc -d 60 -f malloc_profile.html <PID>

# 特定事件分析
./profiler.sh -e JavaObjectAllocationInNewTLAB -d 60 -f tlab_profile.html <PID>

# 生成JFR文件
./profiler.sh -e alloc -d 60 -o jfr -f profile.jfr <PID>

# 实时监控模式
./profiler.sh -e alloc -i 10s --loop -f alloc_monitor.html <PID>
```

##### 1.4.1.3. 使用 Arthas 集成的 async-profiler

```bash
# 在Arthas中使用
profiler start --event alloc

# 60秒后生成报告
profiler stop --format html --file /tmp/alloc_profile.html

# 查看支持的事件
profiler list

# CPU和内存组合分析
profiler start --event cpu,alloc --interval 10000000
```

**结果分析要点：**
- 火焰图宽度表示消耗占比
- 火焰图高度表示调用链深度  
- 重点关注内存分配热点方法
- 分析是否有异常的大对象分配

**无法定位时下一步：**
- 如果火焰图显示正常 → 使用**pmap**进行系统级分析
- 如果发现 JNI 调用热点 → 分析**JNI 内存泄漏**

#### 1.4.2. pmap - 进程内存映射分析

##### 1.4.2.1. pmap 命令详解

```bash
# 查看进程内存映射
pmap <PID>

# 显示更详细的信息
pmap -x <PID>

# 显示设备信息
pmap -d <PID>  

# 显示扩展格式
pmap -X <PID>

# 持续监控并保存
watch -n 30 'pmap -x <PID>' > pmap_monitor.log
```

pmap 结果示例：

![image.png](https://r2.129870.xyz/img/2025/f827394b044fa74da99c88c890a2d838.png)

可在不同的时间点多次保存 pmap 命令的输出，然后通过查看两个时间点内存段分布的差异从而找到新分配的内存。

##### 1.4.2.2. pmap 分析脚本

```bash
#!/bin/bash
PID=$1
BASELINE_FILE="pmap_baseline_$(date +%Y%m%d_%H%M%S).txt"
CURRENT_FILE="pmap_current_$(date +%Y%m%d_%H%M%S).txt"

# 生成基线
echo "生成基线内存映射..."
pmap -x $PID > $BASELINE_FILE

echo "等待300秒后生成对比..."
sleep 300

# 生成当前状态
pmap -x $PID > $CURRENT_FILE

# 对比分析
echo "=== 内存映射变化分析 ===" > memory_mapping_diff.txt
echo "基线文件: $BASELINE_FILE" >> memory_mapping_diff.txt
echo "当前文件: $CURRENT_FILE" >> memory_mapping_diff.txt
echo "" >> memory_mapping_diff.txt

# 提取关键信息
echo "=== RSS变化分析 ===" >> memory_mapping_diff.txt
echo "基线总RSS:" >> memory_mapping_diff.txt
tail -n 1 $BASELINE_FILE >> memory_mapping_diff.txt
echo "当前总RSS:" >> memory_mapping_diff.txt  
tail -n 1 $CURRENT_FILE >> memory_mapping_diff.txt

# 找出显著增长的内存区域
echo "=== 显著增长的内存区域 ===" >> memory_mapping_diff.txt
awk 'NR==FNR{a[NR]=$3; next} {if($3-a[FNR]>10240) print "增长: " ($3-a[FNR]) "KB - " $0}' $BASELINE_FILE $CURRENT_FILE >> memory_mapping_diff.txt
```

**pmap 结果分析：**

```
Address: 内存地址
Kbytes: 该段大小(KB)
RSS: 物理内存占用
Dirty: 脏页大小
Mode: 权限模式
Mapping: 映射的文件或库

关键指标：
- 大量[anon]区域增长 → 匿名内存分配（可能是malloc）
- 库文件(.so)增长 → 动态库加载
- [heap]区域异常 → 堆内存问题
- [stack]区域增长 → 栈内存问题
```

##### 1.4.2.3. pmap 分析示例

```shell
# tail -c +OFFSET FILE | head -c SIZE | strings | less -S
tail -c +$((0x00007face0000000+1)) /proc/1/mem | head -c $((11616*1024)) | strings | less -S
```

输出结果：

![image.png](https://r2.129870.xyz/img/2025/faa9353e4e5739a15eab1b3dfd4e1525.png)

pmap 输出结果后，可从进程内存中提取和分析字符串数据：

- Linux 将进程内存虚拟为伪文件 `/proc/$pid/mem`，通过它即可查看进程内存中的数据
- 从进程 ID 为 1 的进程内存映像中，从特定内存地址（0x00007face0000000）开始读取数据
- 读取指定大小的内存块（11616KB）
- 提取其中的可打印字符串
- 以不换行的方式分页显示结果

各组件参数说明：

| 命令组件    | 参数     | 作用              |
| ------- | ------ | --------------- |
| tail    | -c +N  | 从第 N 个字节开始输出到文件末尾 |
| head    | -c N   | 只输出前 N 个字节        |
| strings | (默认)   | 提取文件中的可打印字符串    |
| strings | -n NUM | 设置最小字符串长度(默认 4)  |
| strings | -a     | 扫描整个文件，不只是数据段   |
| less    | -S     | 不换行显示长行         |
| less    | -R     | 保持颜色显示          |

### 1.5. 工具组合使用策略

#### 1.5.1. 排查决策树

```
1. 发现内存问题
   ↓
2. ps/top确认RSS持续增长
   ↓
3. jstat检查JVM堆内存
   ├─ 堆内存异常 → MAT分析heap dump
   └─ 堆内存正常 → 继续堆外分析
   ↓
4. Arthas检查DirectBuffer
   ├─ DirectBuffer异常 → 分析Netty等框架
   └─ DirectBuffer正常 → 继续native分析
   ↓  
5. NMT分析native内存
   ├─ NMT能追踪到增长 → 分析对应模块
   └─ NMT无法追踪 → 使用pmap/async-profiler
   ↓
6. pmap分析系统内存映射
   ↓
7. async-profiler生成火焰图
   ↓
8. 结合业务代码分析
```

![image.png](https://r2.129870.xyz/img/2025/3fc5265c7a2d14a68de7f4b3e358e1af.png)

#### 1.5.2. 监控脚本模板

```bash
#!/bin/bash
# 综合内存监控脚本

PID=$1
MONITOR_DIR="memory_monitor_$(date +%Y%m%d_%H%M%S)"
mkdir -p $MONITOR_DIR

echo "开始综合内存监控，PID: $PID"

# 1. 系统内存监控
echo "启动系统内存监控..."
while true; do
    echo "$(date): $(ps -o rss,vsz -p $PID --no-headers)" >> $MONITOR_DIR/system_memory.log
    sleep 60
done &
SYSTEM_PID=$!

# 2. JVM内存监控
echo "启动JVM内存监控..."  
while true; do
    echo "$(date):" >> $MONITOR_DIR/jvm_memory.log
    jstat -gcutil $PID >> $MONITOR_DIR/jvm_memory.log 2>/dev/null
    echo "" >> $MONITOR_DIR/jvm_memory.log
    sleep 60
done &
JVM_PID=$!

# 3. NMT监控（如果启用）
if jcmd $PID VM.native_memory summary >/dev/null 2>&1; then
    echo "启动NMT监控..."
    jcmd $PID VM.native_memory baseline
    while true; do
        echo "$(date):" >> $MONITOR_DIR/nmt_memory.log  
        jcmd $PID VM.native_memory summary.diff >> $MONITOR_DIR/nmt_memory.log 2>/dev/null
        echo "" >> $MONITOR_DIR/nmt_memory.log
        sleep 300
    done &
    NMT_PID=$!
fi

# 清理函数
cleanup() {
    echo "停止监控..."
    kill $SYSTEM_PID $JVM_PID $NMT_PID 2>/dev/null
    echo "监控数据保存在: $MONITOR_DIR"
}

trap cleanup EXIT
echo "监控运行中，按Ctrl+C停止..."
wait
```

这个完整的工具使用指南涵盖了从系统级到应用级的各种内存分析工具，每个工具都有具体的使用命令、结果分析方法和后续分析方向，可以帮助您系统性地排查各种内存泄漏问题。

## 2. 内存分析使用工具

### 2.1. jstat

#### 2.1.1. 命令的作用

`jstat`（Java Virtual Machine Statistics Monitoring Tool）是 Java 自带的一款 JVM 性能监控工具，用于统计和监控正在运行的 Java 应用的各种虚拟机统计信息。主要用来监控 Java 堆、垃圾回收（GC）行为、类装载、JIT 编译等信息。`jstat` 适合在分析 Java 程序运行时的性能瓶颈、GC 问题等场景下使用。

#### 2.1.2. 常用参数及解释

基本用法：

```bash
jstat [option] <vmid> [interval] [count]
```

- **option**: 要查询的统计数据类型（如 GC、类加载等）。
- **vmid**: 目标 Java 进程的 PID。
- **interval**:（可选）刷新时间间隔（秒或毫秒）。
- **count**:（可选）输出次数。

常见 option 及作用：

| 参数             | 作用说明                                         |
|------------------|------------------------------------------------|
| -class           | 显示类加载、卸载信息                             |
| -compile         | 显示 JIT 编译相关统计信息                          |
| -gc              | 显示与垃圾回收相关的数据（堆区各分区容量等）     |
| -gccapacity      | 各内存区域当前容量和最大容量等                   |
| -gcutil          | 各堆区域利用率和 GC 统计                           |
| -gccause         | 垃圾回收统计数据和 GC 产生的原因                    |
| -gcnew           | 新生代统计数据                                   |
| -gcnewcapacity   | 新生代容量相关数据                               |
| -gcold           | 年老代统计数据                                   |
| -gcoldcapacity   | 年老代容量相关数据                               |
| -printcompilation| 已编译方法列表                                   |
| -snap            | 同步快照所有统计数据（减少偏移）                 |

#### 2.1.3. 使用示例

1. 显示进程 12345 的 GC 各区空间相关数据：

    ```bash
    jstat -gc 12345
    ```

    结果示例：

    ```bash
     S0C    S1C    S0U    S1U      EC       EU        OC         OU      MC      MU     CCSC    CCSU     YGC     YGCT    FGC    FGCT     GCT
    1024.0 1024.0   0.0   1016.0  8192.0   345.8   16384.0    2345.6   22048.0 20433.9 2688.0 2434.4    7     0.091   2     0.076   0.167
    ```

2. 每 1 秒监控 10 次 GC 利用率：

    ```bash
    jstat -gcutil 12345 1000 10
    ```

    结果示例：

    ```bash
      S0     S1     E      O      M     CCS    YGC   YGCT    FGC   FGCT     GCT
      0.00 100.00  10.36  23.81 82.78  83.24     7   0.091      2   0.076    0.167
      0.00 100.00  10.36  23.81 82.78  83.24     7   0.091      2   0.076    0.167
      ...
    ```

3. 查看 JIT 编译统计：

    ```bash
    jstat -compile 12345
    ```

    结果示例：

    ```bash
    Compiled Failed Invalid Time FailedType FailedMethod
         109     0       0   12.00
    ```

4. 观察类加载信息：

    ```bash
    jstat -class 12345 2000 5
    ```

    结果示例：

    ```bash
    Loaded  Bytes  Unloaded  Bytes   Time
      3245  712678   650     10456   3.56
    ```

#### 2.1.4. 常用组合命令及使用技巧

1. watch 等工具配合观察 GC 数据高频刷新：

    ```bash
    watch -n 1 "jstat -gcutil 12345"
    ```

2. 与 grep 等命令结合过滤关键信息：

    ```bash
    jstat -gcutil 12345 1000 5 | grep -v "^ *S0"
    ```

3. 将监控日志落盘用于后续分析：

    ```bash
    jstat -gc 12345 1000 300 > gc.log
    ```

4. 查询所有 Java 进程后对批量 jstat 监控：

    ```bash
    for pid in $(jps | awk '{print $1}'); do echo "pid=$pid"; jstat -gcutil $pid 1000 1; done
    ```

#### 2.1.5. 总结

`jstat` 是监控和分析 Java 运行时垃圾回收、内存利用、类加载及 JIT 编译等信息的轻量级利器。无需重启应用，即可快速定位 JVM 性能问题，是调优与故障诊断常用工具。配合 `watch`、`grep` 等命令，可实现更灵活高效的数据获取和分析。熟悉各参数和输出解释，有助于高效地监控和解决 Java 程序的瓶颈问题。

### 2.2. jcmd

#### 2.2.1. 命令的作用

`jcmd` 是 Java Development Kit (JDK) 提供的一个命令行工具，主要用于和正在运行中的 Java 进程进行交互，支持多种诊断和监控操作。使用 `jcmd` 可以执行如生成堆转储、触发垃圾回收、打印线程信息、查看 JVM 参数、动态改变 JVM 参数等操作，是 Java 运维和调优中非常重要的工具。

#### 2.2.2. 常用参数及解释

基本用法：

```bash
jcmd <pid | main-class> <command> [options]
```

| 指令 | 作用 |
|--------|------------------------------------------------|
| help         | 显示所有可用命令或指定命令的帮助信息    |
| VM.version   | 打印 JVM 版本信息                       |
| VM.flags     | 打印 JVM 启动参数                       |
| VM.command_line | 打印应用程序启动命令行            |
| GC.heap_dump <file> | 将 Java 堆导出到指定文件      |
| GC.run       | 触发一次垃圾回收                       |
| GC.class_histogram | 打印类实例的统计信息           |
| Thread.print | 打印线程堆栈信息                       |
| VM.system_properties | 打印系统属性                  |
| VM.uptime    | 打印 JVM 进程已运行时间                 |

要获取目标进程 pid，可运行无参数的 `jcmd`，会显示当前系统上所有 Java 进程及其 pid。

#### 2.2.3. 使用示例

1. 查看当前运行中的所有 Java 进程：

    ```bash
    jcmd
    ```

    结果示例：

    ```bash
    12345 org.example.Main
    23456 com.example.AnotherApp
    ```

2. 打印 JVM 版本信息：

    ```bash
    jcmd 12345 VM.version
    ```

    结果示例：

    ```bash
    12345:
    Java HotSpot(TM) 64-Bit Server VM version 17.0.1+12-LTS-39
    ```

3. 导出堆转储：

    ```bash
    jcmd 12345 GC.heap_dump /tmp/heapdump.hprof
    ```

    结果示例：

    ```bash
    12345:
    Heap dump file created
    ```

4. 打印线程信息：

    ```bash
    jcmd 12345 Thread.print
    ```

    结果示例：

    ```
    12345:
    2024-06-01 09:12:56
    Full thread dump Java HotSpot(TM) 64-Bit Server VM (17.0.1+12-LTS-39 mixed mode, sharing):
    
    "main" #1 prio=5 os_prio=0 tid=0x00007f7b7c001000 nid=0x3f48 runnable [0x00007f7b81244000]
       java.lang.Thread.State: RUNNABLE
         at java.io.FileInputStream.readBytes(Native Method)
         ...
    ```

5. 查看系统属性：

    ```bash
    jcmd 12345 VM.system_properties
    ```

    结果示例（部分）：

    ```bash
    java.home = /usr/lib/jvm/java-17-openjdk-amd64
    user.dir = /home/user/project
    os.name = Linux
    ...
    ```

#### 2.2.4. 常用组合命令及使用技巧

1. 查询支持的所有命令：

    ```bash
    jcmd 12345 help
    ```

2. 查看某一命令的详细帮助：

    ```bash
    jcmd 12345 help GC.heap_dump
    ```

3. 连续多次导出堆统计信息做内存泄漏分析（自动化脚本中常用）：

    ```bash
    for i in {1..5}; do jcmd 12345 GC.class_histogram > histo_$i.txt; sleep 60; done
    ```

4. 查询所有 JVM 系统信息，用于问题排查：

    ```bash
    jcmd 12345 VM.flags
    jcmd 12345 VM.system_properties
    jcmd 12345 VM.command_line
    ```

5. 多进程批量操作（如所有 Java 进程线程 dump）：

    ```bash
    for pid in $(jcmd | awk '{print $1}'); do jcmd $pid Thread.print > thread_dump_$pid.txt; done
    ```

#### 2.2.5. 总结

`jcmd` 是功能极其丰富且灵活的 Java 进程诊断与运维工具，可进行线程、内存、GC、类统计等几乎所有关键监控和调优操作。它的优势在于命令简单、适配新 JVM 功能，无需配置目标进程即可操作，非常适合线上问题排查和性能分析。熟练掌握 `jcmd`，可以大大提升 Java 运维与故障诊断的效率。

### 2.3. jmap

#### 2.3.1. 命令的作用

`jmap`（Java Memory Map）是 JDK 提供的用于内存分析和调试的命令行工具。它主要用于生成或分析 Java 进程的堆转储（heap dump）文件、查看堆内存、perm 区、类的实例分布等详细运行时内存信息。`jmap` 支持与正在运行的 Java 进程直接交互，是排查内存泄漏、分析内存使用情况时的常用工具。

#### 2.3.2. 常用参数及解释

基本用法：

```bash
jmap [option] <pid>
```

常用参数（option）及作用说明：

| 参数                | 作用说明                                                         |
|---------------------|------------------------------------------------------------------|
| -heap               | 显示堆配置概要，包括各内存区域的使用情况、垃圾收集器信息等         |
| -histo[:live]       | 显示堆中各类对象的数量和占用空间（:live 只统计存活对象）           |
| -dump:<opts>        | 生成 heap dump 文件（用于后续分析，比如用 MAT 或 VisualVM 打开）     |
| -finalizerinfo      | 显示等待 finalization queue 处理的对象                            |
| -clstats            | 显示类加载器详细统计信息（JDK 8+、部分版本/平台支持）              |
| -F                  | 强制模式，常和 -dump 等连用，适用于某些不可响应的 JVM 进程           |
| -J<flag>            | 传递参数给 jmap 启动的 JVM，如 -J-Xmx512m                         |

#### 2.3.3. 使用示例

1. 查看 JVM 堆内存概要信息：

    ```bash
    jmap -heap 12345
    ```

    结果示例：

    ```
    Attaching to process ID 12345, please wait...
    Debugger attached successfully.
    Server compiler detected.
    JVM version is 17.0.1+12-LTS-39
    ...
    Heap Configuration:
       MinHeapFreeRatio         = 40
       MaxHeapFreeRatio         = 70
       MaxHeapSize              = 4294967296 (4096.0MB)
    ...
    ```

2. 生成 heap dump 文件（用于 MAT、VisualVM、JProfiler 等工具分析）：

    ```bash
    jmap -dump:format=b,file=/tmp/heapdump_12345.hprof 12345
    ```

    结果示例：

    ```
    Dumping heap to /tmp/heapdump_12345.hprof ...
    Heap dump file created
    ```

3. 查看对象数量和内存占用统计：

    ```bash
    jmap -histo 12345
    ```

    结果示例（部分）：

    ```
     num     #instances         #bytes  class name
    ----------------------------------------------
       1:        345678       17283952  [B
       2:        131072        3145728  java.lang.String
       3:         32768        1048576  [Ljava.lang.Object;
    ...
    Total         999999       55555555
    ```

4. 只统计存活对象分布：

    ```bash
    jmap -histo:live 12345
    ```

5. 强制 dump 某些响应缓慢的进程（加 -F）：

    ```bash
    jmap -F -dump:format=b,file=/tmp/heapdump_12345.hprof 12345
    ```

6. 显示等待 finalizer 的对象信息：

    ```bash
    jmap -finalizerinfo 12345
    ```

    结果示例：

    ```
    Unfinalized objects awaiting finalization...
    Class
    ----------------------
    java.io.FileInputStream
    java.util.zip.ZipFile
    ...
    ```

#### 2.3.4. 常用组合命令及使用技巧

1. 结合 jps 查询目标 Java 进程：

    ```bash
    jps -l
    jmap -heap <pid>
    ```

2. 联合 grep、sort 查找 top 类型对象（如大对象、泄漏）：

    ```bash
    jmap -histo:live 12345 | head -n 20
    jmap -histo 12345 | grep "java.lang.String" 
    ```

3. 自动化定时 heap dump 排查内存泄漏：

    ```bash
    while true; do jmap -dump:format=b,file=/tmp/heapdump_$(date +'%Y%m%d_%H%M%S').hprof 12345; sleep 1800; done
    ```

4. 对比多次 histo 差异定位增长的对象种类：

    ```bash
    jmap -histo:live 12345 > histo_before.txt
    # 执行操作后
    jmap -histo:live 12345 > histo_after.txt
    diff histo_before.txt histo_after.txt
    ```

#### 2.3.5. 总结

`jmap` 是 Java 应用内存分析的核心工具之一，它可以轻松地获取堆转储文件、类实例分布、堆区使用状况等关键信息，在排查应用内存溢出、判断内存泄漏及分析 OOM 问题时有着不可替代的实践价值。建议搭配 `jhat`、MAT、VisualVM 等工具进一步分析 dump 文件，提升故障定位与诊断效率。

### 2.4. strace

#### 2.4.1. 命令的作用

strace 是一个强大的系统调用跟踪工具，用于监控和分析进程与 Linux 内核之间的交互。它可以跟踪进程执行时所调用的系统调用和接收到的信号，帮助开发者和系统管理员诊断程序问题、分析程序行为、调试应用程序以及进行性能分析。

#### 2.4.2. 常用参数及解释

基本用法：

```bash
strace [选项] 命令 [参数]
strace [选项] -p PID
```

指令及作用：

| 指令 | 作用 |
| -- | --- |
| -p PID | 跟踪指定进程 ID 的系统调用 |
| -f | 跟踪子进程的系统调用 |
| -o filename | 将输出重定向到指定文件 |
| -e trace=系统调用 | 只跟踪指定的系统调用 |
| -e trace=file | 只跟踪文件相关的系统调用 |
| -e trace=network | 只跟踪网络相关的系统调用 |
| -e trace=process | 只跟踪进程相关的系统调用 |
| -c | 统计每个系统调用的时间、调用次数和错误次数 |
| -t | 在每行输出前加上时间戳 |
| -tt | 显示微秒级时间戳 |
| -T | 显示每个系统调用的耗时 |
| -s size | 指定字符串的最大显示长度（默认 32） |
| -v | 显示详细信息，不省略结构体内容 |
| -x | 以十六进制显示字符串 |
| -xx | 以十六进制显示所有字符串 |

#### 2.4.3. 使用示例

1. 跟踪 ls 命令的系统调用：

    ```bash
    strace ls /tmp
    ```

    结果示例：

    ```bash
    execve("/bin/ls", ["ls", "/tmp"], 0x7fff8c9c5e80 /* 24 vars */) = 0
    brk(NULL)                               = 0x55a8b9c4a000
    arch_prctl(ARCH_SET_FS, 0x7f8a9c8a5540) = 0
    readlink("/proc/self/exe", "/bin/ls", 4096) = 7
    access("/etc/ld.so.preload", R_OK)      = -1 ENOENT (No such file or directory)
    openat(AT_FDCWD, "/etc/ld.so.cache", O_RDONLY|O_CLOEXEC) = 3
    fstat(3, {st_mode=S_IFREG|0644, st_size=94091, ...}) = 0
    mmap(NULL, 94091, PROT_READ, MAP_PRIVATE, 3, 0) = 0x7f8a9c88d000
    close(3)                                = 0
    ...
    ```

2. 跟踪正在运行的进程：

    ```bash
    strace -p 1234
    ```

    结果示例：

    ```bash
    strace: Process 1234 attached
    read(0, "hello\n", 1024)               = 6
    write(1, "hello\n", 6)                 = 6
    read(0, ^Cstrace: Process 1234 detached
    ```

3. 只跟踪文件相关的系统调用：

    ```bash
    strace -e trace=file cat /etc/passwd
    ```

    结果示例：

    ```bash
    execve("/bin/cat", ["cat", "/etc/passwd"], 0x7fff2c8b5e80 /* 24 vars */) = 0
    access("/etc/ld.so.preload", R_OK)      = -1 ENOENT (No such file or directory)
    openat(AT_FDCWD, "/etc/ld.so.cache", O_RDONLY|O_CLOEXEC) = 3
    openat(AT_FDCWD, "/lib/x86_64-linux-gnu/libc.so.6", O_RDONLY|O_CLOEXEC) = 3
    openat(AT_FDCWD, "/etc/passwd", O_RDONLY) = 3
    ```

4. 统计系统调用的使用情况：

    ```bash
    strace -c ls /tmp
    ```

    结果示例：

    ```bash
    % time     seconds  usecs/call     calls    errors syscall
    ------ ----------- ----------- --------- --------- ----------------
     28.57    0.000020           2        10           mmap
     14.29    0.000010           2         5           close
     14.29    0.000010           2         5           fstat
     11.43    0.000008           2         4           openat
      8.57    0.000006           6         1           write
      5.71    0.000004           4         1           munmap
      5.71    0.000004           4         1           brk
    ------ ----------- ----------- --------- --------- ----------------
    100.00    0.000070                    32         1 total
    ```

#### 2.4.4. 常用组合命令及使用技巧

1. 跟踪程序启动过程并保存到文件：

    ```bash
    strace -o trace.log -f ./myprogram
    ```

2. 实时监控进程的网络活动：

    ```bash
    strace -p $(pgrep nginx) -e trace=network -f
    ```

3. 分析程序的文件 I/O 性能：

    ```bash
    strace -T -e trace=read,write,open,close ./myprogram
    ```

4. 查找程序访问的配置文件：

    ```bash
    strace -e trace=openat,open program 2>&1 | grep -E "\.(conf|cfg|ini|xml|json)"
    ```

5. 监控多进程程序的系统调用：

    ```bash
    strace -f -o trace_%p.log ./multi_process_program
    ```

6. 调试网络连接问题：

    ```bash
    strace -e trace=socket,connect,bind,listen,accept curl http://example.com
    ```

7. 分析程序卡死原因：

    ```bash
    strace -p PID -T -tt
    ```

#### 2.4.5. 总结

strace 是 Linux 系统下非常重要的调试和分析工具，它能够帮助用户：

- 理解程序的运行机制和系统调用模式
- 诊断程序错误和性能问题
- 分析程序与系统资源的交互
- 调试复杂的多进程应用程序
- 监控程序的安全行为

合理使用 strace 可以大大提高问题诊断的效率，是系统管理员和开发人员必备的工具之一。需要注意的是，strace 会对程序性能产生一定影响，在生产环境中使用时需要谨慎。