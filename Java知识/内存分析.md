## 1. 内存泄漏排查工具详细使用指南

### 1.1. 一、系统级初步排查工具

#### 1.1.1. 系统内存监控

##### 1.1.1.1. top/htop - 实时内存监控

```bash
# 基础命令
top -p <PID>
htop -p <PID>

# 持续监控并保存到文件
top -b -n1 -p <PID> >> memory_monitor.log
```

**结果分析：**
- **VIRT**：虚拟内存大小
- **RES**：物理内存使用（RSS）
- **SHR**：共享内存
- **%MEM**：内存使用百分比

**关键指标：**

```
VIRT持续增长 → 可能存在内存泄漏
RES/VIRT比值过小 → 可能有大量虚拟内存未实际使用
%MEM持续上升 → 确认存在内存泄漏
```

**无法定位时下一步：**
- 如果 RES 稳定，VIRT 增长 → 使用**pmap**分析虚拟内存分布
- 如果 RES 持续增长 → 使用**jstat**检查 JVM 内存

##### 1.1.1.2. ps - 进程内存详情

```bash
# 查看进程内存统计
ps -o pid,ppid,rss,vsz,comm -p <PID>

# 查看进程内存映射概要
ps -eo pid,rss,vsz,comm | grep java

# 持续监控
watch -n 5 'ps -o pid,rss,vsz,comm -p <PID>'
```

**结果分析：**

```
RSS: 物理内存使用量（KB）
VSZ: 虚拟内存使用量（KB）

正常情况：RSS稳定或周期性波动
异常情况：RSS持续线性增长
```

#### 1.1.2. JVM 进程识别

```bash
# 找到Java进程PID
jps -v | grep YourAppName
# 或
ps aux | grep java | grep YourAppName
```

### 1.2. 二、JVM 堆内存分析工具

#### 1.2.1. jstat - JVM 内存统计

##### 1.2.1.1. 基础内存监控

```bash
# 查看堆内存使用情况（每5秒一次，共10次）
jstat -gc <PID> 5s 10

# 查看堆内存详细信息
jstat -gccapacity <PID>

# 查看GC统计
jstat -gcutil <PID> 5s
```

**结果分析：**

```
S0C, S1C: 年轻代中两个Survivor区的容量
S0U, S1U: 年轻代中Survivor区的使用量
EC, EU: Eden区的容量和使用量  
OC, OU: 老年代的容量和使用量
MC, MU: 元空间的容量和使用量

关键指标：
- OU持续增长且不下降 → 老年代内存泄漏
- EU频繁接近EC → 年轻代内存压力大
- MU持续增长 → 可能是类加载导致的元空间泄漏
```

**无法定位时下一步：**
- 如果 OU 持续增长 → 生成**heap dump**进行 MAT 分析
- 如果各项指标正常 → 检查**DirectMemory**

##### 1.2.1.2. 持续监控脚本

```bash
#!/bin/bash
PID=$1
LOG_FILE="gc_monitor_$(date +%Y%m%d_%H%M%S).log"

echo "开始监控PID: $PID"
echo "监控时间: $(date)" > $LOG_FILE

while true; do
    echo "$(date): " >> $LOG_FILE
    jstat -gcutil $PID >> $LOG_FILE
    echo "" >> $LOG_FILE
    sleep 60
done
```

#### 1.2.2. 生成 Heap Dump

```bash
# 生成heap dump文件
jcmd <PID> GC.run_finalization
jcmd <PID> GC.run
jmap -dump:live,format=b,file=heapdump_$(date +%Y%m%d_%H%M%S).hprof <PID>

# 如果jmap失败，使用jcmd
jcmd <PID> GC.run_finalization
jcmd <PID> GC.run  
jcmd <PID> VM.gc
jcmd <PID> Heap.dump /path/to/heapdump.hprof
```

#### 1.2.3. MAT (Memory Analyzer Tool) 分析

##### 1.2.3.1. MAT 安装和启动

```bash
# 下载MAT
wget https://eclipse.org/downloads/download.php?file=/mat/1.14.0/rcp/MemoryAnalyzer-1.14.0.20230315-linux.gtk.x86_64.zip

# 解压并启动
unzip MemoryAnalyzer-*.zip
./MemoryAnalyzer/MemoryAnalyzer -vmargs -Xmx4g -data ./workspace
```

##### 1.2.3.2. MAT 命令行分析

```bash
# 生成泄漏报告
./ParseHeapDump.sh heapdump.hprof org.eclipse.mat.api:suspects

# 生成直方图
./ParseHeapDump.sh heapdump.hprof org.eclipse.mat.api:overview

# 查找大对象
./ParseHeapDump.sh heapdump.hprof org.eclipse.mat.api:top_consumers
```

**MAT 分析要点：**
1. **泄漏嫌疑报告**：自动识别可能的内存泄漏
2. **支配树分析**：找到占用内存最大的对象
3. **直方图分析**：按类统计对象数量
4. **GC Root 分析**：找到对象无法回收的根因

**无法定位时下一步：**
- MAT 显示堆内存正常 → 检查**堆外内存**
- 发现大量 DirectByteBuffer → 使用**Arthas**分析

### 1.3. 三、堆外内存分析工具

#### 1.3.1. Arthas - 运行时 Java 诊断

##### 1.3.1.1. Arthas 安装和连接

```bash
# 下载并启动Arthas
curl -O https://arthas.aliyun.com/arthas-boot.jar
java -jar arthas-boot.jar

# 选择目标Java进程
# 或者直接连接指定PID
java -jar arthas-boot.jar <PID>
```

##### 1.3.1.2. 内存分析命令

```bash
# 查看JVM内存使用详情
memory

# 实时监控面板
dashboard

# 查看JVM信息
jvm

# 查看DirectByteBuffer使用情况
mbean java.nio:type=BufferPool,name=direct

# 强制GC
ognl '#runtime=@java.lang.Runtime@getRuntime(), #runtime.gc()'

# 查看某个类的实例数
sc -d java.nio.DirectByteBuffer

# 查看DirectByteBuffer实例
vmtool --action getInstances --className java.nio.DirectByteBuffer --limit 10
```

**结果分析要点：**

```bash
# memory命令输出分析
heap: 堆内存使用情况
nonheap: 非堆内存使用情况  
direct: 直接内存使用量 ← 重点关注
mapped: 内存映射文件大小

# 异常情况
direct内存持续增长 → DirectBuffer泄漏
nonheap持续增长 → 元空间或其他非堆区域泄漏
```

**无法定位时下一步：**
- direct 内存异常 → 分析 **Netty** 等框架的 DirectBuffer 使用
- 所有 JVM 指标正常 → 使用 **NMT** 分析 native 内存

#### 1.3.2. NMT (Native Memory Tracking)

##### 1.3.2.1. 启用 NMT

```bash
# 启动JVM时添加参数
-XX:NativeMemoryTracking=detail

# 或者修改启动脚本
JAVA_OPTS="$JAVA_OPTS -XX:NativeMemoryTracking=detail"
```

##### 1.3.2.2. NMT 命令详解

```bash
# 查看内存概览
jcmd <PID> VM.native_memory summary

# 查看详细内存分配
jcmd <PID> VM.native_memory detail

# 建立基线（应用启动后执行）
jcmd <PID> VM.native_memory baseline

# 与基线对比（运行一段时间后执行）
jcmd <PID> VM.native_memory summary.diff
jcmd <PID> VM.native_memory detail.diff

# 按内存分类查看
jcmd <PID> VM.native_memory summary scale=MB

# 关闭NMT
jcmd <PID> VM.native_memory shutdown
```

##### 1.3.2.3. NMT 结果分析脚本

```bash
#!/bin/bash
PID=$1
OUTPUT_DIR="nmt_analysis_$(date +%Y%m%d_%H%M%S)"
mkdir -p $OUTPUT_DIR

echo "=== NMT内存分析开始 ===" 
echo "PID: $PID"
echo "时间: $(date)"

# 生成基线
echo "生成基线..."
jcmd $PID VM.native_memory baseline

# 等待一段时间让应用运行
echo "等待5分钟后进行对比分析..."
sleep 300

# 生成对比报告
echo "生成对比报告..."
jcmd $PID VM.native_memory summary.diff > $OUTPUT_DIR/memory_diff.txt
jcmd $PID VM.native_memory detail.diff > $OUTPUT_DIR/memory_detail_diff.txt

# 解析关键指标
echo "=== 关键内存增长分析 ===" > $OUTPUT_DIR/analysis.txt
grep -E "(Total|Java Heap|Class|Thread|Code|GC|Compiler|Internal|Other|Symbol|Native Memory Tracking|Arena Chunk|Tracing|Logging|Arguments|Module|Synchronizer|Serviceability)" $OUTPUT_DIR/memory_diff.txt >> $OUTPUT_DIR/analysis.txt

echo "分析完成，结果保存在: $OUTPUT_DIR"
```

**NMT 结果分析要点：**

```
Java Heap: 堆内存使用
Class: 类加载器相关内存  
Thread: 线程栈内存
Code: 编译代码内存
GC: 垃圾收集器内存
Internal: JVM内部结构
Other: 其他（通常包含DirectBuffer）
Symbol: 符号表
Arena Chunk: 内存块管理

关键指标：
- Total committed持续增长 → 确认存在native内存泄漏
- Other大幅增长 → 可能是DirectBuffer或JNI调用
- Thread增长 → 线程泄漏
- Class增长 → 类加载器泄漏
```

**无法定位时下一步：**
- NMT 显示 Other 或 Unknown 增长 → 使用 **pmap** 定位具体内存区域
- NMT 无法追踪的内存增长 → 使用 **async-profiler** 分析

### 1.4. 四、高级分析工具

#### 1.4.1. async-profiler

##### 1.4.1.1. 下载和安装

```bash
# 下载async-profiler
wget https://github.com/jvm-profiling-tools/async-profiler/releases/download/v2.9/async-profiler-2.9-linux-x64.tar.gz
tar -xzf async-profiler-2.9-linux-x64.tar.gz
cd async-profiler-2.9-linux-x64
```

##### 1.4.1.2. 内存分析命令

```bash
# CPU火焰图
./profiler.sh -e cpu -d 60 -f cpu_profile.html <PID>

# 内存分配火焰图  
./profiler.sh -e alloc -d 60 -f alloc_profile.html <PID>

# Native内存分析（新版本支持）
./profiler.sh -e malloc -d 60 -f malloc_profile.html <PID>

# 特定事件分析
./profiler.sh -e JavaObjectAllocationInNewTLAB -d 60 -f tlab_profile.html <PID>

# 生成JFR文件
./profiler.sh -e alloc -d 60 -o jfr -f profile.jfr <PID>

# 实时监控模式
./profiler.sh -e alloc -i 10s --loop -f alloc_monitor.html <PID>
```

##### 1.4.1.3. 使用 Arthas 集成的 async-profiler

```bash
# 在Arthas中使用
profiler start --event alloc

# 60秒后生成报告
profiler stop --format html --file /tmp/alloc_profile.html

# 查看支持的事件
profiler list

# CPU和内存组合分析
profiler start --event cpu,alloc --interval 10000000
```

**结果分析要点：**
- 火焰图宽度表示消耗占比
- 火焰图高度表示调用链深度  
- 重点关注内存分配热点方法
- 分析是否有异常的大对象分配

**无法定位时下一步：**
- 如果火焰图显示正常 → 使用**pmap**进行系统级分析
- 如果发现 JNI 调用热点 → 分析**JNI 内存泄漏**

#### 1.4.2. pmap - 进程内存映射分析

##### 1.4.2.1. pmap 命令详解

```bash
# 查看进程内存映射
pmap <PID>

# 显示更详细的信息
pmap -x <PID>

# 显示设备信息
pmap -d <PID>  

# 显示扩展格式
pmap -X <PID>

# 持续监控并保存
watch -n 30 'pmap -x <PID>' > pmap_monitor.log
```

##### 1.4.2.2. pmap 分析脚本

```bash
#!/bin/bash
PID=$1
BASELINE_FILE="pmap_baseline_$(date +%Y%m%d_%H%M%S).txt"
CURRENT_FILE="pmap_current_$(date +%Y%m%d_%H%M%S).txt"

# 生成基线
echo "生成基线内存映射..."
pmap -x $PID > $BASELINE_FILE

echo "等待300秒后生成对比..."
sleep 300

# 生成当前状态
pmap -x $PID > $CURRENT_FILE

# 对比分析
echo "=== 内存映射变化分析 ===" > memory_mapping_diff.txt
echo "基线文件: $BASELINE_FILE" >> memory_mapping_diff.txt
echo "当前文件: $CURRENT_FILE" >> memory_mapping_diff.txt
echo "" >> memory_mapping_diff.txt

# 提取关键信息
echo "=== RSS变化分析 ===" >> memory_mapping_diff.txt
echo "基线总RSS:" >> memory_mapping_diff.txt
tail -n 1 $BASELINE_FILE >> memory_mapping_diff.txt
echo "当前总RSS:" >> memory_mapping_diff.txt  
tail -n 1 $CURRENT_FILE >> memory_mapping_diff.txt

# 找出显著增长的内存区域
echo "=== 显著增长的内存区域 ===" >> memory_mapping_diff.txt
awk 'NR==FNR{a[NR]=$3; next} {if($3-a[FNR]>10240) print "增长: " ($3-a[FNR]) "KB - " $0}' $BASELINE_FILE $CURRENT_FILE >> memory_mapping_diff.txt
```

**pmap 结果分析：**

```
Address: 内存地址
Kbytes: 该段大小(KB)
RSS: 物理内存占用
Dirty: 脏页大小
Mode: 权限模式
Mapping: 映射的文件或库

关键指标：
- 大量[anon]区域增长 → 匿名内存分配（可能是malloc）
- 库文件(.so)增长 → 动态库加载
- [heap]区域异常 → 堆内存问题
- [stack]区域增长 → 栈内存问题
```

### 1.5. 五、工具组合使用策略

#### 1.5.1. 排查决策树

```
1. 发现内存问题
   ↓
2. ps/top确认RSS持续增长
   ↓
3. jstat检查JVM堆内存
   ├─ 堆内存异常 → MAT分析heap dump
   └─ 堆内存正常 → 继续堆外分析
   ↓
4. Arthas检查DirectBuffer
   ├─ DirectBuffer异常 → 分析Netty等框架
   └─ DirectBuffer正常 → 继续native分析
   ↓  
5. NMT分析native内存
   ├─ NMT能追踪到增长 → 分析对应模块
   └─ NMT无法追踪 → 使用pmap/async-profiler
   ↓
6. pmap分析系统内存映射
   ↓
7. async-profiler生成火焰图
   ↓
8. 结合业务代码分析
```

#### 1.5.2. 监控脚本模板

```bash
#!/bin/bash
# 综合内存监控脚本

PID=$1
MONITOR_DIR="memory_monitor_$(date +%Y%m%d_%H%M%S)"
mkdir -p $MONITOR_DIR

echo "开始综合内存监控，PID: $PID"

# 1. 系统内存监控
echo "启动系统内存监控..."
while true; do
    echo "$(date): $(ps -o rss,vsz -p $PID --no-headers)" >> $MONITOR_DIR/system_memory.log
    sleep 60
done &
SYSTEM_PID=$!

# 2. JVM内存监控
echo "启动JVM内存监控..."  
while true; do
    echo "$(date):" >> $MONITOR_DIR/jvm_memory.log
    jstat -gcutil $PID >> $MONITOR_DIR/jvm_memory.log 2>/dev/null
    echo "" >> $MONITOR_DIR/jvm_memory.log
    sleep 60
done &
JVM_PID=$!

# 3. NMT监控（如果启用）
if jcmd $PID VM.native_memory summary >/dev/null 2>&1; then
    echo "启动NMT监控..."
    jcmd $PID VM.native_memory baseline
    while true; do
        echo "$(date):" >> $MONITOR_DIR/nmt_memory.log  
        jcmd $PID VM.native_memory summary.diff >> $MONITOR_DIR/nmt_memory.log 2>/dev/null
        echo "" >> $MONITOR_DIR/nmt_memory.log
        sleep 300
    done &
    NMT_PID=$!
fi

# 清理函数
cleanup() {
    echo "停止监控..."
    kill $SYSTEM_PID $JVM_PID $NMT_PID 2>/dev/null
    echo "监控数据保存在: $MONITOR_DIR"
}

trap cleanup EXIT
echo "监控运行中，按Ctrl+C停止..."
wait
```

这个完整的工具使用指南涵盖了从系统级到应用级的各种内存分析工具，每个工具都有具体的使用命令、结果分析方法和后续分析方向，可以帮助您系统性地排查各种内存泄漏问题。

## 2. 内存分析使用工具

### 2.1. jstat

#### 2.1.1. 命令的作用

`jstat`（Java Virtual Machine Statistics Monitoring Tool）是 Java 自带的一款 JVM 性能监控工具，用于统计和监控正在运行的 Java 应用的各种虚拟机统计信息。主要用来监控 Java 堆、垃圾回收（GC）行为、类装载、JIT 编译等信息。`jstat` 适合在分析 Java 程序运行时的性能瓶颈、GC 问题等场景下使用。

#### 2.1.2. 常用参数及解释

基本用法：

```bash
jstat [option] <vmid> [interval] [count]
```

- **option**: 要查询的统计数据类型（如 GC、类加载等）。
- **vmid**: 目标 Java 进程的 PID。
- **interval**:（可选）刷新时间间隔（秒或毫秒）。
- **count**:（可选）输出次数。

常见 option 及作用：

| 参数             | 作用说明                                         |
|------------------|------------------------------------------------|
| -class           | 显示类加载、卸载信息                             |
| -compile         | 显示 JIT 编译相关统计信息                          |
| -gc              | 显示与垃圾回收相关的数据（堆区各分区容量等）     |
| -gccapacity      | 各内存区域当前容量和最大容量等                   |
| -gcutil          | 各堆区域利用率和 GC 统计                           |
| -gccause         | 垃圾回收统计数据和 GC 产生的原因                    |
| -gcnew           | 新生代统计数据                                   |
| -gcnewcapacity   | 新生代容量相关数据                               |
| -gcold           | 年老代统计数据                                   |
| -gcoldcapacity   | 年老代容量相关数据                               |
| -printcompilation| 已编译方法列表                                   |
| -snap            | 同步快照所有统计数据（减少偏移）                 |

#### 2.1.3. 使用示例

1. 显示进程 12345 的 GC 各区空间相关数据：

    ```bash
    jstat -gc 12345
    ```

    结果示例：

    ```bash
     S0C    S1C    S0U    S1U      EC       EU        OC         OU      MC      MU     CCSC    CCSU     YGC     YGCT    FGC    FGCT     GCT
    1024.0 1024.0   0.0   1016.0  8192.0   345.8   16384.0    2345.6   22048.0 20433.9 2688.0 2434.4    7     0.091   2     0.076   0.167
    ```

2. 每 1 秒监控 10 次 GC 利用率：

    ```bash
    jstat -gcutil 12345 1000 10
    ```

    结果示例：

    ```bash
      S0     S1     E      O      M     CCS    YGC   YGCT    FGC   FGCT     GCT
      0.00 100.00  10.36  23.81 82.78  83.24     7   0.091      2   0.076    0.167
      0.00 100.00  10.36  23.81 82.78  83.24     7   0.091      2   0.076    0.167
      ...
    ```

3. 查看 JIT 编译统计：

    ```bash
    jstat -compile 12345
    ```

    结果示例：

    ```bash
    Compiled Failed Invalid Time FailedType FailedMethod
         109     0       0   12.00
    ```

4. 观察类加载信息：

    ```bash
    jstat -class 12345 2000 5
    ```

    结果示例：

    ```bash
    Loaded  Bytes  Unloaded  Bytes   Time
      3245  712678   650     10456   3.56
    ```

#### 2.1.4. 常用组合命令及使用技巧

1. watch 等工具配合观察 GC 数据高频刷新：

    ```bash
    watch -n 1 "jstat -gcutil 12345"
    ```

2. 与 grep 等命令结合过滤关键信息：

    ```bash
    jstat -gcutil 12345 1000 5 | grep -v "^ *S0"
    ```

3. 将监控日志落盘用于后续分析：

    ```bash
    jstat -gc 12345 1000 300 > gc.log
    ```

4. 查询所有 Java 进程后对批量 jstat 监控：

    ```bash
    for pid in $(jps | awk '{print $1}'); do echo "pid=$pid"; jstat -gcutil $pid 1000 1; done
    ```

#### 2.1.5. 总结

`jstat` 是监控和分析 Java 运行时垃圾回收、内存利用、类加载及 JIT 编译等信息的轻量级利器。无需重启应用，即可快速定位 JVM 性能问题，是调优与故障诊断常用工具。配合 `watch`、`grep` 等命令，可实现更灵活高效的数据获取和分析。熟悉各参数和输出解释，有助于高效地监控和解决 Java 程序的瓶颈问题。

### 2.2. jcmd

#### 2.2.1. 命令的作用

`jcmd` 是 Java Development Kit (JDK) 提供的一个命令行工具，主要用于和正在运行中的 Java 进程进行交互，支持多种诊断和监控操作。使用 `jcmd` 可以执行如生成堆转储、触发垃圾回收、打印线程信息、查看 JVM 参数、动态改变 JVM 参数等操作，是 Java 运维和调优中非常重要的工具。

#### 2.2.2. 常用参数及解释

基本用法：

```bash
jcmd <pid | main-class> <command> [options]
```

| 指令 | 作用 |
|--------|------------------------------------------------|
| help         | 显示所有可用命令或指定命令的帮助信息    |
| VM.version   | 打印 JVM 版本信息                       |
| VM.flags     | 打印 JVM 启动参数                       |
| VM.command_line | 打印应用程序启动命令行            |
| GC.heap_dump <file> | 将 Java 堆导出到指定文件      |
| GC.run       | 触发一次垃圾回收                       |
| GC.class_histogram | 打印类实例的统计信息           |
| Thread.print | 打印线程堆栈信息                       |
| VM.system_properties | 打印系统属性                  |
| VM.uptime    | 打印 JVM 进程已运行时间                 |

要获取目标进程 pid，可运行无参数的 `jcmd`，会显示当前系统上所有 Java 进程及其 pid。

#### 2.2.3. 使用示例

1. 查看当前运行中的所有 Java 进程：

    ```bash
    jcmd
    ```

    结果示例：

    ```bash
    12345 org.example.Main
    23456 com.example.AnotherApp
    ```

2. 打印 JVM 版本信息：

    ```bash
    jcmd 12345 VM.version
    ```

    结果示例：

    ```bash
    12345:
    Java HotSpot(TM) 64-Bit Server VM version 17.0.1+12-LTS-39
    ```

3. 导出堆转储：

    ```bash
    jcmd 12345 GC.heap_dump /tmp/heapdump.hprof
    ```

    结果示例：

    ```bash
    12345:
    Heap dump file created
    ```

4. 打印线程信息：

    ```bash
    jcmd 12345 Thread.print
    ```

    结果示例：

    ```
    12345:
    2024-06-01 09:12:56
    Full thread dump Java HotSpot(TM) 64-Bit Server VM (17.0.1+12-LTS-39 mixed mode, sharing):
    
    "main" #1 prio=5 os_prio=0 tid=0x00007f7b7c001000 nid=0x3f48 runnable [0x00007f7b81244000]
       java.lang.Thread.State: RUNNABLE
         at java.io.FileInputStream.readBytes(Native Method)
         ...
    ```

5. 查看系统属性：

    ```bash
    jcmd 12345 VM.system_properties
    ```

    结果示例（部分）：

    ```bash
    java.home = /usr/lib/jvm/java-17-openjdk-amd64
    user.dir = /home/user/project
    os.name = Linux
    ...
    ```

#### 2.2.4. 常用组合命令及使用技巧

1. 查询支持的所有命令：

    ```bash
    jcmd 12345 help
    ```

2. 查看某一命令的详细帮助：

    ```bash
    jcmd 12345 help GC.heap_dump
    ```

3. 连续多次导出堆统计信息做内存泄漏分析（自动化脚本中常用）：

    ```bash
    for i in {1..5}; do jcmd 12345 GC.class_histogram > histo_$i.txt; sleep 60; done
    ```

4. 查询所有 JVM 系统信息，用于问题排查：

    ```bash
    jcmd 12345 VM.flags
    jcmd 12345 VM.system_properties
    jcmd 12345 VM.command_line
    ```

5. 多进程批量操作（如所有 Java 进程线程 dump）：

    ```bash
    for pid in $(jcmd | awk '{print $1}'); do jcmd $pid Thread.print > thread_dump_$pid.txt; done
    ```

#### 2.2.5. 总结

`jcmd` 是功能极其丰富且灵活的 Java 进程诊断与运维工具，可进行线程、内存、GC、类统计等几乎所有关键监控和调优操作。它的优势在于命令简单、适配新 JVM 功能，无需配置目标进程即可操作，非常适合线上问题排查和性能分析。熟练掌握 `jcmd`，可以大大提升 Java 运维与故障诊断的效率。

### 2.3. jmap

#### 2.3.1. 命令的作用

`jmap`（Java Memory Map）是 JDK 提供的用于内存分析和调试的命令行工具。它主要用于生成或分析 Java 进程的堆转储（heap dump）文件、查看堆内存、perm 区、类的实例分布等详细运行时内存信息。`jmap` 支持与正在运行的 Java 进程直接交互，是排查内存泄漏、分析内存使用情况时的常用工具。

#### 2.3.2. 常用参数及解释

基本用法：

```bash
jmap [option] <pid>
```

常用参数（option）及作用说明：

| 参数                | 作用说明                                                         |
|---------------------|------------------------------------------------------------------|
| -heap               | 显示堆配置概要，包括各内存区域的使用情况、垃圾收集器信息等         |
| -histo[:live]       | 显示堆中各类对象的数量和占用空间（:live 只统计存活对象）           |
| -dump:<opts>        | 生成 heap dump 文件（用于后续分析，比如用 MAT 或 VisualVM 打开）     |
| -finalizerinfo      | 显示等待 finalization queue 处理的对象                            |
| -clstats            | 显示类加载器详细统计信息（JDK 8+、部分版本/平台支持）              |
| -F                  | 强制模式，常和 -dump 等连用，适用于某些不可响应的 JVM 进程           |
| -J<flag>            | 传递参数给 jmap 启动的 JVM，如 -J-Xmx512m                         |

#### 2.3.3. 使用示例

1. 查看 JVM 堆内存概要信息：
    
    ```bash
    jmap -heap 12345
    ```
    
    结果示例：
    
    ```
    Attaching to process ID 12345, please wait...
    Debugger attached successfully.
    Server compiler detected.
    JVM version is 17.0.1+12-LTS-39
    ...
    Heap Configuration:
       MinHeapFreeRatio         = 40
       MaxHeapFreeRatio         = 70
       MaxHeapSize              = 4294967296 (4096.0MB)
    ...
    ```

2. 生成 heap dump 文件（用于 MAT、VisualVM、JProfiler 等工具分析）：
    
    ```bash
    jmap -dump:format=b,file=/tmp/heapdump_12345.hprof 12345
    ```
    
    结果示例：
    
    ```
    Dumping heap to /tmp/heapdump_12345.hprof ...
    Heap dump file created
    ```

3. 查看对象数量和内存占用统计：
    
    ```bash
    jmap -histo 12345
    ```
    
    结果示例（部分）：
    
    ```
     num     #instances         #bytes  class name
    ----------------------------------------------
       1:        345678       17283952  [B
       2:        131072        3145728  java.lang.String
       3:         32768        1048576  [Ljava.lang.Object;
    ...
    Total         999999       55555555
    ```

4. 只统计存活对象分布：
    
    ```bash
    jmap -histo:live 12345
    ```

5. 强制 dump 某些响应缓慢的进程（加 -F）：
    
    ```bash
    jmap -F -dump:format=b,file=/tmp/heapdump_12345.hprof 12345
    ```

6. 显示等待 finalizer 的对象信息：
    
    ```bash
    jmap -finalizerinfo 12345
    ```
    
    结果示例：
    
    ```
    Unfinalized objects awaiting finalization...
    Class
    ----------------------
    java.io.FileInputStream
    java.util.zip.ZipFile
    ...
    ```

#### 2.3.4. 常用组合命令及使用技巧

1. 结合 jps 查询目标 Java 进程：
    
    ```bash
    jps -l
    jmap -heap <pid>
    ```

2. 联合 grep、sort 查找 top 类型对象（如大对象、泄漏）：
    
    ```bash
    jmap -histo:live 12345 | head -n 20
    jmap -histo 12345 | grep "java.lang.String" 
    ```

3. 自动化定时 heap dump 排查内存泄漏：
    
    ```bash
    while true; do jmap -dump:format=b,file=/tmp/heapdump_$(date +'%Y%m%d_%H%M%S').hprof 12345; sleep 1800; done
    ```

4. 对比多次 histo 差异定位增长的对象种类：
    
    ```bash
    jmap -histo:live 12345 > histo_before.txt
    # 执行操作后
    jmap -histo:live 12345 > histo_after.txt
    diff histo_before.txt histo_after.txt
    ```

#### 2.3.5. 总结

`jmap` 是 Java 应用内存分析的核心工具之一，它可以轻松地获取堆转储文件、类实例分布、堆区使用状况等关键信息，在排查应用内存溢出、判断内存泄漏及分析 OOM 问题时有着不可替代的实践价值。建议搭配 `jhat`、MAT、VisualVM 等工具进一步分析 dump 文件，提升故障定位与诊断效率。