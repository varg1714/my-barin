#Mysql


## 1. 优化技术原理

### 1.1. Mysql 是如何工作的？

一条 SQL 语句在 Mysql 内部是按何种顺序执行的呢？每一步又完成了什么事情呢？可以使用下面一张图片进行概括：

![](https://r2.129870.xyz/img/20220508232841.png)

Mysql 分为两个大块，一块为 Server 层，一层为引擎层。Server 层负责管理连接，进行词法语法分析与 SQL 语句执行，执行过程中调用存储引擎提供的 API 读写数据。Server 层不管理数据，它不知道数据是如何存储的，亦不知道数据存放在哪，甚至连数据存放在磁盘还是内存中都不知道，更别提 B+树是什么东西了。

**与数据有关的操作都在引擎层完成**，引擎层提供了数据存储读取的实现。数据是存放在内存还是磁盘，数据是按 B+树索引还是哈希索引，是按 LSM 日志结构存储还是按块/页存储，这都是引擎层的工作。

引擎层为 Server 层屏蔽了数据管理的细节，使 Server 层仅关注 SQL 语句本身而不关心数据。这样的分工使得 Server 层与引擎层的边界非常清晰，也就有了许多引擎供我们替换使用。如 Innodb，MyISAM，Memory，CSV 引擎等等。

### 1.2. Mysql 的索引是什么样的？

#### 1.2.1. 索引的组织结构

Mysql 使用 B+树组织数据，那么 B+树是如何存在的呢？数据表中的主键索引与我们建立的二级索引又有何区别？

![](https://r2.129870.xyz/img/20220810160805.svg)

对于主键索引，索引树上的每一个非叶子节点只包含主键值，树上叶子节点为物理磁盘的完整数据，数据库中的一条数据就是 B+树的一个叶子节点。

对于二级索引，节点值为二级索引列中的所有列值+该数据对应的主键值。二级索引查询时，首先在二级索引树中查找目标数据，目标数据定位到后通过隐藏的主键列去主键索引列查询完整的数据，这一步就是我们常说的**回表**。

索引数据的组织由引擎层管理，即 Server 层经过分析器与优化器决策后选择的哪个索引进行查询，而查询的具体实现就是上面看到的树的搜索过程。索引的查询时间复杂度就是树的搜索复杂度，即 O (log (N))，并非 O (1)。

#### 1.2.2. Server 层与引擎层数据查询的细节

Server 层与引擎层一个重要的交互是**引擎层只根据索引查询数据**。这意味着什么呢？如果一条 SQL 中 where 语句包含多个条件，那么这些条件并不都是在引擎层过滤的。如 `select * from table where a = 1 and b = 2 and c = 3 and d = 4;` 这条语句：若 (a, b) 两列建立索引的情况下，Server 层传递给引擎层的查询条件是 `a = 1 and b = 2`，此时引擎层走二级索引树查询数据，定位数据后回表查询完整数据返回给 Server 层；若该表上无索引，则引擎层直接扫描主键索引树，这就是我们常说的**全表扫描**。

显然 `a = 1 and b = 2` 条件查询得到的结果并非全都是满足条件的数据，Server 层需要对查询结果进行进一步过滤，若引擎层返回的数据满足 `c = 3 and d = 4` 才将其发送给客户端，否则丢弃这条数据。

Why？为什么引擎层只查询索引列中的数据呢？这涉及到职责分工的问题，**引擎层的作用是负责存取数据，不负责数据的逻辑运算**。想象简单的条件过滤或许引擎层可以直接实现，那么复杂的函数计算呢？数据库提供了大量的计算函数，关于时间的，关于编码的，关于数学运算的，林林种种，如果这些函数写在 where 条件中呢？如 `where unix_timestamp(column) * 3 = 12`，这意味这引擎层不仅需要**处理大量的运算，还需要实现所有的函数计算逻辑**。这对引擎层的扩展性是致命的，这意味着引擎层需要兼容非常多的东西，做非常多的事情，这违反了引擎层的工作职责。

所以在综合情况的考虑下，引擎层与 Server 层各司其职。引擎层只负责管理数据，Server 层考虑 SQL 的各种细节，这是一种模块拆分的思想。

### 1.3. 一条 SQL 是何如执行的？

在上面看到了一条 SQL 在 Server 层和引擎层流转的细节，那么一条完整的 SQL 又是如何执行的呢？

```sql

select table1.a, count(table1.b), distinct (table1.c)  
from table1,table2  
where tabl1.a = table2.a and table1.a = 1 and table2.b =2  
group by table1.a  
having table1.a > 1  
order by table2.b;

```

#### 1.3.1. SQL 语句的执行过程

对于上面这条 SQL，大致的执行顺序如下：
1. from 表做笛卡尔积
2. 执行 on 过滤
3. 添加外部行，这里在左连接或右连接才会有
4. 执行 where 过滤
5. 执行 group By 分组
6. 执行 having 过滤
7. 执行 select 列选择
8. 执行 distinct 过滤数据 (这里会生成临时表，在过滤列上加唯一索引)
9. 执行 order by 语句
10. 执行 limit 语句

#### 1.3.2. ON 和 WHERE 的区别

1. 内连接
	对于内连接，如 `t1 join t2 on t1.a = t2.a where t2.b > 1` 和 `t1 join t2 on t1.a = t2.a and t2.b > 1` 的执行效果是一样的。
1. 左/右外连接
	对于左右外连接则不同了，对于 `t1 left join t2 on t1.a = t2.a and t2.b > 1` 这条语句，where 条件不会影响查询表的数量，始终是 t1 表的全量数据。

	对于 `t1 left join t2 on t1.a = t2.a where t2.b > 1` 这条语句，where 条件会影响查询表的数量，对于 on 连接的结果，会使用 where 中的条件过滤掉不满足该条件的数据。

需要注意的是，每个关键字的执行都是很复杂的一个过程，因此上面的流程只能简单的概括关键字执行的顺序，实际实现过程中各个关键字内部都会做很多的逻辑与优化。

### 1.4. 连接查询是如何实现的？

对于一条 join 语句，执行实现是怎样的呢？

```sql
select *  
from table1  
         left join t1 on t1.a = t2.a and t1.b = t2.b  
where t1.c = 1  
  and t2.d = 2;
```

以上面这条 SQL 为例，对于关联查询的实现如下：
1. 根据 t1 表上的索引列执行索引查询，如 a 列有索引的话走 a 列的索引树，没有则全表查询走主键索引树。
1. 引擎层从表 t1 中读入一行满足 a 字段条件的数据 R。
2. Server 层判断数据行 R 中中其他非索引字段是否满足条件，如 `c = 1`，若不满足条件，再次从引擎层获取。
4. 对于满足 t1 表的数据 R，以 R 作为条件去 t2 表查询。对于 t2 表查询同样是有索引走索引，无索引全表扫描。
5. Server 层判断组合的数据是否满足 t2 表非索引列的其他条件，若不满足再次查询。
3. 取出表 t2 中满足条件的行，跟 R 组成一行，作为结果集的一部分。
4. 重复执行步骤 1 到 6，直到表 t1 的末尾循环结束。

这个过程是先遍历表 t1，然后根据从表 t1 中取出的每行数据中的 a 值，去表 t2 中查找满足条件的记录。在形式上，这个过程就跟我们写程序时的嵌套查询类似，并且可以用上被驱动表的索引，所以我们称之为 `Index Nested-Loop Join`，简称 NLJ。

上面的例子对于两张表都有索引，若表没有索引，那么针对这些情况还有一些优化措施。如 MRR 策略，BAK 算法等，这里不再展开。

上面的一个细节是不管左表还是右表，都会尽可能的使用索引查询。我们常说的小表关联大表不是按照表数据量来区分的，而是看满足索引条件的数据量。**索引命中率越高，数据查询条数越少的表才是小表**。

### 1.5. 索引下推是什么？

上面提到了索引树搜索的过程，实际上对于索引树的搜索并不是一定会用到索引，在部分场景下索引会失效，如查询条件索引字段用上了函数，进行了范围查询等。如 `where a > 1` 或 `where unix_timestamp(column) * 3 = 12` 这种情况。

假设一个表包含有关人员及其地址的信息，并且该表具有定义为的索引 `INDEX (zipcode, lastname, firstname)`。如果我们知道一个人的 `zipcode` 价值但不确定姓氏，我们可以这样搜索：

```sql
SELECT *  
FROM people  
WHERE zipcode = '95054'  
  AND lastname LIKE '%etrunia%'  
  AND address LIKE '%Main Street%';
```

MySQL 可以使用索引来扫描具有 `zipcode='95054'`，第二部分 ( `lastname LIKE '%etrunia%'`) 不能用于限制必须扫描的行数，因此如果没有索引条件下推，此查询必须检索所有满足 `zipcode='95054'` 条件的数据，即引擎层回表找到所有满足该条件的数据，再交由 Server 层判断。

使用索引条件下推，MySQL `lastname LIKE '%etrunia%'` 在回表读取整个表行之前检查该部分，若不满足条件，则不会进行回表查询。

需要注意的是目前索引下推支持 WHERE 条件中的索引字段，且还有一些其他限制，具体可以参考[详细文档](https://dev.mysql.com/doc/refman/5.7/en/index-condition-pushdown-optimization.html)。

![](https://r2.129870.xyz/img/20220810170853.png)