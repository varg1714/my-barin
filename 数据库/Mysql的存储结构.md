#数据库 #Mysql 

# 1. Mysql 的编码集

## 1.1. Mysql 支持的编码集

`utf8` 字符集表示一个字符需要使用 1～4 个字节，但是我们常用的一些字符使用 1～3 个字节就可以表示了。而在 `MySQL` 中字符集表示一个字符所用最大字节长度在某些方面会影响系统的存储和性能，所以设计 `MySQL` 的大叔偷偷的定义了两个概念：

- `utf8mb3` ：阉割过的 `utf8` 字符集，只使用 1～3 个字节表示字符。
- `utf8mb4` ：正宗的 `utf8` 字符集，使用 1～4 个字节表示字符。

有一点需要大家十分的注意，在 `MySQL` 中 `utf8` 是 `utf8mb3` 的别名，所以之后在 `MySQL` 中提到 `utf8` 就意味着使用 1~3 个字节来表示一个字符，如果大家有使用 4 字节编码一个字符的情况，比如存储一些 emoji 表情啥的，那请使用 `utf8mb4`。

其实准确的说，utf8 只是 Unicode 字符集的一种编码方案，Unicode 字符集可以采用 utf8、utf16、utf32 这几种编码方案，utf8 使用 1～4 个字节编码一个字符，utf16 使用 2 个或 4 个字节编码一个字符，utf32 使用 4 个字节编码一个字符。

通过语句 `SHOW (CHARACTER SET|CHARSET) [LIKE 匹配的模式];` 可以查询 Mysql 支持的字符集。

## 1.2. Mysql 字符集的比较规则

比较规则的作用通常体现比较字符串大小的表达式以及对某个字符串列进行排序中。一种字符集可能对应着若干种比较规则，`MySQL` 支持的字符集就已经非常多了，所以支持的比较规则更多，我们先只查看一下 `utf8` 字符集下的比较规则：

```sql

mysql> SHOW COLLATION LIKE 'utf8\_%';
+--------------------------+---------+-----+---------+----------+---------+
| Collation                | Charset | Id  | Default | Compiled | Sortlen |
+--------------------------+---------+-----+---------+----------+---------+
| utf8_general_ci          | utf8    |  33 | Yes     | Yes      |       1 |
| utf8_bin                 | utf8    |  83 |         | Yes      |       1 |
| utf8_unicode_ci          | utf8    | 192 |         | Yes      |       8 |
| utf8_icelandic_ci        | utf8    | 193 |         | Yes      |       8 |
| utf8_latvian_ci          | utf8    | 194 |         | Yes      |       8 |
| utf8_romanian_ci         | utf8    | 195 |         | Yes      |       8 |
| utf8_slovenian_ci        | utf8    | 196 |         | Yes      |       8 |
| utf8_polish_ci           | utf8    | 197 |         | Yes      |       8 |
| utf8_estonian_ci         | utf8    | 198 |         | Yes      |       8 |
| utf8_spanish_ci          | utf8    | 199 |         | Yes      |       8 |
| utf8_swedish_ci          | utf8    | 200 |         | Yes      |       8 |
| utf8_turkish_ci          | utf8    | 201 |         | Yes      |       8 |
| utf8_czech_ci            | utf8    | 202 |         | Yes      |       8 |
| utf8_danish_ci           | utf8    | 203 |         | Yes      |       8 |
| utf8_lithuanian_ci       | utf8    | 204 |         | Yes      |       8 |
| utf8_slovak_ci           | utf8    | 205 |         | Yes      |       8 |
| utf8_spanish2_ci         | utf8    | 206 |         | Yes      |       8 |
| utf8_roman_ci            | utf8    | 207 |         | Yes      |       8 |
| utf8_persian_ci          | utf8    | 208 |         | Yes      |       8 |
| utf8_esperanto_ci        | utf8    | 209 |         | Yes      |       8 |
| utf8_hungarian_ci        | utf8    | 210 |         | Yes      |       8 |
| utf8_sinhala_ci          | utf8    | 211 |         | Yes      |       8 |
| utf8_german2_ci          | utf8    | 212 |         | Yes      |       8 |
| utf8_croatian_ci         | utf8    | 213 |         | Yes      |       8 |
| utf8_unicode_520_ci      | utf8    | 214 |         | Yes      |       8 |
| utf8_vietnamese_ci       | utf8    | 215 |         | Yes      |       8 |
| utf8_general_mysql500_ci | utf8    | 223 |         | Yes      |       1 |
+--------------------------+---------+-----+---------+----------+---------+
27 rows in set (0.00 sec)

```

名称后缀意味着该比较规则是否区分语言中的重音、大小写啥的，具体可以用的值如下：

<table> <thead> <tr> <th> 后缀 </th> <th> 英文释义 </th> <th> 描述 </th> </tr> </thead> <tbody> <tr> <td> <code> _ai </code> </td> <td> <code> accent insensitive </code> </td> <td> 不区分重音 </td> </tr> <tr> <td> <code> _as </code> </td> <td> <code> accent sensitive </code> </td> <td> 区分重音 </td> </tr> <tr> <td> <code> _ci </code> </td> <td> <code> case insensitive </code> </td> <td> 不区分大小写 </td> </tr> <tr> <td> <code> _cs </code> </td> <td> <code> case sensitive </code> </td> <td> 区分大小写 </td> </tr> <tr> <td> <code> _bin </code> </td> <td> <code> binary </code> </td> <td> 以二进制方式比较 </td> </tr> </tbody> </table>

比如 `utf8_general_ci` 这个比较规则是以 `ci` 结尾的，说明不区分大小写。

每种字符集对应若干种比较规则，每种字符集都有一种默认的比较规则，`SHOW COLLATION` 的返回结果中的 `Default` 列的值为 `YES` 的就是该字符集的默认比较规则，比方说 `utf8` 字符集默认的比较规则就是 `utf8_general_ci`。

`MySQL` 有 4 个级别的字符集和比较规则，分别是：

- 服务器级别
- 数据库级别
- 表级别
- 列级别

可以使用 sql 语句更改数据库的字符集与比较规则，在转换列的字符集时需要注意，**如果转换前列中存储的数据不能用转换后的字符集进行表示会发生错误**。比方说原先列使用的字符集是 utf8，列中存储了一些汉字，现在把列的字符集转换为 ascii 的话就会出错，因为 ascii 字符集并不能表示汉字字符。

## 1.3. 服务器与客户端之间的字符集转换

从发送请求到接收结果过程中发生的字符集转换：

1. 客户端使用操作系统的字符集编码请求字符串，向服务器发送的是经过编码的一个字节串。
2. 服务器将客户端发送来的字节串采用 `character_set_client` 代表的字符集进行解码，将解码后的字符串再按照 `character_set_connection` 代表的字符集进行编码。
	如果 `character_set_connection` 代表的字符集和具体操作的列使用的字符集一致，则直接进行相应操作，否则的话需要将请求中的字符串从 `character_set_connection` 代表的字符集转换为具体操作的列使用的字符集之后再进行操作。
3. 将从某个列获取到的字节串从该列使用的字符集转换为 `character_set_results` 代表的字符集后发送到客户端。
4. 客户端使用操作系统的字符集解析收到的结果集字节串。

在这个过程中各个系统变量的含义如下：

<table> <thead> <tr> <th> 系统变量 </th> <th> 描述 </th> </tr> </thead> <tbody> <tr> <td> <code> character_set_client </code> </td> <td> 服务器解码请求时使用的字符集 </td> </tr> <tr> <td> <code> character_set_connection </code> </td> <td> 服务器处理请求时会把请求字符串从 <code> character_set_client </code> 转为 <code> character_set_connection </code> </td> </tr> <tr> <td> <code> character_set_results </code> </td> <td> 服务器向客户端返回数据时使用的字符集 </td> </tr> </tbody> </table>    

一般情况下要**保持这三个变量的值和客户端使用的字符集相同**。

# 2. Mysql 记录的存储结构

`InnoDB` 是一个将表中的数据存储到磁盘上的存储引擎，所以即使关机后重启我们的数据还是存在的。而真正处理数据的过程是发生在内存中的，所以需要把磁盘中的数据加载到内存中，如果是处理写入或修改请求的话，还需要把内存中的内容刷新到磁盘上。而我们知道读写磁盘的速度非常慢，和内存读写差了几个数量级，所以当我们想从表中获取某些记录时，`InnoDB` 存储引擎需要一条一条的把记录从磁盘上读出来么？不，那样会慢死，`InnoDB` 采取的方式是：将数据划分为若干个页，以页作为磁盘和内存之间交互的基本单位，**InnoDB 中页的大小一般为 16KB**。也就是在一般情况下，一次最少从磁盘中读取 16KB 的内容到内存中，一次最少把内存中的 16KB 内容刷新到磁盘中。

我们平时是以记录为单位来向表中插入数据的，这些记录在磁盘上的存放方式也被称为 `行格式` 或者 `记录格式`。设计 `InnoDB` 存储引擎的大叔们到现在为止设计了 4 种不同类型的 `行格式`，分别是 `Compact`、`Redundant`、`Dynamic` 和 `Compressed` 行格式。

我们可以在创建或修改表的语句中指定 `行格式` ：

```sql
CREATE TABLE 表名 (列的信息) ROW_FORMAT=行格式名称;
ALTER TABLE 表名 ROW_FORMAT=行格式名称;
```

比如我们在 `xiaohaizi` 数据库里创建一个演示用的表 `record_format_demo`，可以这样指定它的 `行格式` ：

```sql
mysql> USE xiaohaizi;
Database changed

mysql> CREATE TABLE record_format_demo (
    ->     c1 VARCHAR(10),
    ->     c2 VARCHAR(10) NOT NULL,
    ->     c3 CHAR(10),
    ->     c4 VARCHAR(10)
    -> ) CHARSET=ascii ROW_FORMAT=COMPACT;
Query OK, 0 rows affected (0.03 sec)
```

可以看到我们刚刚创建的这个表的 `行格式` 就是 `Compact`，另外，我们还显式指定了这个表的字符集为 `ascii`，因为 `ascii` 字符集只包括空格、标点符号、数字、大小写字母和一些不可见字符，所以我们的汉字是不能存到这个表里的。我们现在向这个表中插入两条记录：

```sql

mysql> SELECT * FROM record_format_demo;
+------+-----+------+------+
| c1   | c2  | c3   | c4   |
+------+-----+------+------+
| aaaa | bbb | cc   | d    |
| eeee | fff | NULL | NULL |
+------+-----+------+------+
2 rows in set (0.00 sec)

mysql>

```

## 2.1. COMPACT 格式

![](https://varg-my-images.oss-cn-beijing.aliyuncs.com/img/202209042217042.png)

COMPACT 格式一条完整的记录其实可以被分为 `记录的额外信息` 和 `记录的真实数据` 两大部分。

### 2.1.1. 记录的额外信息

这部分信息是服务器为了描述这条记录而不得不额外添加的一些信息，这些额外信息分为 3 类，分别是 `变长字段长度列表`、`NULL值列表` 和 `记录头信息`。

#### 2.1.1.1. 变长字段列表

`MySQL` 支持一些变长的数据类型，比如 `VARCHAR(M)`、`VARBINARY(M)`、各种 `TEXT` 类型，各种 `BLOB` 类型，我们也可以把拥有这些数据类型的列称为 `变长字段`，变长字段中存储多少字节的数据是不固定的，所以我们在存储真实数据的时候需要顺便把这些数据占用的字节数也存起来，这样才不至于把 `MySQL` 服务器搞懵，所以这些变长字段占用的存储空间分为两部分：

1. 真正的数据内容
2. 占用的字节数

在 `Compact` 行格式中，把所有变长字段的真实数据占用的字节长度都存放在记录的开头部位，从而形成一个变长字段长度列表，各变长字段数据占用的字节数按照列的顺序**逆序存放**。

![](https://varg-my-images.oss-cn-beijing.aliyuncs.com/img/202209042223666.png)
![](https://varg-my-images.oss-cn-beijing.aliyuncs.com/img/202209042223432.png)

由于第一行记录中 `c1`、`c2`、`c4` 列中的字符串都比较短，也就是说内容占用的字节数比较小，用 1 个字节就可以表示，但是如果变长列的内容占用的字节数比较多，可能就需要用 2 个字节来表示。具体用 1 个还是 2 个字节来表示真实数据占用的字节数，`InnoDB` 有它的一套规则，我们首先声明一下 `W`、`M` 和 `L` 的意思：

1. 假设某个字符集中表示一个字符最多需要使用的字节数为 `W`，也就是使用 `SHOW CHARSET` 语句的结果中的 `Maxlen` 列，比方说 `utf8` 字符集中的 `W` 就是 `3`，`gbk` 字符集中的 `W` 就是 `2`，`ascii` 字符集中的 `W` 就是 `1`。
2. 对于变长类型 `VARCHAR(M)` 来说，这种类型表示能存储最多 `M` 个字符（注意是字符不是字节），所以这个类型能表示的字符串最多占用的字节数就是 `M×W`。
3. 假设它实际存储的字符串占用的字节数是 `L`。

所以确定使用 1 个字节还是 2 个字节表示真正字符串占用的字节数的规则就是这样：

- 如果 $M \times W \leq 255$，那么使用 1 个字节来表示真正字符串占用的字节数。
	也就是说 InnoDB 在读记录的变长字段长度列表时先查看表结构，如果某个变长字段允许存储的最大字节数不大于 255 时，可以认为只使用 1 个字节来表示真正字符串占用的字节数。
- 如果 $M \times W \gt 255$，则分为两种情况：
	- 如果 $L \leq 127$，则用 1 个字节来表示真正字符串占用的字节数。
	- 如果 $L \gt 127$，则用 2 个字节来表示真正字符串占用的字节数。

	InnoDB 在读记录的变长字段长度列表时先查看表结构，如果某个变长字段允许存储的最大字节数大于 255 时，该怎么区分它正在读的某个字节是一个单独的字段长度还是半个字段长度呢？
	
	设计 InnoDB 的大叔使用该字节的第一个二进制位作为标志位：如果该字节的第一个位为 0，那该字节就是一个单独的字段长度（使用一个字节表示不大于 127 的二进制的第一个位都为 0），如果该字节的第一个位为 1，那该字节就是半个字段长度。**对于一些占用字节数非常多的字段，比方说某个字段长度大于了 16KB，那么如果该记录在单个页面中无法存储时，InnoDB 会把一部分数据存放到所谓的溢出页中**（我们后边会唠叨），在变长字段长度列表处只存储留在本页面中的长度，所以使用两个字节也可以存放下来。

总结一下就是说：如果该可变字段允许存储的最大字节数（$M \times W$）超过 255 字节并且真实存储的字节数（`L`）超过 127 字节，则使用 2 个字节，否则使用 1 个字节。

另外需要注意的一点是，变长字段长度列表中只存储值为 _**非 NULL**_ 的列内容占用的长度，值为 _**NULL**_ 的列的长度是不储存的。

![](https://varg-my-images.oss-cn-beijing.aliyuncs.com/img/202209042228572.png)

**并不是所有记录都有这个变长字段长度列表部分**，比方说表中所有的列都不是变长的数据类型的话，这一部分就不需要有。

#### 2.1.1.2. NULL 值列表

表中的某些列可能存储 `NULL` 值，如果把这些 `NULL` 值都放到 `记录的真实数据` 中存储会很占地方，所以 `Compact` 行格式把这些值为 `NULL` 的列统一管理起来，存储到 `NULL` 值列表中，它的处理过程是这样的：

1. 首先统计表中允许存储 `NULL` 的列有哪些。
    主键列、被 `NOT NULL` 修饰的列都是不可以存储 `NULL` 值的，所以在统计的时候不会把这些列算进去。
2. 如果表中没有允许存储 _**NULL**_ 的列，则 `NULL 值列表` 也不存在了，否则将每个允许存储 `NULL` 的列对应一个二进制位，二进制位按照列的顺序**逆序排列**，二进制位表示的意义如下：
    - 二进制位的值为 `1` 时，代表该列的值为 `NULL`。
    - 二进制位的值为 `0` 时，代表该列的值不为 `NULL`。

3. `MySQL` 规定 `NULL值列表` 必须用整数个字节的位表示，如果使用的二进制位个数不是整数个字节，则在字节的高位补 `0`。

所以对于上面两条数据，他们的 _NULL 值列表_ 如下：

![](https://varg-my-images.oss-cn-beijing.aliyuncs.com/img/202209042233266.png)
![](https://varg-my-images.oss-cn-beijing.aliyuncs.com/img/202209042233752.png)
![](https://varg-my-images.oss-cn-beijing.aliyuncs.com/img/202209042233037.png)

#### 2.1.1.3. 记录头信息

除了 `变长字段长度列表`、`NULL值列表` 之外，还有一个用于描述记录的 `记录头信息`，它是由固定的 `5` 个字节组成。`5` 个字节也就是 `40` 个二进制位，不同的位代表不同的意思，如图：

![](https://varg-my-images.oss-cn-beijing.aliyuncs.com/img/202209042234643.png)

这些二进制位代表的详细信息如下表：

<table> <thead> <tr> <th> 名称 </th> <th> 大小（单位：bit）</th> <th> 描述 </th> </tr> </thead> <tbody> <tr> <td> <code> 预留位 1 </code> </td> <td> <code> 1 </code> </td> <td> 没有使用 </td> </tr> <tr> <td> <code> 预留位 2 </code> </td> <td> <code> 1 </code> </td> <td> 没有使用 </td> </tr> <tr> <td> <code> delete_mask </code> </td> <td> <code> 1 </code> </td> <td> 标记该记录是否被删除 </td> </tr> <tr> <td> <code> min_rec_mask </code> </td> <td> <code> 1 </code> </td> <td> B + 树的每层非叶子节点中的最小记录都会添加该标记 </td> </tr> <tr> <td> <code> n_owned </code> </td> <td> <code> 4 </code> </td> <td> 表示当前记录拥有的记录数 </td> </tr> <tr> <td> <code> heap_no </code> </td> <td> <code> 13 </code> </td> <td> 表示当前记录在记录堆的位置信息 </td> </tr> <tr> <td> <code> record_type </code> </td> <td> <code> 3 </code> </td> <td> 表示当前记录的类型，<code> 0 </code> 表示普通记录，<code> 1 </code> 表示 B + 树非叶子节点记录，<code> 2 </code> 表示最小记录，<code> 3 </code> 表示最大记录 </td> </tr> <tr> <td> <code> next_record </code> </td> <td> <code> 16 </code> </td> <td> 表示下一条记录的相对位置 </td> </tr> </tbody> </table>

我们现在直接看一下 `record_format_demo` 中的两条记录的 `头信息` 分别是什么：

![](https://varg-my-images.oss-cn-beijing.aliyuncs.com/img/202209042237473.png)

### 2.1.2. 记录的真实数据

对于 `record_format_demo` 表来说，`记录的真实数据` 除了 `c1`、`c2`、`c3`、`c4` 这几个我们自己定义的列的数据以外，`MySQL` 会为每个记录默认的添加一些列（也称为 `隐藏列`），具体的列如下：

<table> <thead> <tr> <th> 列名 </th> <th> 是否必须 </th> <th> 占用空间 </th> <th> 描述 </th> </tr> </thead> <tbody> <tr> <td> <code> row_id </code> </td> <td> 否 </td> <td> <code> 6 </code> 字节 </td> <td> 行 ID，唯一标识一条记录 </td> </tr> <tr> <td> <code> transaction_id </code> </td> <td> 是 </td> <td> <code> 6 </code> 字节 </td> <td> 事务 ID </td> </tr> <tr> <td> <code> roll_pointer </code> </td> <td> 是 </td> <td> <code> 7 </code> 字节 </td> <td> 回滚指针 </td> </tr> </tbody> </table>

实际上这几个列的真正名称其实是：DB_ROW_ID、DB_TRX_ID、DB_ROLL_PTR，我们为了美观才写成了 row_id、transaction_id 和 roll_pointer。

这里需要提一下 `InnoDB` 表对主键的生成策略：优先使用用户自定义主键作为主键，**如果用户没有定义主键，则选取一个 `Unique` 键作为主键**，如果表中连 `Unique` 键都没有定义的话，则 `InnoDB` 会为表默认添加一个名为 `row_id` 的隐藏列作为主键。

![](https://varg-my-images.oss-cn-beijing.aliyuncs.com/img/202209042239073.png)

### 2.1.3. CHAR (M) 列的存储格式

在 `Compact` 行格式下只会把变长类型的列的长度逆序存到 `变长字段长度列表` 中，如果采用变长的字符集（也就是表示一个字符需要的字节数不确定，比如 `gbk` 表示一个字符要 1～2 个字节、`utf8` 表示一个字符要 1~3 个字节等）的话，列的长度也会被存储到 `变长字段长度列表` 中。

比如我们修改一下 `record_format_demo` 表的字符集：

```sql
mysql> ALTER TABLE record_format_demo MODIFY COLUMN c3 CHAR(10) CHARACTER SET utf8;
Query OK, 2 rows affected (0.02 sec)
Records: 2  Duplicates: 0  Warnings: 0
```

修改该列字符集后记录的 `变长字段长度列表` 也发生了变化，如图：

![](https://varg-my-images.oss-cn-beijing.aliyuncs.com/img/202209042243072.png)

这就意味着：对于 _**CHAR (M)**_ 类型的列来说，**当列采用的是定长字符集时，该列占用的字节数不会被加到变长字段长度列表，而如果采用变长字符集时，该列占用的字节数也会被加到变长字段长度列表**。

另外有一点还需要注意，**变长字符集的 `CHAR(M)` 类型的列要求至少占用 `M` 个字节**，而 `VARCHAR(M)` 却没有这个要求。比方说对于使用 `utf8` 字符集的 `CHAR(10)` 的列来说，该列存储的数据字节长度的范围是 10～30 个字节。即使我们向该列中存储一个空字符串也会占用 `10` 个字节，这是为了将来更新该列的值时，若该新值的字节长度大于原有值的字节长度而小于 10 个字节时，可以在该记录处直接更新，而不是在存储空间中重新分配一个新的记录空间，导致原有的记录空间成为所谓的碎片。

我们知道对于 **`VARCHAR(M)` 类型的列最多可以占用 `65535` 个字节**。其中的 `M` 代表该类型最多存储的字符数量。`MySQL` 对一条记录占用的最大存储空间是有限制的，除了 `BLOB` 或者 `TEXT` 类型的列之外，**其他所有的列（不包括隐藏列和记录头信息）占用的字节长度加起来不能超过 `65535` 个字节**。所以 `MySQL` 服务器建议我们把超长字符串存储类型改为 `TEXT` 或者 `BLOB` 的类型。这个 `65535` 个字节除了列本身的数据之外，还包括一些其他的数据（`storage overhead`），比如说我们为了存储一个 `VARCHAR(M)` 类型的列，其实需要占用 3 部分存储空间：
- 真实数据
- 真实数据占用字节的长度
- `NULL` 值标识，如果该列有 `NOT NULL` 属性则可以没有这部分存储空间

如果 `VARCHAR(M)` 类型的列使用的不是 `ascii` 字符集，那 `M` 的最大取值取决于该字符集表示一个字符最多需要的字节数。在列的值允许为 `NULL` 的情况下，`gbk` 字符集表示一个字符最多需要 `2` 个字节，那在该字符集下，`M` 的最大取值就是 `32766`（也就是：$65532 \div 2$），也就是说最多能存储 `32766` 个字符；`utf8` 字符集表示一个字符最多需要 `3` 个字节，那在该字符集下，`M` 的最大取值就是 `21844`，就是说最多能存储 `21844`（也就是：$65532 \div 3$）个字符。

上述所言在列的值允许为 NULL 的情况下，gbk 字符集下 M 的最大取值就是 32766，utf8 字符集下 M 的最大取值就是 21844，这都是在表中只有一个字段的情况下说的。**一个行中的所有列（不包括隐藏列和记录头信息）占用的字节长度加起来不能超过 65535 个字节！**

## 2.2. 行溢出

### 2.2.1. 行溢出现象

在 `Compact` 和 `Redundant` 行格式中，对于占用存储空间非常大的列，在 `记录的真实数据` 处只会存储该列的一部分数据，把剩余的数据分散存储在几个其他的页中，然后 `记录的真实数据` 处用 20 个字节存储指向这些页的地址（当然这 20 个字节中还包括这些分散在其他页面中的数据的指针占用的字节数），从而可以找到剩余数据所在的页，如图所示：

![](https://varg-my-images.oss-cn-beijing.aliyuncs.com/img/202209042303293.png)

从图中可以看出来，对于 `Compact` 和 `Redundant` 行格式来说，如果某一列中的数据非常多的话，在本记录的真实数据处只会存储该列的前 `768` 个字节的数据和一个指向其他页的地址，然后把剩下的数据存放到其他页中，这个过程也叫做 `行溢出`，存储超出 `768` 字节的那些页面也被称为 `溢出页`。画一个简图就是这样：

![](https://varg-my-images.oss-cn-beijing.aliyuncs.com/img/202209042304813.png)

最后需要注意的是，不只是 VARCHAR (M) 类型的列，其他的 TEXT、BLOB 类型的列在存储数据非常多的时候也会发生 `行溢出`。

### 2.2.2. 行溢出临界点

那发生 `行溢出` 的临界点是什么呢？也就是说在列存储多少字节的数据时就会发生 `行溢出`？

`MySQL` 中规定**一个页中至少存放两行记录**。以上边的 `varchar_size_demo` 表为例，它只有一个列 `c`，我们往这个表中插入两条记录，每条记录最少插入多少字节的数据才会 `行溢出` 的现象呢？这得分析一下页中的空间都是如何利用的。

- 每个页除了存放我们的记录以外，也需要存储一些额外的信息，乱七八糟的额外信息加起来需要 `132` 个字节的空间（现在只要知道这个数字就好了），其他的空间都可以被用来存储记录。
- 每个记录需要的额外信息是 `27` 字节。
	这 27 个字节包括下边这些部分：
	- 2 个字节用于存储真实数据的长度
	- 1 个字节用于存储列是否是 NULL 值
	- 5 个字节大小的头信息
	- 6 个字节的 `row_id` 列
	- 6 个字节的 `transaction_id` 列
	- 7 个字节的 `roll_pointer` 列

假设一个列中存储的数据字节数为 n，设计 `MySQL` 的大叔规定如果该列不发生溢出的现象，就需要满足下边这个式子：

$$
132 + 2 \times (27 + n) \lt 16384
$$

如果表中有多个列，那上边的式子和结论都需要改一改了，所以重点就是：你不用关注这个临界点是什么，只要知道如果我们一条记录的某个列中存储的数据占用的字节数非常多时，该列就可能成为 `溢出列`。

## 2.3. Dynamic 和 Compressed 行格式

`Dynamic` 和 `Compressed` 行格式，这俩行格式和 `Compact` 行格式挺像，只不过在处理 `行溢出` 数据时有点儿分歧，它们不会在记录的真实数据处存储字段真实数据的前 `768` 个字节，而是把所有的字节都存储到其他页面中，只在记录的真实数据处存储其他页面的地址，就像这样：

![](https://varg-my-images.oss-cn-beijing.aliyuncs.com/img/202209042308235.png)

`Compressed` 行格式和 `Dynamic` 不同的一点是，`Compressed` 行格式会采用压缩算法对页面进行压缩，以节省空间。

# 3. Mysql 的数据页

## 3.1. 数据页概览

数据页代表的这块 `16KB` 大小的存储空间可以被划分为多个部分，不同部分有不同的功能，各个部分如图所示：

![](https://varg-my-images.oss-cn-beijing.aliyuncs.com/img/202209042335106.png)

一个 `InnoDB` 数据页的存储空间大致被划分成了 `7` 个部分，有的部分占用的字节数是确定的，有的部分占用的字节数是不确定的。

<table> <thead> <tr> <th> 名称 </th> <th> 中文名 </th> <th> 占用空间大小 </th> <th> 简单描述 </th> </tr> </thead> <tbody> <tr> <td> <code> File Header </code> </td> <td> 文件头部 </td> <td> <code> 38 </code> 字节 </td> <td> 页的一些通用信息 </td> </tr> <tr> <td> <code> Page Header </code> </td> <td> 页面头部 </td> <td> <code> 56 </code> 字节 </td> <td> 数据页专有的一些信息 </td> </tr> <tr> <td> <code> Infimum + Supremum </code> </td> <td> 最小记录和最大记录 </td> <td> <code> 26 </code> 字节 </td> <td> 两个虚拟的行记录 </td> </tr> <tr> <td> <code> User Records </code> </td> <td> 用户记录 </td> <td> 不确定 </td> <td> 实际存储的行记录内容 </td> </tr> <tr> <td> <code> Free Space </code> </td> <td> 空闲空间 </td> <td> 不确定 </td> <td> 页中尚未使用的空间 </td> </tr> <tr> <td> <code> Page Directory </code> </td> <td> 页面目录 </td> <td> 不确定 </td> <td> 页中的某些记录的相对位置 </td> </tr> <tr> <td> <code> File Trailer </code> </td> <td> 文件尾部 </td> <td> <code> 8 </code> 字节 </td> <td> 校验页是否完整 </td> </tr> </tbody> </table>

## 3.2. 记录在页中的存储

在页的 7 个组成部分中，我们自己存储的记录会按照我们指定的 `行格式` 存储到 `User Records` 部分。但是在一开始生成页的时候，其实并没有 `User Records` 这个部分，每当我们插入一条记录，都会从 `Free Space` 部分，也就是尚未使用的存储空间中申请一个记录大小的空间划分到 `User Records` 部分，当 `Free Space` 部分的空间全部被 `User Records` 部分替代掉之后，也就意味着这个页使用完了，如果还有新的记录插入的话，就需要去申请新的页了，这个过程的图示如下：

![](https://varg-my-images.oss-cn-beijing.aliyuncs.com/img/202209042337859.png)

### 3.2.1. 数据的记录头信息

为了故事的顺利发展，我们先创建一个表：

```sql

mysql> CREATE TABLE page_demo(
    ->     c1 INT,
    ->     c2 INT,
    ->     c3 VARCHAR(10000),
    ->     PRIMARY KEY (c1)
    -> ) CHARSET=ascii ROW_FORMAT=Compact;
Query OK, 0 rows affected (0.03 sec)

```

这个新创建的 `page_demo` 表有 3 个列，其中 `c1` 和 `c2` 列是用来存储整数的，`c3` 列是用来存储字符串的。需要注意的是，我们把 c1 列指定为主键，所以在具体的行格式中 InnoDB 就没必要为我们去创建那个所谓的 `row_id` 隐藏列了。而且我们为这个表指定了 `ascii` 字符集以及 `Compact` 的行格式。所以这个表中记录的行格式示意图就是这样的：

![](https://varg-my-images.oss-cn-beijing.aliyuncs.com/img/202209042339797.png)

<table> <thead> <tr> <th> 名称 </th> <th> 大小（单位：bit）</th> <th> 描述 </th> </tr> </thead> <tbody> <tr> <td> <code> 预留位 1 </code> </td> <td> <code> 1 </code> </td> <td> 没有使用 </td> </tr> <tr> <td> <code> 预留位 2 </code> </td> <td> <code> 1 </code> </td> <td> 没有使用 </td> </tr> <tr> <td> <code> delete_mask </code> </td> <td> <code> 1 </code> </td> <td> 标记该记录是否被删除 </td> </tr> <tr> <td> <code> min_rec_mask </code> </td> <td> <code> 1 </code> </td> <td> B + 树的每层非叶子节点中的最小记录都会添加该标记 </td> </tr> <tr> <td> <code> n_owned </code> </td> <td> <code> 4 </code> </td> <td> 表示当前记录拥有的记录数 </td> </tr> <tr> <td> <code> heap_no </code> </td> <td> <code> 13 </code> </td> <td> 表示当前记录在记录堆的位置信息 </td> </tr> <tr> <td> <code> record_type </code> </td> <td> <code> 3 </code> </td> <td> 表示当前记录的类型，<code> 0 </code> 表示普通记录，<code> 1 </code> 表示 B + 树非叶节点记录，<code> 2 </code> 表示最小记录，<code> 3 </code> 表示最大记录 </td> </tr> <tr> <td> <code> next_record </code> </td> <td> <code> 16 </code> </td> <td> 表示下一条记录的相对位置 </td> </tr> </tbody> </table>

以一些数据例子为例说明记录头信息中各个字段的作用：

![](https://varg-my-images.oss-cn-beijing.aliyuncs.com/img/202209042340092.png)

- `delete_mask`
    这个属性标记着当前记录是否被删除，占用 1 个二进制位，值为 `0` 的时候代表记录并没有被删除，为 `1` 的时候代表记录被删除掉了。

    啥？被删除的记录还在 `页` 中么？是的，摆在台面上的和背地里做的可能大相径庭，你以为它删除了，可它还在真实的磁盘上。
    
    这些被删除的记录之所以不立即从磁盘上移除，是因为**移除它们之后把其他的记录在磁盘上重新排列需要性能消耗**，所以只是打一个删除标记而已，所有被删除掉的记录都会组成一个所谓的 `垃圾链表`，在这个链表中的记录占用的空间称之为所谓的 `可重用空间`，之后如果有新记录插入到表中的话，可能把这些被删除的记录占用的存储空间覆盖掉。
    
    将这个 `delete_mask` 位设置为 1 和将被删除的记录加入到垃圾链表中其实是两个阶段，我们后边在介绍事务的时候会详细唠叨删除操作的详细过程。
- `min_rec_mask`
    B+树的每层 [[Mysql的存储结构#4 2 1 索引的存储|非叶子节点]]中的最小记录都会添加该标记。
- `n_owned`
    槽中记录数，用于记录当前记录数据所属槽中包含的记录数，具体在 [[Mysql的存储结构#3 3 Page Directory（页目录）|页目录]]中使用。
- `heap_no`
    这个属性表示当前记录在本 `页` 中的位置，从图中可以看出来，我们插入的 4 条记录在本 `页` 中的位置分别是：`2`、`3`、`4`、`5`。是不是少了点啥？是的，怎么不见 `heap_no` 值为 `0` 和 `1` 的记录呢？

    `InnoDB` 自动给每个页里边儿加了两个记录，由于这两个记录并不是我们自己插入的，所以有时候也称为 `伪记录` 或者 `虚拟记录`。这两个伪记录一个代表 `最小记录`，一个代表 `最大记录`。

    不管我们向 `页` 中插入了多少自己的记录，设计 `InnoDB` 的大叔们都规定他们定义的两条伪记录分别为最小记录与最大记录。这两条记录的构造十分简单，都是由 5 字节大小的 `记录头信息` 和 8 字节大小的一个固定的部分组成的，如图所示：

    ![](https://varg-my-images.oss-cn-beijing.aliyuncs.com/img/202209042345355.png)

    由于这两条记录不是我们自己定义的记录，所以它们并不存放在 `页` 的 `User Records` 部分，他们被单独放在一个称为 `Infimum + Supremum` 的部分，如图所示：

    ![](https://varg-my-images.oss-cn-beijing.aliyuncs.com/img/202209042345733.png)

    从图中我们可以看出来，最小记录和最大记录的 `heap_no` 值分别是 `0` 和 `1`，也就是说它们的位置最靠前。
- record_type
    这个属性表示当前记录的类型，一共有 4 种类型的记录，`0` 表示普通记录，`1` 表示 [[Mysql的存储结构#4 2 InnoDB 的索引结构|B+树非叶节点记录]]，`2` 表示最小记录，`3` 表示最大记录。从图中我们也可以看出来，我们自己插入的记录就是普通记录，它们的 `record_type` 值都是 `0`，而最小记录和最大记录的 `record_type` 值分别为 `2` 和 `3`。
- next_record
    表示**从当前记录的真实数据到下一条记录的真实数据的地址偏移量**。比方说第一条记录的 `next_record` 值为 `32`，意味着从第一条记录的真实数据的地址处向后找 `32` 个字节便是下一条记录的真实数据。

    这其实是个 `链表`，可以通过一条记录找到它的下一条记录。但是需要注意的一点是，`下一条记录` 指得并不是按照我们插入顺序的下一条记录，而是按照主键值由小到大的顺序的下一条记录。而且规定 _**Infimum 记录（也就是最小记录）**_ 的下一条记录就是本页中主键值最小的用户记录，而本页中主键值最大的用户记录的下一条记录就是 _**Supremum 记录（也就是最大记录）**_。

    ![](https://varg-my-images.oss-cn-beijing.aliyuncs.com/img/202209042347269.png)
    
    > [!note] next_record 指针的设计
    > 
    > 你会不会觉得 next_record 这个指针有点儿怪，为啥要指向记录头信息和真实数据之间的位置呢？为啥不干脆指向整条记录的开头位置，也就是记录的额外信息开头的位置呢？ 因为这个位置刚刚好，**向左读取就是记录头信息，向右读取就是真实数据**。我们前边还说过变长字段长度列表、NULL 值列表中的信息都是逆序存放，这样可以**使记录中位置靠前的字段和它们对应的字段长度信息在内存中的距离更近，可能会提高高速缓存的命中率**。

## 3.3. Page Directory（页目录）

现在我们了解了记录在页中按照主键值由小到大顺序串联成一个单链表，那如果我们想根据主键值查找页中的某条记录该咋办呢？

最笨的办法：从 `Infimum` 记录（最小记录）开始，沿着链表一直往后找，总有一天会找到（或者找不到）。在找的时候还能投机取巧，因为链表中各个记录的值是按照从小到大顺序排列的，所以当链表的某个节点代表的记录的主键值大于你想要查找的主键值时，你就可以停止查找了，因为该节点后边的节点的主键值依次递增。这个方法当记录数少的时候没啥问题，但当记录数多时性能表现不好。

我们平常想从一本书中查找某个内容的时候，一般会先看目录，找到需要查找的内容对应的书的页码，然后到对应的页码查看内容。设计 `InnoDB` 的大叔们为我们的记录也制作了一个类似的目录，他们的制作过程是这样的：
1. 将所有正常的记录（包括最大和最小记录，不包括标记为已删除的记录）划分为几个组。
2. 每个组的最后一条记录（也就是组内最大的那条记录）的头信息中的 `n_owned` 属性表示该记录拥有多少条记录，也就是该组内共有几条记录。
3. 将每个组的最后一条记录的地址偏移量单独提取出来按顺序存储到靠近 `页` 的尾部的地方，这个地方就是所谓的 `Page Directory`，也就是 `页目录`。页面目录中的这些地址偏移量被称为 `槽`（英文名：`Slot`），所以这个页面目录就是由 `槽` 组成的。

比方说现在的 `page_demo` 表中正常的记录共有 6 条，`InnoDB` 会把它们分成两组，第一组中只有一个最小记录，第二组中是剩余的 5 条记录：

![](https://varg-my-images.oss-cn-beijing.aliyuncs.com/img/202209042353242.png)
![](https://varg-my-images.oss-cn-beijing.aliyuncs.com/img/202209042353223.png)

设计 `InnoDB` 的大叔们对每个分组中的记录条数是有规定的：对于最小记录所在的分组只能有 _**1**_ 条记录；最大记录所在的分组拥有的记录条数只能在 _**1~8**_ 条之间；剩下的分组中记录的条数范围只能在是 _**4~8**_ 条之间。所以分组是按照下边的步骤进行的：
1. 初始情况下一个数据页里只有最小记录和最大记录两条记录，它们分属于两个分组。
2. 之后每插入一条记录，都会从 `页目录` 中找到主键值比本记录的主键值大并且差值最小的槽，然后把该槽对应的记录的 `n_owned` 值加 1，表示本组内又添加了一条记录，直到该组中的记录数等于 8 个。
3. 在一个组中的记录数等于 8 个后再插入一条记录时，会将组中的记录拆分成两个组，一个组中 4 条记录，另一个 5 条记录。这个过程会在 `页目录` 中新增一个 `槽` 来记录这个新增分组中最大的那条记录的偏移量。

以更多的数据为例说明：

![](https://varg-my-images.oss-cn-beijing.aliyuncs.com/img/202209042357931.png)

现在看怎么从这个 `页目录` 中查找记录。因为各个槽代表的记录的主键值都是从小到大排序的，所以我们可以使用所谓的 `二分法` 来进行快速查找。

在一个数据页中查找指定主键值的记录的过程分为两步：
1. 通过二分法确定该记录所在的槽，并找到该槽所在分组中主键值最小的那条记录。
2. 通过记录的 `next_record` 属性遍历该槽所在的组中的各个记录。

5 个槽的编号分别是：`0`、`1`、`2`、`3`、`4`，所以初始情况下最低的槽就是 `low = 0`，最高的槽就是 `high = 4`。比方说我们想找主键值为 `6` 的记录，过程是这样的：
1. 计算中间槽的位置：$(0+4)\div 2 = 2$，所以查看 `槽2` 对应记录的主键值为 `8`，又因为 `8 > 6`，所以设置 `high=2`，`low` 保持不变。
2. 重新计算中间槽的位置：$(0+2) \div 2=1$，所以查看 `槽1` 对应的主键值为 `4`，又因为 `4 < 6`，所以设置 `low=1`，`high` 保持不变。
3. 因为 `high - low` 的值为 1，所以确定主键值为 `6` 的记录在 `槽2` 对应的组中。此刻我们需要找到 `槽2` 中主键值最小的那条记录，然后沿着单向链表遍历 `槽2` 中的记录。但是我们前边又说过，每个槽对应的记录都是该组中主键值最大的记录，这里 `槽2` 对应的记录是主键值为 `8` 的记录，怎么定位一个组中最小的记录呢？别忘了各个槽都是挨着的，我们可以很轻易的拿到 `槽1` 对应的记录（主键值为 `4`），该条记录的下一条记录就是 `槽2` 中主键值最小的记录，该记录的主键值为 `5`。所以我们可以从这条主键值为 `5` 的记录出发，遍历 `槽2` 中的各条记录，直到找到主键值为 `6` 的那条记录即可。由于一个组中包含的记录条数只能是 1~8 条，所以遍历一个组中的记录的代价是很小的。

这个槽的设计与 [[Redis大纲#3.4.7. 跳表|跳表]] 有异曲同工之妙，通过抽取一部分数据而加快查询的速度。

## 3.4. Page Header（页面头部）

设计 `InnoDB` 的大叔们为了能得到一个数据页中存储的记录的状态信息，比如本页中已经存储了多少条记录，第一条记录的地址是什么，页目录中存储了多少个槽等等，特意在页中定义了一个叫 `Page Header` 的部分，它是 `页` 结构的第二部分，这个部分占用固定的 `56` 个字节，专门存储各种状态信息：

<table> <thead> <tr> <th> 名称 </th> <th> 占用空间大小 </th> <th> 描述 </th> </tr> </thead> <tbody> <tr> <td> <code> PAGE_N_DIR_SLOTS </code> </td> <td> <code> 2 </code> 字节 </td> <td> 在页目录中的槽数量 </td> </tr> <tr> <td> <code> PAGE_HEAP_TOP </code> </td> <td> <code> 2 </code> 字节 </td> <td> 还未使用的空间最小地址，也就是说从该地址之后就是 <code> Free Space </code> </td> </tr> <tr> <td> <code> PAGE_N_HEAP </code> </td> <td> <code> 2 </code> 字节 </td> <td> 本页中的记录的数量（包括最小和最大记录以及标记为删除的记录）</td> </tr> <tr> <td> <code> PAGE_FREE </code> </td> <td> <code> 2 </code> 字节 </td> <td> 第一个已经标记为删除的记录地址（各个已删除的记录通过 <code> next_record </code> 也会组成一个单链表，这个单链表中的记录可以被重新利用）</td> </tr> <tr> <td> <code> PAGE_GARBAGE </code> </td> <td> <code> 2 </code> 字节 </td> <td> 已删除记录占用的字节数 </td> </tr> <tr> <td> <code> PAGE_LAST_INSERT </code> </td> <td> <code> 2 </code> 字节 </td> <td> 最后插入记录的位置 </td> </tr> <tr> <td> <code> PAGE_DIRECTION </code> </td> <td> <code> 2 </code> 字节 </td> <td> 记录插入的方向 </td> </tr> <tr> <td> <code> PAGE_N_DIRECTION </code> </td> <td> <code> 2 </code> 字节 </td> <td> 一个方向连续插入的记录数量 </td> </tr> <tr> <td> <code> PAGE_N_RECS </code> </td> <td> <code> 2 </code> 字节 </td> <td> 该页中记录的数量（不包括最小和最大记录以及被标记为删除的记录）</td> </tr> <tr> <td> <code> PAGE_MAX_TRX_ID </code> </td> <td> <code> 8 </code> 字节 </td> <td> 修改当前页的最大事务 ID，该值仅在二级索引中定义 </td> </tr> <tr> <td> <code> PAGE_LEVEL </code> </td> <td> <code> 2 </code> 字节 </td> <td> 当前页在 B + 树中所处的层级 </td> </tr> <tr> <td> <code> PAGE_INDEX_ID </code> </td> <td> <code> 8 </code> 字节 </td> <td> 索引 ID，表示当前页属于哪个索引 </td> </tr> <tr> <td> <code> PAGE_BTR_SEG_LEAF </code> </td> <td> <code> 10 </code> 字节 </td> <td> B + 树叶子段的头部信息，仅在 B + 树的 Root 页定义 </td> </tr> <tr> <td> <code> PAGE_BTR_SEG_TOP </code> </td> <td> <code> 10 </code> 字节 </td> <td> B + 树非叶子段的头部信息，仅在 B + 树的 Root 页定义 </td> </tr> </tbody> </table>

其中前半段字段含义已经介绍过了，这里我们先唠叨一下 `PAGE_DIRECTION` 和 `PAGE_N_DIRECTION` 的意思：
- `PAGE_DIRECTION`
    假如新插入的一条记录的主键值比上一条记录的主键值大，我们说这条记录的插入方向是右边，反之则是左边。用来表示最后一条记录插入方向的状态就是 `PAGE_DIRECTION`。
- `PAGE_N_DIRECTION`
    假设连续几次插入新记录的方向都是一致的，`InnoDB` 会把沿着同一个方向插入记录的条数记下来，这个条数就用 `PAGE_N_DIRECTION` 这个状态表示。当然，如果最后一条记录的插入方向改变了的话，这个状态的值会被清零重新统计。
- `PAGE_BTR_SEG_LEAF` 与 `PAGE_BTR_SEG_TOP`
	这两部分用于在表空间中定位 [[Mysql的存储结构#5 2 1 5 4 2 索引关联 INODE 页面|索引的根页面]]。

## 3.5. File Header（文件头部）

`Page Header` 是专门针对 `数据页` 记录的各种状态信息，比方说页里头有多少个记录，有多少个槽。我们现在描述的 `File Header` 针对各种类型的页都通用，也就是说不同类型的页都会以 `File Header` 作为第一个组成部分，它描述了一些针对各种页都通用的一些信息，比方说这个页的编号是多少，它的上一个页、下一个页是谁。这个部分占用固定的 `38` 个字节，是由下边这些内容组成的：

<table> <thead> <tr> <th> 名称 </th> <th> 占用空间大小 </th> <th> 描述 </th> </tr> </thead> <tbody> <tr> <td> <code> FIL_PAGE_SPACE_OR_CHKSUM </code> </td> <td> <code> 4 </code> 字节 </td> <td> 页的校验和（checksum 值）</td> </tr> <tr> <td> <code> FIL_PAGE_OFFSET </code> </td> <td> <code> 4 </code> 字节 </td> <td> 页号 </td> </tr> <tr> <td> <code> FIL_PAGE_PREV </code> </td> <td> <code> 4 </code> 字节 </td> <td> 上一个页的页号 </td> </tr> <tr> <td> <code> FIL_PAGE_NEXT </code> </td> <td> <code> 4 </code> 字节 </td> <td> 下一个页的页号 </td> </tr> <tr> <td> <code> FIL_PAGE_LSN </code> </td> <td> <code> 8 </code> 字节 </td> <td> 页面被最后修改时对应的日志序列位置（英文名是：Log Sequence Number）</td> </tr> <tr> <td> <code> FIL_PAGE_TYPE </code> </td> <td> <code> 2 </code> 字节 </td> <td> 该页的类型 </td> </tr> <tr> <td> <code> FIL_PAGE_FILE_FLUSH_LSN </code> </td> <td> <code> 8 </code> 字节 </td> <td> 仅在系统表空间的一个页中定义，代表文件至少被刷新到了磁盘对应的 LSN 值 </td> </tr> <tr> <td> <code> FIL_PAGE_ARCH_LOG_NO_OR_SPACE_ID </code> </td> <td> <code> 4 </code> 字节 </td> <td> 页属于哪个表空间 </td> </tr> </tbody> </table>

对照着这个表格，我们看几个目前比较重要的部分：
- `FIL_PAGE_SPACE_OR_CHKSUM`
    这个代表当前页面的校验和（`checksum`）。
- `FIL_PAGE_OFFSET`
    每一个 `页` 都有一个单独的页号，就跟你的身份证号码一样，`InnoDB` 通过页号来可以唯一定位一个 `页`。
- `FIL_PAGE_TYPE`
    这个代表当前 `页` 的类型，我们前边说过，`InnoDB` 为了不同的目的而把页分为不同的类型，我们上边介绍的其实都是存储记录的 `数据页`，其实还有很多别的类型的页，具体如下表：

	<table> <thead> <tr> <th> 类型名称 </th> <th> 十六进制 </th> <th> 描述 </th> </tr> </thead> <tbody> <tr> <td> <code> FIL_PAGE_TYPE_ALLOCATED </code> </td> <td> 0x0000 </td> <td> 最新分配，还没使用 </td> </tr> <tr> <td> <code> FIL_PAGE_UNDO_LOG </code> </td> <td> 0x0002 </td> <td> Undo 日志页 </td> </tr> <tr> <td> <code> FIL_PAGE_INODE </code> </td> <td> 0x0003 </td> <td> 段信息节点 </td> </tr> <tr> <td> <code> FIL_PAGE_IBUF_FREE_LIST </code> </td> <td> 0x0004 </td> <td> Insert Buffer 空闲列表 </td> </tr> <tr> <td> <code> FIL_PAGE_IBUF_BITMAP </code> </td> <td> 0x0005 </td> <td> Insert Buffer 位图 </td> </tr> <tr> <td> <code> FIL_PAGE_TYPE_SYS </code> </td> <td> 0x0006 </td> <td> 系统页 </td> </tr> <tr> <td> <code> FIL_PAGE_TYPE_TRX_SYS </code> </td> <td> 0x0007 </td> <td> 事务系统数据 </td> </tr> <tr> <td> <code> FIL_PAGE_TYPE_FSP_HDR </code> </td> <td> 0x0008 </td> <td> 表空间头部信息 </td> </tr> <tr> <td> <code> FIL_PAGE_TYPE_XDES </code> </td> <td> 0x0009 </td> <td> 扩展描述页 </td> </tr> <tr> <td> <code> FIL_PAGE_TYPE_BLOB </code> </td> <td> 0x000A </td> <td> 溢出页 </td> </tr> <tr> <td> <code> FIL_PAGE_INDEX </code> </td> <td> 0x45BF </td> <td> 索引页，也就是我们所说的 <code> 数据页 </code> </td> </tr> </tbody> </table>

- `FIL_PAGE_PREV` 和 `FIL_PAGE_NEXT`
	`InnoDB` 都是以页为单位存放数据的，`FIL_PAGE_PREV` 和 `FIL_PAGE_NEXT` 就分别代表本页的上一个和下一个页的页号。这样通过建立一个双向链表把许许多多的页就都串联起来了，而无需这些页在物理上真正连着。
	
	需要注意的是，并不是所有类型的页都有上一个和下一个页的属性，不过 `数据页`（也就是类型为 `FIL_PAGE_INDEX` 的页）是有这两个属性的，所以所有的数据页其实是一个双链表，就像这样：
	
	![](https://varg-my-images.oss-cn-beijing.aliyuncs.com/img/202209050009280.png)

- `FIL_PAGE_LSN`
	用于记录页面被 [[Mysql的一致性保证#1 5 Log Sequence Number|刷新到磁盘时的LSN值]]。

## 3.6. File Trailer（文件尾部）

`InnoDB` 存储引擎会把数据存储到磁盘上，但是磁盘速度太慢，需要以 `页` 为单位把数据加载到内存中处理，如果该页中的数据在内存中被修改了，那么在修改后的某个时间需要把数据同步到磁盘中。但是在同步了一半的时候中断电了咋办，这不是莫名尴尬么？

为了检测一个页是否完整（也就是在同步的时候有没有发生只同步一半的尴尬情况），设计 `InnoDB` 的大叔们在每个页的尾部都加了一个 `File Trailer` 部分，这个部分由 `8` 个字节组成，可以分成 2 个小部分：

- 前 4 个字节代表页的校验和
    这个部分是和 `File Header` 中的校验和相对应的。每当一个页面在内存中修改了，在同步之前就要把它的校验和算出来，因为 `File Header` 在页面的前边，所以校验和会被首先同步到磁盘，当完全写完时，校验和也会被写到页的尾部，如果完全同步成功，则页的首部和尾部的校验和应该是一致的。如果写了一半儿断电了，那么在 `File Header` 中的校验和就代表着已经修改过的页，而在 `File Trailer` 中的校验和代表着原先的页，二者不同则意味着同步中间出了错。
-   后 4 个字节代表页面被最后修改时对应的日志序列位置（LSN）
    [[Mysql的一致性保证#1 5 Log Sequence Number|日志序列号]]，这个部分也是为了校验页的完整性的。

这个 `File Trailer` 与 `File Header` 类似，都是所有类型的页通用的。

# 4. Mysql 的索引结构

## 4.1. 索引设计概览

在 [[Mysql的存储结构#3 5 File Header（文件头部）|数据页]]一章中，我们介绍了数据页之间是一个双向链表，通过该链表，我们就能找到所有的数据记录。

![](https://varg-my-images.oss-cn-beijing.aliyuncs.com/img/202209060012224.png)

当数据量很大时，若想查找记录则需遍历该链表，这是非常耗时的。还记得我们为根据主键值快速定位一条记录在页中的位置而设立的 [[Mysql的存储结构#3 3 Page Directory（页目录）|页目录]]么？我们也可以想办法为快速定位记录所在的数据页而建立一个别的目录，建这个目录必须完成下边这些事儿：

- 下一个数据页中用户记录的主键值必须大于上一个页中用户记录的主键值。
    假设我们现在有一个页，其中有 3 条数据，并假设一个页中最多存放 3 条数据（实际上会有很多）：
    
    ![](https://varg-my-images.oss-cn-beijing.aliyuncs.com/img/202209060015878.png)
    ![](https://varg-my-images.oss-cn-beijing.aliyuncs.com/img/202209060015220.png)
    
    此时我们再来插入一条记录：
    
    ```sql
    mysql> INSERT INTO index_demo VALUES(4, 4, 'a'); Query OK, 1 row affected (0.00 sec)
    ```
    
    因为 `页10` 最多只能放 3 条记录，所以我们不得不再分配一个新页：
    
    ![](https://varg-my-images.oss-cn-beijing.aliyuncs.com/img/202209060017918.png)
    
    `页10` 中用户记录最大的主键值是 `5`，而 `页28` 中有一条记录的主键值是 `4`，因为 `5 > 4`，所以这就不符合下一个数据页中用户记录的主键值必须大于上一个页中用户记录的主键值的要求，所以在插入主键值为 `4` 的记录的时候需要伴随着一次记录移动，也就是把主键值为 `5` 的记录移动到 `页28` 中，然后再把主键值为 `4` 的记录插入到 `页10` 中，这个过程的示意图如下：
    
    ![](https://varg-my-images.oss-cn-beijing.aliyuncs.com/img/202209060018184.png)
    
    这个过程表明了**在对页中的记录进行增删改操作的过程中，我们必须通过一些诸如记录移动的操作来始终保证这个状态一直成立：下一个数据页中用户记录的主键值必须大于上一个页中用户记录的主键值。这个过程我们也可以称为 `页分裂`**。
- 给所有的页建立一个目录项。
	由于数据页的编号可能并不是连续的，所以在向 `index_demo` 表中插入许多条记录后，数据页可能会变得很多。所以如果想从这么多页中根据主键值快速定位某些记录所在的页，我们需要给它们做个目录，每个页对应一个目录项，每个目录项包括下边两个部分：
	- 页的用户记录中最小的主键值，我们用 `key` 来表示。
	- 页号，我们用 `page_no` 表示。

	![](https://varg-my-images.oss-cn-beijing.aliyuncs.com/img/202209060021912.png)

	以 `页28` 为例，它对应 `目录项2`，这个目录项中包含着该页的页号 `28` 以及该页中用户记录的最小主键值 `5`。我们只需要把几个目录项在物理存储器上连续存储，比如把他们放到一个数组里，就可以实现根据主键值快速查找某条记录的功能了。比方说我们想找主键值为 `20` 的记录，具体查找过程分两步：
    
    1. 先从目录项中根据二分法快速确定出主键值为 `20` 的记录在 `目录项3` 中（因为 `12 < 20 < 209`），它对应的页是 `页9`。
    2. 再根据前边说的在页中查找记录的方式去 `页9` 中定位具体的记录。

	至此，针对数据页做的简易目录就搞定了。这个 `目录` 有一个别名，称为 `索引`。

## 4.2. InnoDB 的索引结构

### 4.2.1. 索引的存储

上边之所以称为一个简易的索引方案，是因为我们为了在根据主键值进行查找时使用二分法快速定位具体的目录项而假设所有目录项都可以在物理存储器上连续存储，但是这样做有几个问题：
- `InnoDB` 是使用页来作为管理存储空间的基本单位，也就是最多能保证 `16KB` 的连续存储空间，而随着表中记录数量的增多，需要非常大的连续的存储空间才能把所有的目录项都放下，这对记录数量非常多的表是不现实的。
- 我们时常会对记录进行增删，假设我们把 `页28` 中的记录都删除了，`页28` 也就没有存在的必要了，那意味着 `目录项2` 也就没有存在的必要了，这就需要把 `目录项2` 后的目录项都向前移动一下，这种牵一发而动全身的设计不是什么好主意。

所以，设计 `InnoDB` 的大叔们需要一种可以灵活管理所有 `目录项` 的方式。他们灵光乍现，忽然发现**这些 `目录项` 其实长得跟我们的用户记录差不多，只不过 `目录项` 中的两个列是 `主键` 和 `页号` 而已**，所以他们复用了之前存储用户记录的数据页来存储目录项。

为了和用户记录做一下区分，我们把这些用来表示目录项的记录称为 `目录项记录`。那 `InnoDB` 怎么区分一条记录是普通的 `用户记录` 还是 `目录项记录` 呢？别忘了 [[Mysql的存储结构#3 2 1 数据的记录头信息|记录头信息]]里的 `record_type` 属性，它的各个取值代表的意思如下：
- `0` ：普通的用户记录
- `1` ：目录项记录
- `2` ：最小记录
- `3` ：最大记录

我们把前边使用到的目录项放到数据页中的样子就是这样：

![](https://varg-my-images.oss-cn-beijing.aliyuncs.com/img/202209060026474.png)

从图中可以看出来，我们新分配了一个编号为 `30` 的页来专门存储 `目录项记录`。这里再次强调一遍 `目录项记录` 和普通的 `用户记录` 的不同点：

- `目录项记录` 的 `record_type` 值是 1，而普通用户记录的 `record_type` 值是 0。
- `目录项记录` 只有主键值和页的编号两个列，而普通的用户记录的列是用户自己定义的，可能包含很多列，另外还有 `InnoDB` 自己添加的隐藏列。
- 还记得我们之前在唠叨 [[Mysql的存储结构#3 2 1 数据的记录头信息|记录头信息]]的时候说过一个叫 `min_rec_mask` 的属性么，只有在存储 `目录项记录` 的页中的主键值最小的 `目录项记录` 的 `min_rec_mask` 值为 `1`，其他别的记录的 `min_rec_mask` 值都是 `0`。

除了上述几点外，这两者就没啥差别了，它们用的是一样的数据页（页面类型都是 `0x45BF`，这个属性在 [[Mysql的存储结构#3 5 File Header（文件头部）|File Header]] 中），页的组成结构也是一样一样的（就是我们前边介绍过的 7 个部分），都会为主键值生成 `Page Directory`（页目录），从而在按照主键值进行查找时可以使用二分法来加快查询速度。

### 4.2.2. 索引的查找过程

现在以查找主键为 `20` 的记录为例，根据某个主键值去查找记录的步骤就可以大致拆分成下边两步：

1. 通过二分法定位数据所在的目录页。
	如查找主键为 20 的记录就是页 `30` 中通过二分法快速定位到对应目录项，因为 `12 < 20 < 209`，所以定位到对应的记录所在的页就是 `页9`。

	当目录页较多时，根据目录页范围定位数据到底在哪个目录页中。如以下例子：

	![](https://varg-my-images.oss-cn-beijing.aliyuncs.com/img/202209060036352.png)

	我们现在的存储 `目录项记录` 的页有两个，即 `页30` 和 `页32`，又因为 `页30` 表示的目录项的主键值的范围是 `[1, 320)`，`页32` 表示的目录项的主键值不小于 `320`，所以主键值为 `20` 的记录对应的目录项记录在 `页30` 中。

	为什么主键值范围是 `[1, 320)` 而不是 `[1, 209]` 呢？因为页 30 与页 32 之间通过链表连接，我们可以轻松到定位到页 30 的下一页，定位到下一页之后自然的就知道该页中第一条数据的值了，因此可以轻松的构建出这个范围。
	
2. 通过 `目录项记录` 页确定用户记录真实所在的页。
	同样是二分法定位数据。
2. 在真实存储用户记录的页中采用二分法定位到具体的记录。
	到存储用户记录的 `页9` 中根据二分法快速定位到主键值为 `20` 的用户记录。

随着我们的数据越来越多，因此数据页和目录页就会越来越多。这些页在存储空间中也可能不挨着，如果我们表中的数据非常多则会产生很多存储 `目录项记录` 的页，那我们怎么根据主键值快速定位一个存储 `目录项记录` 的页呢？其实也简单，为这些存储 `目录项记录` 的页再生成一个更高级的目录，就像是一个多级目录一样，大目录里嵌套小目录，小目录里才是实际的数据，所以现在各个页的示意图就是这样子：

![](https://varg-my-images.oss-cn-beijing.aliyuncs.com/img/202209060040013.png)

如果简化一下，它就变成了以下这个结构，这就是 B+树：

![](https://varg-my-images.oss-cn-beijing.aliyuncs.com/img/202209060041061.png)

不论是存放用户记录的数据页，还是存放目录项记录的数据页，我们都把它们存放到 `B+` 树这个数据结构中了，所以我们也称这些数据页为 `节点`。

从图中可以看出来，我们的实际用户记录其实都存放在 B+树的最底层的节点上，这些节点也被称为 `叶子节点` 或 `叶节点`，其余用来存放 `目录项` 的节点称为 `非叶子节点` 或者 `内节点`，其中 `B+` 树最上边的那个节点也称为 `根节点`。

从图中可以看出来，一个 `B+` 树的节点其实可以分成好多层，最下边的那层，也就是存放我们用户记录的那层为第 `0` 层，之后依次往上加。

之前的讨论我们做了一个非常极端的假设：存放用户记录的页最多存放 3 条记录，存放目录项记录的页最多存放 4 条记录。其实真实环境中一个页存放的记录数量是非常大的，假设，假设，假设所有存放用户记录的叶子节点代表的数据页可以存放 100 条用户记录，所有存放目录项记录的内节点代表的数据页可以存放 1000 条目录项记录，那么：

- 如果 `B+` 树只有 1 层，也就是只有 1 个用于存放用户记录的节点，最多能存放 `100` 条记录。
- 如果 `B+` 树有 2 层，最多能存放 `1000×100=100000` 条记录。
- 如果 `B+` 树有 3 层，最多能存放 `1000×1000×100=100000000` 条记录。
- 如果 `B+` 树有 4 层，最多能存放 `1000×1000×1000×100=100000000000` 条记录。哇咔咔～这么多的记录！！！

你的表里能存放 `100000000000` 条记录么？所以一般情况下，我们用到的 `B+` 树都不会超过 4 层，那我们通过主键值去查找某条记录最多只需要做 4 个页面内的查找（查找 3 个目录项页和一个用户记录页），又因为在每个页面内有所谓的 `Page Directory`（页目录），所以在页面内也可以通过二分法实现快速定位记录，因此这个速度就很快了！

### 4.2.3. 索引的构建过程

我们前边介绍 `B+` 树索引的时候，为了大家理解上的方便，先把存储用户记录的叶子节点都画出来，然后接着画存储目录项记录的内节点，实际上 `B+` 树的形成过程是这样的：

- 建表时初始化主键索引
	每当为某个表创建一个 `B+` 树索引（聚簇索引不是人为创建的，默认就有）的时候，都会为这个索引创建一个 `根节点` 页面。最开始表中没有数据的时候，每个 `B+` 树索引对应的 `根节点` 中既没有用户记录，也没有目录项记录。
- 随后向表中插入用户记录时，先把用户记录存储到这个 `根节点` 中。
- 根结点页面使用完毕后进行页分裂
	当 `根节点` 中的可用空间用完时继续插入记录，此时会**将 `根节点` 中的所有记录复制到一个新分配的页**，比如 `页a` 中，然后对这个新页进行 `页分裂` 的操作，得到另一个新页，比如 `页b`。
	
	这时新插入的记录根据键值（也就是聚簇索引中的主键值，二级索引中对应的索引列的值）的大小就会被分配到 `页a` 或者 `页b` 中，而 **`根节点` 便升级为存储目录项记录的页**。

这个过程需要大家特别注意的是：一个 B+树索引的根节点自诞生之日起，便不会再移动。这样只要我们对某个表建立一个索引，那么它的 `根节点` 的页号便会被记录到[[数据库/Mysql的存储结构#5 2 2 2 3 SYS_INDEXES 表|系统表空间中]]，然后凡是 `InnoDB` 存储引擎需要用到这个索引的时候，都会从那个固定的地方取出 `根节点` 的页号，从而来访问这个索引。

## 4.3. 聚簇索引

我们上边介绍的 `B+` 树本身就是一个目录，或者说本身就是一个索引。它有两个特点：

1. 使用记录主键值的大小进行记录和页的排序，这包括三个方面的含义：
    - 页内的记录是按照主键的大小顺序排成一个单向链表。
    - 各个存放用户记录的页也是根据页中用户记录的主键大小顺序排成一个双向链表。
    - 存放目录项记录的页分为不同的层次，在同一层次中的页也是根据页中目录项记录的主键大小顺序排成一个双向链表。
2. `B+` 树的叶子节点存储的是完整的用户记录。
    所谓完整的用户记录，就是指这个记录中存储了所有列的值（包括隐藏列）。

我们把具有这两种特性的 `B+` 树称为 `聚簇索引`，所有完整的用户记录都存放在这个 `聚簇索引` 的叶子节点处。这种 `聚簇索引` 并不需要我们在 `MySQL` 语句中显式的使用 `INDEX` 语句去创建，`InnoDB` 存储引擎会自动的为我们创建聚簇索引。另外有趣的一点是，在 `InnoDB` 存储引擎中，`聚簇索引` 就是数据的存储方式（所有的用户记录都存储在了 `叶子节点`），也就是所谓的索引即数据，数据即索引。

## 4.4. 二级索引

`聚簇索引` 只能在搜索条件是主键值时才能发挥作用，因为 `B+` 树中的数据都是按照主键进行排序的。那如果我们想以别的列作为搜索条件该咋办呢？我们可以多建几棵 `B+` 树，不同的 `B+` 树中的数据采用不同的排序规则。比方说我们用 `c2` 列的大小作为数据页、页中记录的排序规则，再建一棵 `B+` 树，效果如下图所示：

![](https://varg-my-images.oss-cn-beijing.aliyuncs.com/img/202209060045675.png)

这个 `B+` 树与上边介绍的聚簇索引有几处不同：

- 使用记录 `c2` 列的大小进行记录和页的排序，这包括三个方面的含义：
    - 页内的记录是按照 `c2` 列的大小顺序排成一个单向链表。
    - 各个存放用户记录的页也是根据页中记录的 `c2` 列大小顺序排成一个双向链表。
    - 存放目录项记录的页分为不同的层次，在同一层次中的页也是根据页中目录项记录的 `c2` 列大小顺序排成一个双向链表。
- `B+` 树的叶子节点存储的并不是完整的用户记录，而只是 `c2列+主键` 这两个列的值。
- 目录项记录中不再是 `主键+页号` 的搭配，而变成了 `c2列+页号` 的搭配。

	事实上，除了 `C2` 列之外，二级索引中还有主键值。如果二级索引中目录项记录的内容只是 `索引列 + 页号` 的搭配的话，那么为 `c2` 列建立索引后的 `B+` 树应该长这样：

	![](https://varg-my-images.oss-cn-beijing.aliyuncs.com/img/202209060052678.png)

	如果我们想新插入一行记录，其中 `c1`、`c2`、`c3` 的值分别是：`9`、`1`、`'c'`，那么在修改这个为 `c2` 列建立的二级索引对应的 `B+` 树时便碰到了个大问题：由于 `页3` 中存储的目录项记录是由 `c2列 + 页号` 的值构成的，`页3` 中的两条目录项记录对应的 `c2` 列的值都是 `1`，而我们新插入的这条记录的 `c2` 列的值也是 `1`，那我们这条新插入的记录到底应该放到 `页4` 中，还是应该放到 `页5` 中啊？答案是：对不起，懵逼了。

	为了让新插入记录能找到自己在那个页里，我们需要**保证在 B+树的同一层内节点的目录项记录除 `页号` 这个字段以外是唯一的**。所以对于二级索引的内节点的目录项记录的内容实际上是由三个部分构成的：

	- 索引列的值
	- 主键值
	- 页号

	也就是我们把 `主键值` 也添加到二级索引内节点中的目录项记录了，这样就能保证 `B+` 树每一层节点中各条目录项记录除 `页号` 这个字段外是唯一的，所以我们为 `c2` 列建立二级索引后的示意图实际上应该是这样子的：

	![](https://varg-my-images.oss-cn-beijing.aliyuncs.com/img/202209060053306.png)

	这样我们再插入记录 `(9, 1, 'c')` 时，由于 `页3` 中存储的目录项记录是由 `c2列 + 主键 + 页号` 的值构成的，可以先把新记录的 `c2` 列的值和 `页3` 中各目录项记录的 `c2` 列的值作比较，如果 `c2` 列的值相同的话，可以接着比较主键值，因为 `B+` 树同一层中不同目录项记录的 `c2列 + 主键` 的值肯定是不一样的，所以最后肯定能定位唯一的一条目录项记录，在本例中最后确定新记录应该被插入到 `页5` 中。

二级索引树和聚簇索引查询是一模一样的，不同的地方在于索引中数据的字段换了而已。

我们根据这个以 `c2` 列大小排序的 `B+` 树只能确定我们要查找记录的主键值，所以如果我们想根据 `c2` 列的值查找到完整的用户记录的话，仍然需要到 `聚簇索引` 中再查一遍，这个过程也被称为 `回表`。也就是根据 `c2` 列的值查询一条完整的用户记录需要使用到 `2` 棵 `B+` 树！

## 4.5. MyISAM 索引结构

我们知道 `InnoDB` 中索引即数据，也就是聚簇索引的那棵 `B+` 树的叶子节点中已经把所有完整的用户记录都包含了，而 `MyISAM` 的索引方案虽然也使用树形结构，但是却将索引和数据分开存储：

**MyISAM 将表中的记录按照记录的插入顺序单独存储在一个文件中，称之为 `数据文件`**。这个文件并不划分为若干个数据页，有多少记录就往这个文件中塞多少记录就成了。我们可以通过行号而快速访问到一条记录。

`MyISAM` 记录也需要记录头信息来存储一些额外数据，我们以上边唠叨过的 `index_demo` 表为例，看一下这个表中的记录使用 `MyISAM` 作为存储引擎在存储空间中的表示：

![](https://varg-my-images.oss-cn-beijing.aliyuncs.com/img/202209060059582.png)

由于在插入数据的时候并没有刻意按照主键大小排序，所以我们并不能在这些数据上使用二分法进行查找。

**使用 `MyISAM` 存储引擎的表会把索引信息另外存储到一个称为 `索引文件` 的另一个文件中**。`MyISAM` 会单独为表的主键创建一个索引，只不过在索引的叶子节点中存储的不是完整的用户记录，而是 `主键值 + 行号` 的组合。也就是先通过索引找到对应的行号，再通过行号去找对应的记录！

这一点和 `InnoDB` 是完全不相同的，在 `InnoDB` 存储引擎中，我们只需要根据主键值对 `聚簇索引` 进行一次查找就能找到对应的记录，而在 `MyISAM` 中却需要进行一次 `回表` 操作，意味着 `MyISAM` 中建立的索引相当于全部都是 `二级索引`！

如果有需要的话，我们也可以对其它的列分别建立索引或者建立联合索引，原理和 `InnoDB` 中的索引差不多，不过在叶子节点处存储的是 `相应的列 + 行号`。这些索引也全部都是 `二级索引`。

MyISAM 的行格式有定长记录格式（Static）、变长记录格式（Dynamic）、压缩记录格式（Compressed）。上边用到的 index_demo 表采用定长记录格式，也就是一条记录占用存储空间的大小是固定的，这样就可以轻松算出某条记录在数据文件中的地址偏移量。但是变长记录格式就不行了，MyISAM 会直接在索引叶子节点处存储该条记录在数据文件中的地址偏移量。

通过这个可以看出，MyISAM 的回表操作是十分快速的，因为是拿着地址偏移量直接到文件中取数据的，反观 InnoDB 是通过获取主键之后再去聚簇索引里边儿找记录，虽然说也不慢，但还是比不上直接用地址去访问。

# 5. Mysql 的表空间

现在我们已经知道了数据是按以下格式存储的：

- `InnoDB` 其实是使用 `页` 为基本单位来管理存储空间的，默认的 `页` 大小为 `16KB`。
- 对于 `InnoDB` 存储引擎来说，每个索引都对应着一棵 `B+` 树，该 `B+` 树的每个节点都是一个数据页，数据页之间不必要是物理连续的，因为数据页之间有 `双向链表` 来维护着这些页的顺序。
- `InnoDB` 的聚簇索引的叶子节点存储了完整的用户记录，也就是所谓的索引即数据，数据即索引。

为了更好的管理这些页，Mysql 提出了一个 `表空间` 或者 `文件空间`（英文名：`table space` 或者 `file space`）的概念，这个表空间是一个抽象的概念，它可以对应文件系统上一个或多个真实文件（不同表空间对应的文件数量可能不同）。

每一个 `表空间` 可以被划分为很多很多很多个 `页`，我们的表数据就存放在某个 `表空间` 下的某些页里，表空间划分为几种不同的类型。

## 5.1. 表空间分类

### 5.1.1. 系统表空间

`系统表空间` 可以对应文件系统上一个或多个实际的文件，默认情况下，`InnoDB` 会在 `数据目录` 下创建一个名为 `ibdata1`、大小为 `12M` 的文件，这个文件就是对应的 `系统表空间` 在文件系统上的表示。这个文件是 `自扩展文件`，也就是当不够用的时候它会自己增加文件大小。

系统表空间的初始大小和存储位置可以自行配置。

### 5.1.2. 独立表空间

在 MySQL5.6.6 以及之后的版本中，`InnoDB` 并不会默认的把各个表的数据存储到系统表空间中，而是为每一个表建立一个独立表空间，也就是说我们创建了多少个表，就有多少个独立表空间。

使用 `独立表空间` 来存储表数据的话，会在该表所属数据库对应的子目录下创建一个表示该 `独立表空间` 的文件，文件名和表名相同，只不过添加了一个 `.ibd` 的扩展名而已，所以完整的文件名称类型这样：`表名.ibd`。

### 5.1.3. 其它类型表空间

随着 MySQL 的发展，除了上述两种老牌表空间之外，现在还新提出了一些不同类型的表空间，比如通用表空间（general tablespace）、undo 表空间（undo tablespace）、临时表空间（temporary tablespace）等。

## 5.2. 表空间的存储格式

![](https://varg-my-images.oss-cn-beijing.aliyuncs.com/img/202209070114027.png)

### 5.2.1. 独立表空间

#### 5.2.1.1. 区（exient）的概述

表空间中的页实在是太多了，既包含索引页，还包含数据页以及其他各种的页类型。为了更好的管理这些页面，设计 `InnoDB` 的大叔们提出了 `区`（英文名：`extent`）的概念。对于 16KB 的页来说，连续的 64 个页就是一个 `区`，也就是说一个区默认占用 1MB 空间大小。不论是系统表空间还是独立表空间，都可以看成是由若干个区组成的，每 256 个区被划分成一组。画个图表示就是这样：

![](https://varg-my-images.oss-cn-beijing.aliyuncs.com/img/202209070109823.png)

划分区以后虽然能减少页管理的数量，但是**一方面区的数量仍非常多，另一方面我们需要额外管理这些区的信息，因此提出了 `组` 的概念**。一个组包含 256 个区，利用组的前几个页面中存放了区管理的信息和其他的一些信息：

![](https://varg-my-images.oss-cn-beijing.aliyuncs.com/img/202209070111554.png)

从上图中我们能得到如下信息：

- 第一个组最开始的 3 个页面的类型是固定的，也就是说 `extent 0` 这个区最开始的 3 个页面的类型是固定的，分别是：
    - `FSP_HDR` 类型：这个类型的页面是用来登记整个表空间的一些整体属性以及本组所有的 `区`，也就是 `extent 0` ~ `extent 255` 这 256 个区的属性。需要注意的一点是，整个表空间只有一个 `FSP_HDR` 类型的页面。
    - `IBUF_BITMAP` 类型：这个类型的页面是存储本组所有的区的所有页面关于 `INSERT BUFFER` 的信息。
    - `INODE` 类型：这个类型的页面存储了许多称为 `INODE` 的数据结构。
- 其余各组最开始的 2 个页面的类型是固定的，也就是说 `extent 256`、`extent 512` 这些区最开始的 2 个页面的类型是固定的，分别是：
    - `XDES` 类型：全称是 `extent descriptor`，用来登记本组 256 个区的属性，也就是说对于在 `extent 256` 区中的该类型页面存储的就是 `extent 256` ~ `extent 511` 这些区的属性，对于在 `extent 512` 区中的该类型页面存储的就是 `extent 512` ~ `extent 767` 这些区的属性。上边介绍的 `FSP_HDR` 类型的页面其实和 `XDES` 类型的页面的作用类似，只不过 `FSP_HDR` 类型的页面还会额外存储一些表空间的属性。
    -   `IBUF_BITMAP` 类型：上边介绍过了。

#### 5.2.1.2. 段（segment）的概述

**一方面为了更好的管理页的内容，另一方面为了使页连续分配而利用顺序 IO 的特性**，我们引入了区的概念，但是这仍然不够。

**对 `B+` 树节点中的记录进行顺序扫描，而如果不区分叶子节点和非叶子节点，统统把节点代表的页面放到申请到的区中的话，进行范围扫描的效果就大打折扣了**。所以设计 `InnoDB` 的大叔们对 `B+` 树的叶子节点和非叶子节点进行了区别对待，也就是说叶子节点有自己独有的 `区`，非叶子节点也有自己独有的 `区`。存放叶子节点的区的集合就算是一个 `段`（`segment`），存放非叶子节点的区的集合也算是一个 `段`。**也就是说一个索引会生成 2 个段，一个叶子节点段，一个非叶子节点段**。

默认情况下一个使用 `InnoDB` 存储引擎的表只有一个聚簇索引，一个索引会生成 2 个段，而段是以区为单位申请存储空间的，一个区默认占用 1M 存储空间，所以默认情况下一个只存了几条记录的小表也需要 2M 的存储空间么？以后每次添加一个索引都要多申请 2M 的存储空间么？这对于存储记录比较少的表简直是天大的浪费。

为了考虑以完整的区为单位分配给某个段对于数据量较小的表太浪费存储空间的这种情况，设计 `InnoDB` 的大叔们提出了一个碎片（fragment）区的概念，也就是在一个碎片区中，并不是所有的页都是为了存储同一个段的数据而存在的，而是碎片区中的页可以用于不同的目的，比如有些页用于段 A，有些页用于段 B，有些页甚至哪个段都不属于。**碎片区直属于表空间，并不属于任何一个段**。所以此后为某个段分配存储空间的策略是这样的：
- 在刚开始向表中插入数据的时候，段是从某个碎片区以单个页面为单位来分配存储空间的。
- 当某个段已经占用了 32 个碎片区页面之后，就会以完整的区为单位来分配存储空间。

所以现在**段不能仅定义为是某些区的集合，更精确的应该是某些零散的页面以及一些完整的区的集合**。除了索引的叶子节点段和非叶子节点段之外，`InnoDB` 中还有为存储一些特殊的数据而定义的段，比如回滚段，当然我们现在并不关心别的类型的段，现在只需要知道段是一些零散的页面以及一些完整的区的集合就好了。

#### 5.2.1.3. 区的分类

从上我们可以了解到表空间的是由若干个区组成的，这些区大体上可以分为 4 种类型：
- 空闲的区：现在还没有用到这个区中的任何页面。
- 有剩余空间的碎片区：表示碎片区中还有可用的页面。
- 没有剩余空间的碎片区：表示碎片区中的所有页面都被使用，没有空闲页面。
- 附属于某个段的区。每一个索引都可以分为叶子节点段和非叶子节点段，除此之外 InnoDB 还会另外定义一些特殊作用的段，在这些段中的数据量很大时将使用区来作为基本的分配单位。

4 种类型的区也可以被称为区的 4 种状态（`State`）：

<table> <thead> <tr> <th> 状态名 </th> <th> 含义 </th> </tr> </thead> <tbody> <tr> <td> <code> FREE </code> </td> <td> 空闲的区 </td> </tr> <tr> <td> <code> FREE_FRAG </code> </td> <td> 有剩余空间的碎片区 </td> </tr> <tr> <td> <code> FULL_FRAG </code> </td> <td> 没有剩余空间的碎片区 </td> </tr> <tr> <td> <code> FSEG </code> </td> <td> 附属于某个段的区 </td> </tr> </tbody> </table>

需要再次强调一遍的是，**处于 `FREE`、`FREE_FRAG` 以及 `FULL_FRAG` 这三种状态的区都是独立的，算是直属于表空间；处于 `FSEG` 状态的区是附属于某个段的**。

##### 5.2.1.3.1. XDES Entry

为了方便管理这些不同类型的区，Mysql 设计了一个称为 `XDES Entry` 的结构（全称就是 Extent Descriptor Entry），每一个区都对应着一个 `XDES Entry` 结构，这个结构记录了对应的区的一些属性：

![](https://varg-my-images.oss-cn-beijing.aliyuncs.com/img/202209070125885.png)

- `Segment ID`（8 字节）
    每一个段都有一个唯一的编号，用 ID 表示，此处的 `Segment ID` 字段表示就是该区所在的段。当然前提是该区已经被分配给某个段了，不然的话该字段的值没啥意义。
- `List Node`（12 字节）
	这个部分可以将若干个 `XDES Entry` 结构串联成一个链表，大家看一下这个 `List Node` 的结构：

	![](https://varg-my-images.oss-cn-beijing.aliyuncs.com/img/202209070129244.png)
	如果我们想定位表空间内的某一个位置的话，只需指定页号以及该位置在指定页号中的页内偏移量即可。所以：
	- `Pre Node Page Number` 和 `Pre Node Offset` 的组合就是指向前一个 `XDES Entry` 的指针
	- `Next Node Page Number` 和 `Next Node Offset` 的组合就是指向后一个 `XDES Entry` 的指针。
- `State`（4 字节）
	这个字段表明区的状态。可选的值就是我们前边说过的那 4 个，分别是：`FREE`、`FREE_FRAG`、`FULL_FRAG` 和 `FSEG`。
- `Page State Bitmap`（16 字节）
	这个部分共占用 16 个字节，也就是 128 个比特位。我们说一个区默认有 64 个页，这 128 个比特位被划分为 64 个部分，每个部分 2 个比特位，对应区中的一个页。比如 `Page State Bitmap` 部分的第 1 和第 2 个比特位对应着区中的第 1 个页面，第 3 和第 4 个比特位对应着区中的第 2 个页面，依此类推，`Page State Bitmap` 部分的第 127 和 128 个比特位对应着区中的第 64 个页面。
	
	这两个比特位的第一个位表示对应的页是否是空闲的，第二个比特位还没有用。

##### 5.2.1.3.2. XDES Entry 链表

上面介绍了数据的插入流程：首先会查看表空间中是否有状态为 `FREE_FRAG` 的区，也就是找还有空闲空间的碎片区，如果找到了，那么从该区中取一些零散的页把数据插进去；否则到表空间下申请一个状态为 `FREE` 的区，也就是空闲的区，把该区的状态变为 `FREE_FRAG`，然后从该新申请的区中取一些零散的页把数据插进去。之后不同的段使用零散页的时候都会从该区中取，直到该区中没有空闲空间，然后该区的状态就变成了 `FULL_FRAG`。

那么我们**怎么知道表空间里的哪些区是 `FREE` 的，哪些区的状态是 `FREE_FRAG` 的，哪些区是 `FULL_FRAG` 的**？这时候就是 `XDES Entry` 中的 `List Node` 部分发挥奇效的时候了，我们可以通过 `List Node` 中的指针，做这么三件事：
- 把状态为 `FREE` 的区对应的 `XDES Entry` 结构通过 `List Node` 来连接成一个链表，这个链表我们就称之为 `FREE` 链表。
- 把状态为 `FREE_FRAG` 的区对应的 `XDES Entry` 结构通过 `List Node` 来连接成一个链表，这个链表我们就称之为 `FREE_FRAG` 链表。
- 把状态为 `FULL_FRAG` 的区对应的 `XDES Entry` 结构通过 `List Node` 来连接成一个链表，这个链表我们就称之为 `FULL_FRAG` 链表。

这样每当我们想找一个 `FREE_FRAG` 状态的区时，就直接把 `FREE_FRAG` 链表的头节点拿出来，从这个节点中取一些零散的页来插入数据，当这个节点对应的区用完时，就修改一下这个节点的 `State` 字段的值，然后从 `FREE_FRAG` 链表中移到 `FULL_FRAG` 链表中。同理，如果 `FREE_FRAG` 链表中一个节点都没有，那么就直接从 `FREE` 链表中取一个节点移动到 `FREE_FRAG` 链表的状态，并修改该节点的 `STATE` 字段值为 `FREE_FRAG`，然后从这个节点对应的区中获取零散的页就好了。

当段中数据已经占满了 32 个零散的页后，就直接申请完整的区来插入数据了。同理，**对于归属于段的区我们也可以采用这种链表的方式对不同状态的区进行管理**：
- `FREE` 链表：同一个段中，所有页面都是空闲的区对应的 `XDES Entry` 结构会被加入到这个链表。注意和直属于表空间的 `FREE` 链表区别开了，此处的 `FREE` 链表是附属于某个段的。
- `NOT_FULL` 链表：同一个段中，仍有空闲空间的区对应的 `XDES Entry` 结构会被加入到这个链表。
- `FULL` 链表：同一个段中，已经没有空闲空间的区对应的 `XDES Entry` 结构会被加入到这个链表。

再次强调一遍，**每一个索引都对应两个段，每个段都会维护上述的 3 个链表**。

##### 5.2.1.3.3. 链表基节点

上边光是介绍了一堆链表，可我们怎么找到这些链表呢，或者说怎么找到某个链表的头节点或者尾节点在表空间中的位置呢？Mysql 设计了一个叫 `List Base Node` 的结构，这个结构中包含了链表的头节点和尾节点的指针以及这个链表中包含了多少节点的信息：

![](https://varg-my-images.oss-cn-beijing.aliyuncs.com/img/202209070138751.png)

我们上边介绍的每个链表都对应这么一个 `List Base Node` 结构，其中：

- `List Length` 表明该链表一共有多少节点，
- `First Node Page Number` 和 `First Node Offset` 表明该链表的头节点在表空间中的位置。
- `Last Node Page Number` 和 `Last Node Offset` 表明该链表的尾节点在表空间中的位置。

一般我们把某个链表对应的 `List Base Node` 结构放置在[[数据库/Mysql的存储结构#5 2 1 5 1 1 File Space Header|表空间中固定的位置]]，这样想找定位某个链表就变得 so easy 啦。

#### 5.2.1.4. 段的结构 INODE Entry

我们前边说过，段其实不对应表空间中某一个连续的物理区域，而是一个逻辑上的概念，由若干个零散的页面以及一些完整的区组成。像每个区都有对应的 `XDES Entry` 来记录这个区中的属性一样，设计 `InnoDB` 的大叔为每个段都定义了一个 `INODE Entry` 结构来记录一下段中的属性：

![](https://varg-my-images.oss-cn-beijing.aliyuncs.com/img/202209070140580.png)

它的各个部分释义如下：

- `Segment ID`
    就是指这个 `INODE Entry` 结构对应的段的编号（ID）。
- `NOT_FULL_N_USED`
    这个字段指的是在 `NOT_FULL` 链表中已经使用了多少个页面。
- 3 个 `List Base Node`
    分别为段的 `FREE` 链表、`NOT_FULL` 链表、`FULL` 链表定义了 `List Base Node`，这样我们想查找某个段的某个链表的头节点和尾节点的时候，就可以直接到这个部分找到对应链表的 `List Base Node`。so easy!
- `Magic Number` 
    这个值是用来标记这个 `INODE Entry` 是否已经被初始化了（初始化的意思就是把各个字段的值都填进去了）。如果这个数字是值的 `97937874`，表明该 `INODE Entry` 已经初始化，否则没有被初始化。。
- `Fragment Array Entry`
    我们前边强调过无数次段是一些零散页面和一些完整的区的集合，每个 `Fragment Array Entry` 结构都对应着一个零散的页面，这个结构一共 4 个字节，表示一个零散页面的页号。

#### 5.2.1.5. 区与段的管理

现在我们已经了解了区和段的结构，那么区和段是如何管理的呢？我们又怎么在表空间中找到这些区和段呢？每个区对应的 `XDES Entry` 结构到底存储在表空间的什么地方？直属于表空间的 `FREE`、`FREE_FRAG`、`FULL_FRAG` 链表的基节点到底存储在表空间的什么地方？每个段对应的 `INODE Entry` 结构到底存在表空间的什么地方？这就涉及到了区和段的管理部分。

##### 5.2.1.5.1. FSP_HDR 类型页

首先看第一个组的第一个页面，当然也是表空间的第一个页面，页号为 `0`。这个页面的类型是 `FSP_HDR`，它**存储了表空间的一些整体属性以及第一个组内 256 个区的对应的 `XDES Entry` 结构**：

![](https://varg-my-images.oss-cn-beijing.aliyuncs.com/img/202209070146831.png)

从图中可以看出，一个完整的 `FSP_HDR` 类型的页面大致由 5 个部分组成：

<table> <thead> <tr> <th> 名称 </th> <th> 中文名 </th> <th> 占用空间大小 </th> <th> 简单描述 </th> </tr> </thead> <tbody> <tr> <td> <code> File Header </code> </td> <td> 文件头部 </td> <td> <code> 38 </code> 字节 </td> <td> 页的一些通用信息 </td> </tr> <tr> <td> <code> File Space Header </code> </td> <td> 表空间头部 </td> <td> <code> 112 </code> 字节 </td> <td> 表空间的一些整体属性信息 </td> </tr> <tr> <td> <code> XDES Entry </code> </td> <td> 区描述信息 </td> <td> <code> 10240 </code> 字节 </td> <td> 存储本组 256 个区对应的属性信息 </td> </tr> <tr> <td> <code> Empty Space </code> </td> <td> 尚未使用空间 </td> <td> <code> 5986 </code> 字节 </td> <td> 用于页结构的填充，没啥实际意义 </td> </tr> <tr> <td> <code> File Trailer </code> </td> <td> 文件尾部 </td> <td> <code> 8 </code> 字节 </td> <td> 校验页是否完整 </td> </tr> </tbody> </table>

[[Mysql的存储结构#3 5 File Header（文件头部）|File Header]] 和 [[Mysql的存储结构#3 6 File Trailer（文件尾部）|File Trailer]] 就不再强调了，另外的几个部分中，`Empty Space` 是尚未使用的空间，我们不用管它，重点来看看 `File Space Header` 和 `XDES Entry` 这两个部分。

###### 5.2.1.5.1.1. File Space Header

这个部分是用来存储表空间的一些整体属性的:

![](https://varg-my-images.oss-cn-beijing.aliyuncs.com/img/202209070148925.png)

下面是各个属性的简单描述：

<table> <thead> <tr> <th> 名称 </th> <th> 占用空间大小 </th> <th> 描述 </th> </tr> </thead> <tbody> <tr> <td> <code> Space ID </code> </td> <td> <code> 4 </code> 字节 </td> <td> 表空间的 ID </td> </tr> <tr> <td> <code> Not Used </code> </td> <td> <code> 4 </code> 字节 </td> <td> 这 4 个字节未被使用，可以忽略 </td> </tr> <tr> <td> <code> Size </code> </td> <td> <code> 4 </code> 字节 </td> <td> 当前表空间占有的页面数 </td> </tr> <tr> <td> <code> FREE Limit </code> </td> <td> <code> 4 </code> 字节 </td> <td> 尚未被初始化的最小页号，大于或等于这个页号的区对应的 XDES Entry 结构都没有被加入 FREE 链表 </td> </tr> <tr> <td> <code> Space Flags </code> </td> <td> <code> 4 </code> 字节 </td> <td> 表空间的一些占用存储空间比较小的属性 </td> </tr> <tr> <td> <code> FRAG_N_USED </code> </td> <td> <code> 4 </code> 字节 </td> <td> FREE_FRAG 链表中已使用的页面数量 </td> </tr> <tr> <td> <code> List Base Node for FREE List </code> </td> <td> <code> 16 </code> 字节 </td> <td> FREE 链表的基节点 </td> </tr> <tr> <td> <code> List Base Node for FREE_FRAG List </code> </td> <td> <code> 16 </code> 字节 </td> <td> FREE_FRAG 链表的基节点 </td> </tr> <tr> <td> <code> List Base Node for FULL_FRAG List </code> </td> <td> <code> 16 </code> 字节 </td> <td> FULL_FRAG 链表的基节点 </td> </tr> <tr> <td> <code> Next Unused Segment ID </code> </td> <td> <code> 8 </code> 字节 </td> <td> 当前表空间中下一个未使用的 Segment ID </td> </tr> <tr> <td> <code> List Base Node for SEG_INODES_FULL List </code> </td> <td> <code> 16 </code> 字节 </td> <td> SEG_INODES_FULL 链表的基节点 </td> </tr> <tr> <td> <code> List Base Node for SEG_INODES_FREE List </code> </td> <td> <code> 16 </code> 字节 </td> <td> SEG_INODES_FREE 链表的基节点 </td> </tr> </tbody> </table>

`Space ID`、`Not Used`、`Size` 这三个字段大家肯定一看就懂，其他的字段我们再详细解释下：

- `List Base Node for FREE List`、`List Base Node for FREE_FRAG List`、`List Base Node for FULL_FRAG List`。
    这三个大家看着太亲切了，分别是直属于表空间的 `FREE` 链表的基节点、`FREE_FRAG` 链表的基节点、`FULL_FRAG` 链表的基节点，这三个链表的基节点在表空间的位置是固定的，就是在表空间的第一个页面（也就是 `FSP_HDR` 类型的页面）的 `File Space Header` 部分。所以之后定位这几个链表就 so easy 啦。
- `FRAG_N_USED`
    这个字段表明在 `FREE_FRAG` 链表中已经使用的页面数量。
- `FREE Limit`
    我们知道表空间都对应着具体的磁盘文件，一开始我们创建表空间的时候对应的磁盘文件中都没有数据，所以我们需要对表空间完成一个初始化操作，包括为表空间中的区建立 `XDES Entry` 结构，为各个段建立 `INODE Entry` 结构，建立各种链表等各种操作。
    
    我们可以一开始就为表空间申请一个特别大的空间，但是实际上有绝大部分的区是空闲的，我们可以选择把所有的这些空闲区对应的 `XDES Entry` 结构加入 `FREE` 链表，也可以选择只把一部分的空闲区加入 `FREE` 链表，等啥时候空闲链表中的 `XDES Entry` 结构对应的区不够使了，再把之前没有加入 `FREE` 链表的空闲区对应的 `XDES Entry` 结构加入 `FREE` 链表，中心思想就是啥时候用到啥时候初始化。
    
    Mysql 为表空间定义了 `FREE Limit` 这个字段，在该字段表示的页号之前的区都被初始化了，之后的区尚未被初始化。

- `Next Unused Segment ID`
	表中每个索引都对应 2 个段，每个段都有一个唯一的 ID。设计 `InnoDB` 的大叔们提出了这个名叫 `Next Unused Segment ID` 的字段，该字段表明当前表空间中最大的段 ID 的下一个 ID，这样在创建新段的时候赋予新段一个唯一的 ID 值就直接使用这个字段的值就好了。
- `Space Flags`
	表空间对于一些布尔类型的属性，或者只需要寥寥几个比特位搞定的属性都放在了这个 `Space Flags` 中存储，虽然它只有 4 个字节，32 个比特位大小，却存储了好多表空间的属性：

	<table> <thead> <tr> <th> 标志名称 </th> <th> 占用的空间（单位：bit）</th> <th> 描述 </th> </tr> </thead> <tbody> <tr> <td> <code> POST_ANTELOPE </code> </td> <td> 1 </td> <td> 表示文件格式是否大于 <code> ANTELOPE </code> </td> </tr> <tr> <td> <code> ZIP_SSIZE </code> </td> <td> 4 </td> <td> 表示压缩页面的大小 </td> </tr> <tr> <td> <code> ATOMIC_BLOBS </code> </td> <td> 1 </td> <td> 表示是否自动把值非常长的字段放到 BLOB 页里 </td> </tr> <tr> <td> <code> PAGE_SSIZE </code> </td> <td> 4 </td> <td> 页面大小 </td> </tr> <tr> <td> <code> DATA_DIR </code> </td> <td> 1 </td> <td> 表示表空间是否是从默认的数据目录中获取的 </td> </tr> <tr> <td> <code> SHARED </code> </td> <td> 1 </td> <td> 是否为共享表空间 </td> </tr> <tr> <td> <code> TEMPORARY </code> </td> <td> 1 </td> <td> 是否为临时表空间 </td> </tr> <tr> <td> <code> ENCRYPTION </code> </td> <td> 1 </td> <td> 表空间是否加密 </td> </tr> <tr> <td> <code> UNUSED </code> </td> <td> 18 </td> <td> 没有使用到的比特位 </td> </tr> </tbody> </table>

- `List Base Node for SEG_INODES_FULL List` 和 `List Base Node for SEG_INODES_FREE List`
	每个段对应的 `INODE Entry` 结构会集中存放到一个类型为 [[Mysql的存储结构#5 2 1 5 4 INODE 类型页面|INODE]] 的页中，如果表空间中的段特别多，则会有多个 `INODE Entry` 结构，可能一个页放不下，这些 `INODE` 类型的页会组成两种列表：
	- `SEG_INODES_FULL` 链表，该链表中的 `INODE` 类型的页面都已经被 `INODE Entry` 结构填充满了，没空闲空间存放额外的 `INODE Entry` 了。
	- `SEG_INODES_FREE` 链表，该链表中的 `INODE` 类型的页面仍有空闲空间来存放 `INODE Entry` 结构。

###### 5.2.1.5.1.2. XDES Entry

紧接着 `File Space Header` 部分的就是 `XDES Entry` 部分了，`XDES Entry` 就是在表空间的第一个页面中保存的。我们知道一个 `XDES Entry` 结构的大小是 40 字节，但是一个页面的大小有限，只能存放有限个 `XDES Entry` 结构，所以我们才把 256 个区划分成一组，在每组的第一个页面中存放 256 个 `XDES Entry` 结构。大家回看那个 `FSP_HDR` 类型页面的示意图，`XDES Entry 0` 就对应着 `extent 0`，`XDES Entry 1` 就对应着 `extent 1`... 依此类推，`XDES Entry255` 就对应着 `extent 255`。

##### 5.2.1.5.2. XDES 类型页面

在区的数量非常多时，一个单独的页可能就不够存放足够多的 `XDES Entry` 结构，所以我们把表空间的区分为了若干个组，每组开头的一个页面记录着本组内所有的区对应的 `XDES Entry` 结构。

除去第一个分组以外，**之后的每个分组的第一个页面只需要记录本组内所有的区对应的 `XDES Entry` 结构即可，不需要再记录表空间的属性了**，为了和 `FSP_HDR` 类型做区别，我们把之后每个分组的第一个页面的类型定义为 `XDES`，它的结构和 `FSP_HDR` 类型是非常相似：

![](https://varg-my-images.oss-cn-beijing.aliyuncs.com/img/202209070157872.png)

与 `FSP_HDR` 类型的页面对比，除了少了 `File Space Header` 部分之外，也就是除了少了记录表空间整体属性的部分之外，其余的部分是一样的。

##### 5.2.1.5.3. IBUF_BITMAP 类型页面

对比前边介绍表空间的图，每个分组的第二个页面的类型都是 `IBUF_BITMAP`，这种类型的页里边记录了一些有关 `Change Buffer` 的东西。

##### 5.2.1.5.4. INODE 类型页面

###### 5.2.1.5.4.1. INODE 页面结构

再次对比前边介绍表空间的图，第一个分组的第三个页面的类型是 `INODE`。我们前边说过设计 `InnoDB` 的大叔为每个索引定义了两个段，而且为某些特殊功能定义了些特殊的段。为了方便管理，他们又为每个段设计了一个 [[Mysql的存储结构#5 2 1 4 段的结构 INODE Entry|INODE Entry]] 结构，这个结构中记录了关于这个段的相关属性：

![](https://varg-my-images.oss-cn-beijing.aliyuncs.com/img/202209070202642.png)

从图中可以看出，一个 `INODE` 类型的页面是由这几部分构成的：

<table> <thead> <tr> <th> 名称 </th> <th> 中文名 </th> <th> 占用空间大小 </th> <th> 简单描述 </th> </tr> </thead> <tbody> <tr> <td> <code> File Header </code> </td> <td> 文件头部 </td> <td> <code> 38 </code> 字节 </td> <td> 页的一些通用信息 </td> </tr> <tr> <td> <code> List Node for INODE Page List </code> </td> <td> 通用链表节点 </td> <td> <code> 12 </code> 字节 </td> <td> 存储上一个 INODE 页面和下一个 INODE 页面的指针 </td> </tr> <tr> <td> <code> INODE Entry </code> </td> <td> 段描述信息 </td> <td> <code> 16320 </code> 字节 </td> <td> </td> </tr> <tr> <td> <code> Empty Space </code> </td> <td> 尚未使用空间 </td> <td> <code> 6 </code> 字节 </td> <td> 用于页结构的填充，没啥实际意义 </td> </tr> <tr> <td> <code> File Trailer </code> </td> <td> 文件尾部 </td> <td> <code> 8 </code> 字节 </td> <td> 校验页是否完整 </td> </tr> </tbody> </table>

除了 `File Header`、`Empty Space`、`File Trailer` 这几个老朋友外，我们重点关注 `List Node for INODE Page List` 和 `INODE Entry` 这两个部分。

首先看 `INODE Entry` 部分，我们前边已经详细介绍过这个结构的组成了，主要包括对应的段内零散页面的地址以及附属于该段的 `FREE`、`NOT_FULL` 和 `FULL` 链表的基节点。每个 `INODE Entry` 结构占用 192 字节，一个页面里可以存储 `85` 个这样的结构。

重点看一下 `List Node for INODE Page List` ，因为一个表空间中可能存在超过 85 个段，所以可能一个 `INODE` 类型的页面不足以存储所有的段对应的 `INODE Entry` 结构，所以就需要额外的 `INODE` 类型的页面来存储这些结构。还是为了方便管理这些 `INODE` 类型的页面，设计 `InnoDB` 的大叔们将这些 `INODE` 类型的页面串联成两个不同的链表：
- `SEG_INODES_FULL` 链表：该链表中的 `INODE` 类型的页面中已经没有空闲空间来存储额外的 `INODE Entry` 结构了。
- `SEG_INODES_FREE` 链表：该链表中的 `INODE` 类型的页面中还有空闲空间来存储额外的 `INODE Entry` 结构了。

我们前边提到过这两个链表的基节点就存储在 [[Mysql的存储结构#5 2 1 5 1 1 File Space Header|File Space Header]] 里边，也就是说这两个链表的基节点的位置是固定的，所以我们可以很轻松的访问到这两个链表。以后每当我们新创建一个段（创建索引时就会创建段）时，都会创建一个 `INODE Entry` 结构与之对应，存储 `INODE Entry` 的大致过程就是这样的：
- 先判断 `SEG_INODES_FREE` 链表是否为空，如果不为空，直接从该链表中获取一个节点，也就相当于获取到一个仍有空闲空间的 `INODE` 类型的页面，然后把该 `INODE Entry` 结构放到该页面中。当该页面中无剩余空间时，就把该页放到 `SEG_INODES_FULL` 链表中。
- 如果 `SEG_INODES_FREE` 链表为空，则需要从表空间的 `FREE_FRAG` 链表中申请一个页面，修改该页面的类型为 `INODE`，把该页面放到 `SEG_INODES_FREE` 链表中，与此同时把该 `INODE Entry` 结构放入该页面。

###### 5.2.1.5.4.2. 索引关联 INODE 页面

我们知道一个索引会产生两个段，分别是叶子节点段和非叶子节点段，而每个段都会对应一个 `INODE Entry` 结构，那我们怎么知道某个段对应哪个 `INODE Entry` 结构呢？所以得找个地方记下来这个对应关系。在唠叨数据页，也就是 `INDEX` 类型的页时有一个 [[Mysql的存储结构#3 4 Page Header（页面头部）|Page Header]] 部分：

<table> <thead> <tr> <th> 名称 </th> <th> 占用空间大小 </th> <th> 描述 </th> </tr> </thead> <tbody> <tr> <td>... </td> <td>... </td> <td>... </td> </tr> <tr> <td> <code> PAGE_BTR_SEG_LEAF </code> </td> <td> <code> 10 </code> 字节 </td> <td> B + 树叶子段的头部信息，仅在 B + 树的根页定义 </td> </tr> <tr> <td> <code> PAGE_BTR_SEG_TOP </code> </td> <td> <code> 10 </code> 字节 </td> <td> B + 树非叶子段的头部信息，仅在 B + 树的根页定义 </td> </tr> </tbody> </table>

其中的 `PAGE_BTR_SEG_LEAF` 和 `PAGE_BTR_SEG_TOP` 都占用 10 个字节，它们其实对应一个叫 `Segment Header` 的结构，该结构图示如下：

![](https://varg-my-images.oss-cn-beijing.aliyuncs.com/img/202209070209093.png)

各个部分的具体释义如下：

<table> <thead> <tr> <th> 名称 </th> <th> 占用字节数 </th> <th> 描述 </th> </tr> </thead> <tbody> <tr> <td> <code> Space ID of the INODE Entry </code> </td> <td> <code> 4 </code> </td> <td> INODE Entry 结构所在的表空间 ID </td> </tr> <tr> <td> <code> Page Number of the INODE Entry </code> </td> <td> <code> 4 </code> </td> <td> INODE Entry 结构所在的页面页号 </td> </tr> <tr> <td> <code> Byte Offset of the INODE Ent </code> </td> <td> <code> 2 </code> </td> <td> INODE Entry 结构在该页面中的偏移量 </td> </tr> </tbody> </table>

这样子就很清晰了，`PAGE_BTR_SEG_LEAF` 记录着叶子节点段对应的 `INODE Entry` 结构的地址是哪个表空间的哪个页面的哪个偏移量，`PAGE_BTR_SEG_TOP` 记录着非叶子节点段对应的 `INODE Entry` 结构的地址是哪个表空间的哪个页面的哪个偏移量。这样子索引和其对应的段的关系就建立起来了。不过需要注意的一点是，因为**一个索引只对应两个段，所以只需要在索引的根页面中记录这两个结构即可**。

### 5.2.2. 系统表空间

系统表空间的结构和独立表空间基本类似，只不过由于整个 MySQL 进程只有一个系统表空间，在系统表空间中会额外记录一些有关整个系统信息的页面，所以会比独立表空间多出一些记录这些信息的页面。因为这个系统表空间最牛逼，相当于是表空间之首，所以它的 `表空间 ID`（Space ID）是 `0`。

#### 5.2.2.1. 系统表空间整体结构

系统表空间与独立表空间的一个非常明显的不同之处就是在表空间开头有许多记录整个系统属性的页面：

![](https://varg-my-images.oss-cn-beijing.aliyuncs.com/img/202209070215271.png)

可以看到，系统表空间和独立表空间的前三个页面（页号分别为 `0`、`1`、`2`，类型分别是 `FSP_HDR`、`IBUF_BITMAP`、`INODE`）的类型是一致的，只是页号为 `3` ～ `7` 的页面是系统表空间特有的：

<table> <thead> <tr> <th> 页号 </th> <th> 页面类型 </th> <th> 英文描述 </th> <th> 描述 </th> </tr> </thead> <tbody> <tr> <td> <code> 3 </code> </td> <td> <code> SYS </code> </td> <td> Insert Buffer Header </td> <td> 存储 Insert Buffer 的头部信息 </td> </tr> <tr> <td> <code> 4 </code> </td> <td> <code> INDEX </code> </td> <td> Insert Buffer Root </td> <td> 存储 Insert Buffer 的根页面 </td> </tr> <tr> <td> <code> 5 </code> </td> <td> <code> TRX_SYS </code> </td> <td> Transction System </td> <td> 事务系统的相关信息 </td> </tr> <tr> <td> <code> 6 </code> </td> <td> <code> SYS </code> </td> <td> First Rollback Segment </td> <td> 第一个回滚段的页面 </td> </tr> <tr> <td> <code> 7 </code> </td> <td> <code> SYS </code> </td> <td> Data Dictionary Header </td> <td> 数据字典头部信息 </td> </tr> </tbody> </table>

除了这几个记录系统属性的页面之外，系统表空间的 `extent 1` 和 `extent 2` 这两个区，也就是页号从 `64` ~ `191` 这 128 个页面被称为 `Doublewrite buffer`，也就是双写缓冲区。不过上述的大部分知识都涉及到了事务和多版本控制的问题。

#### 5.2.2.2. InnoDB 数据字典

MySQL 除了保存着我们插入的用户数据之外，还需要保存许多额外的信息，比方说：
- 某个表属于哪个表空间，表里边有多少列。
- 表对应的每一个列的类型是什么。
- 该表有多少索引，每个索引对应哪几个字段，该索引对应的根页面在哪个表空间的哪个页面。
- 该表有哪些外键，外键对应哪个表的哪些列。
- 某个表空间对应文件系统上文件路径是什么。

上述这些数据并不是我们使用 `INSERT` 语句插入的用户数据，实际上是为了更好的管理我们这些用户数据而不得已引入的一些额外数据，这些数据也称为 `元数据`。InnoDB 存储引擎特意定义了一些列的内部系统表（internal system table）来记录这些这些 `元数据` ：

<table> <thead> <tr> <th> 表名 </th> <th> 描述 </th> </tr> </thead> <tbody> <tr> <td> <code> SYS_TABLES </code> </td> <td> 整个 InnoDB 存储引擎中所有的表的信息 </td> </tr> <tr> <td> <code> SYS_COLUMNS </code> </td> <td> 整个 InnoDB 存储引擎中所有的列的信息 </td> </tr> <tr> <td> <code> SYS_INDEXES </code> </td> <td> 整个 InnoDB 存储引擎中所有的索引的信息 </td> </tr> <tr> <td> <code> SYS_FIELDS </code> </td> <td> 整个 InnoDB 存储引擎中所有的索引对应的列的信息 </td> </tr> <tr> <td> <code> SYS_FOREIGN </code> </td> <td> 整个 InnoDB 存储引擎中所有的外键的信息 </td> </tr> <tr> <td> <code> SYS_FOREIGN_COLS </code> </td> <td> 整个 InnoDB 存储引擎中所有的外键对应列的信息 </td> </tr> <tr> <td> <code> SYS_TABLESPACES </code> </td> <td> 整个 InnoDB 存储引擎中所有的表空间信息 </td> </tr> <tr> <td> <code> SYS_DATAFILES </code> </td> <td> 整个 InnoDB 存储引擎中所有的表空间对应文件系统的文件路径信息 </td> </tr> <tr> <td> <code> SYS_VIRTUAL </code> </td> <td> 整个 InnoDB 存储引擎中所有的虚拟生成列的信息 </td> </tr> </tbody> </table>

这些系统表也被称为 `数据字典`，它们都是以 `B+` 树的形式保存在系统表空间的某些页面中，其中 `SYS_TABLES`、`SYS_COLUMNS`、`SYS_INDEXES`、`SYS_FIELDS` 这四个表尤其重要，称之为基本系统表（basic system tables），我们先看看这 4 个表的结构。

##### 5.2.2.2.1. SYS_TABLES 表

<table> <thead> <tr> <th> 列名 </th> <th> 描述 </th> </tr> </thead> <tbody> <tr> <td> <code> NAME </code> </td> <td> 表的名称 </td> </tr> <tr> <td> <code> ID </code> </td> <td> InnoDB 存储引擎中每个表都有一个唯一的 ID </td> </tr> <tr> <td> <code> N_COLS </code> </td> <td> 该表拥有列的个数 </td> </tr> <tr> <td> <code> TYPE </code> </td> <td> 表的类型，记录了一些文件格式、行格式、压缩等信息 </td> </tr> <tr> <td> <code> MIX_ID </code> </td> <td> 已过时，忽略 </td> </tr> <tr> <td> <code> MIX_LEN </code> </td> <td> 表的一些额外的属性 </td> </tr> <tr> <td> <code> CLUSTER_ID </code> </td> <td> 未使用，忽略 </td> </tr> <tr> <td> <code> SPACE </code> </td> <td> 该表所属表空间的 ID </td> </tr> </tbody> </table>

这个 `SYS_TABLES` 表有两个索引：
- 以 `NAME` 列为主键的聚簇索引
- 以 `ID` 列建立的二级索引

##### 5.2.2.2.2. SYS_COLUMNS 表

<table> <thead> <tr> <th> 列名 </th> <th> 描述 </th> </tr> </thead> <tbody> <tr> <td> <code> TABLE_ID </code> </td> <td> 该列所属表对应的 ID </td> </tr> <tr> <td> <code> POS </code> </td> <td> 该列在表中是第几列 </td> </tr> <tr> <td> <code> NAME </code> </td> <td> 该列的名称 </td> </tr> <tr> <td> <code> MTYPE </code> </td> <td> main data type，主数据类型，就是那堆 INT、CHAR、VARCHAR、FLOAT、DOUBLE 之类的东东 </td> </tr> <tr> <td> <code> PRTYPE </code> </td> <td> precise type，精确数据类型，就是修饰主数据类型的那堆东东，比如是否允许 NULL 值，是否允许负数啥的 </td> </tr> <tr> <td> <code> LEN </code> </td> <td> 该列最多占用存储空间的字节数 </td> </tr> <tr> <td> <code> PREC </code> </td> <td> 该列的精度，不过这列貌似都没有使用，默认值都是 0 </td> </tr> </tbody> </table>

这个 `SYS_COLUMNS` 表只有一个聚集索引：以 `(TABLE_ID, POS)` 列为主键的聚簇索引。

##### 5.2.2.2.3. SYS_INDEXES 表

<table> <thead> <tr> <th> 列名 </th> <th> 描述 </th> </tr> </thead> <tbody> <tr> <td> <code> TABLE_ID </code> </td> <td> 该索引所属表对应的 ID </td> </tr> <tr> <td> <code> ID </code> </td> <td> InnoDB 存储引擎中每个索引都有一个唯一的 ID </td> </tr> <tr> <td> <code> NAME </code> </td> <td> 该索引的名称 </td> </tr> <tr> <td> <code> N_FIELDS </code> </td> <td> 该索引包含列的个数 </td> </tr> <tr> <td> <code> TYPE </code> </td> <td> 该索引的类型，比如聚簇索引、唯一索引、更改缓冲区的索引、全文索引、普通的二级索引等等各种类型 </td> </tr> <tr> <td> <code> SPACE </code> </td> <td> 该索引根页面所在的表空间 ID </td> </tr> <tr> <td> <code> PAGE_NO </code> </td> <td> 该索引根页面所在的页面号 </td> </tr> <tr> <td> <code> MERGE_THRESHOLD </code> </td> <td> 如果页面中的记录被删除到某个比例，就把该页面和相邻页面合并，这个值就是这个比例 </td> </tr> </tbody> </table>

这个 `SYS_INDEXES` 表只有一个聚集索引：以 `(TABLE_ID, ID)` 列为主键的聚簇索引。

##### 5.2.2.2.4. SYS_FIELDS 表

<table> <thead> <tr> <th> 列名 </th> <th> 描述 </th> </tr> </thead> <tbody> <tr> <td> <code> INDEX_ID </code> </td> <td> 该索引列所属的索引的 ID </td> </tr> <tr> <td> <code> POS </code> </td> <td> 该索引列在某个索引中是第几列 </td> </tr> <tr> <td> <code> COL_NAME </code> </td> <td> 该索引列的名称 </td> </tr> </tbody> </table>

这个 `SYS_FIELDS` 表只有一个聚集索引：以 `(INDEX_ID, POS)` 列为主键的聚簇索引。

#### 5.2.2.3. Data Dictionary Header 页面

有了上述 4 个基本系统表，也就意味着可以获取其他系统表以及用户定义的表的所有元数据。比方说我们想看看 `SYS_TABLESPACES` 这个系统表里存储了哪些表空间以及表空间对应的属性，那就可以：

- 到 `SYS_TABLES` 表中根据表名定位到具体的记录，就可以获取到 `SYS_TABLESPACES` 表的 `TABLE_ID`
- 使用这个 `TABLE_ID` 到 `SYS_COLUMNS` 表中就可以获取到属于该表的所有列的信息。
- 使用这个 `TABLE_ID` 还可以到 `SYS_INDEXES` 表中获取所有的索引的信息，索引的信息中包括对应的 `INDEX_ID`，还记录着该索引对应的 `B+` 数根页面是哪个表空间的哪个页面。
- 使用 `INDEX_ID` 就可以到 `SYS_FIELDS` 表中获取所有索引列的信息。

也就是说这 4 个表是表中之表，那这 4 个表的元数据去哪里获取呢？没法搞了，**只能把这 4 个表的元数据，就是它们有哪些列、哪些索引等信息硬编码到代码中**，然后设计 `InnoDB` 的大叔又**拿出一个固定的页面来记录这 4 个表的聚簇索引和二级索引对应的 `B+树` 位置**，这个页面就是页号为 `7` 的页面，类型为 `SYS`，记录了 `Data Dictionary Header`，也就是数据字典的头部信息。除了这 4 个表的 5 个索引的根页面信息外，这个页号为 `7` 的页面还记录了整个 InnoDB 存储引擎的一些全局属性：

![](https://varg-my-images.oss-cn-beijing.aliyuncs.com/img/202209070221126.png)

可以看到这个页面由下边几个部分组成：

<table> <thead> <tr> <th> 名称 </th> <th> 中文名 </th> <th> 占用空间大小 </th> <th> 简单描述 </th> </tr> </thead> <tbody> <tr> <td> <code> File Header </code> </td> <td> 文件头部 </td> <td> <code> 38 </code> 字节 </td> <td> 页的一些通用信息 </td> </tr> <tr> <td> <code> Data Dictionary Header </code> </td> <td> 数据字典头部信息 </td> <td> <code> 56 </code> 字节 </td> <td> 记录一些基本系统表的根页面位置以及 InnoDB 存储引擎的一些全局信息 </td> </tr> <tr> <td> <code> Segment Header </code> </td> <td> 段头部信息 </td> <td> <code> 10 </code> 字节 </td> <td> 记录本页面所在段对应的 INODE Entry 位置信息 </td> </tr> <tr> <td> <code> Empty Space </code> </td> <td> 尚未使用空间 </td> <td> <code> 16272 </code> 字节 </td> <td> 用于页结构的填充，没啥实际意义 </td> </tr> <tr> <td> <code> File Trailer </code> </td> <td> 文件尾部 </td> <td> <code> 8 </code> 字节 </td> <td> 校验页是否完整 </td> </tr> </tbody> </table>

可以看到这个页面里竟然有 `Segment Header` 部分，意味着设计 InnoDB 的大叔把这些有关数据字典的信息当成一个段来分配存储空间，我们就姑且称之为 `数据字典段` 吧。由于目前我们需要记录的数据字典信息非常少（可以看到 `Data Dictionary Header` 部分仅占用了 56 字节），所以该段只有一个碎片页，也就是页号为 `7` 的这个页。

接下来我们需要细细唠叨一下 `Data Dictionary Header` 部分的各个字段：

- `Max Row ID`
	我们说过如果我们不显式的为表定义主键，而且表中也没有 `UNIQUE` 索引，那么 `InnoDB` 存储引擎会默认为我们生成一个名为 `row_id` 的列作为主键。因为它是主键，所以每条记录的 `row_id` 列的值不能重复。原则上只要一个表中的 `row_id` 列不重复就可以了，也就是说表 a 和表 b 拥有一样的 `row_id` 列也没啥关系，不过设计 InnoDB 的大叔只提供了这个 `Max Row ID` 字段，不论哪个拥有 `row_id` 列的表插入一条记录时，该记录的 `row_id` 列的值就是 `Max Row ID` 对应的值，然后再把 `Max Row ID` 对应的值加 1，**也就是说这个 `Max Row ID` 是全局共享的**。
- `Max Table ID`
	InnoDB 存储引擎中的所有的表都对应一个唯一的 ID，每次新建一个表时，就会把本字段的值作为该表的 ID，然后自增本字段的值。
-   `Max Index ID`
	InnoDB 存储引擎中的所有的索引都对应一个唯一的 ID，每次新建一个索引时，就会把本字段的值作为该索引的 ID，然后自增本字段的值。
-   `Max Space ID`
	InnoDB 存储引擎中的所有的表空间都对应一个唯一的 ID，每次新建一个表空间时，就会把本字段的值作为该表空间的 ID，然后自增本字段的值。
-   `Mix ID Low(Unused)`
	暂时未使用。
-   `Root of SYS_TABLES clust index`
	本字段代表 `SYS_TABLES` 表聚簇索引的根页面的页号。
-   `Root of SYS_TABLE_IDS sec index`
	本字段代表 `SYS_TABLES` 表为 `ID` 列建立的二级索引的根页面的页号。
-   `Root of SYS_COLUMNS clust index`
	本字段代表 `SYS_COLUMNS` 表聚簇索引的根页面的页号。
-   `Root of SYS_INDEXES clust index`
	本字段代表 `SYS_INDEXES` 表聚簇索引的根页面的页号。
-   `Root of SYS_FIELDS clust index`
	本字段代表 `SYS_FIELDS` 表聚簇索引的根页面的页号。
-   `Unused`
	暂时未使用。

#### 5.2.2.4. information_schema 系统数据库

需要注意一点的是，用户是不能直接访问 `InnoDB` 的这些内部系统表的，除非你直接去解析系统表空间对应文件系统上的文件。不过设计 InnoDB 的大叔考虑到查看这些表的内容可能有助于大家分析问题，所以在系统数据库 `information_schema` 中提供了一些以 `innodb_sys` 开头的表：

```sql

mysql> USE information_schema;
Database changed

mysql> SHOW TABLES LIKE 'innodb_sys%';
+--------------------------------------------+
| Tables_in_information_schema (innodb_sys%) |
+--------------------------------------------+
| INNODB_SYS_DATAFILES                       |
| INNODB_SYS_VIRTUAL                         |
| INNODB_SYS_INDEXES                         |
| INNODB_SYS_TABLES                          |
| INNODB_SYS_FIELDS                          |
| INNODB_SYS_TABLESPACES                     |
| INNODB_SYS_FOREIGN_COLS                    |
| INNODB_SYS_COLUMNS                         |
| INNODB_SYS_FOREIGN                         |
| INNODB_SYS_TABLESTATS                      |
+--------------------------------------------+
10 rows in set (0.00 sec)

```

在 `information_schema` 数据库中的这些以 `INNODB_SYS` 开头的表并不是真正的内部系统表（内部系统表就是我们上边唠叨的以 `SYS` 开头的那些表），而是在存储引擎启动时读取这些以 `SYS` 开头的系统表，然后填充到这些以 `INNODB_SYS` 开头的表中。以 `INNODB_SYS` 开头的表和以 `SYS` 开头的表中的字段并不完全一样，但供大家参考已经足矣。

# 6. Mysql 的缓冲区（Buffer Pool）


为了处理磁盘与内存及 CPU 之间的速度差异，Mysql 会建立一个缓冲区，称之为 `Buffer Pool`。当需要访问某个页的数据时，就会把完整的页的数据全部加载到内存中，然后就可以进行读写访问了，在进行完读写访问之后并不着急把该页对应的内存空间释放掉，而是将其 `缓存` 起来，这样将来有请求再次访问该页面时，就可以省去磁盘 `IO` 的开销了。

`Buffer Pool` 在 Mysql 启动的时候就会申请建立，其默认大小为 128M，可以通过 `innodb_buffer_pool_size` 进行配置。

## 6.1. Buffer Pool 的组织结构

`Buffer Pool` 中默认的缓存页大小和在磁盘上默认的页大小是一样的，都是 `16KB`。为了更好的管理这些在 `Buffer Pool` 中的缓存页，Mysql 为每一个缓存页都创建了一些所谓的 `控制信息`，这些控制信息包括该**页所属的表空间编号、页号、缓存页在 `Buffer Pool` 中的地址、链表节点信息、一些锁信息以及 [[Mysql的一致性保证#1 5 Log Sequence Number|LSN]] 信息等**。

每个缓存页对应的控制信息占用的内存大小是相同的，称为 `控制块`，控制块和缓存页是一一对应的，它们都被存放到 Buffer Pool 中，其中控制块被存放到 Buffer Pool 的前边，缓存页被存放到 Buffer Pool 后边，所以整个 `Buffer Pool` 对应的内存空间看起来就是这样的：

![](https://varg-my-images.oss-cn-beijing.aliyuncs.com/img/202209182249282.png)

控制块与缓存页分配后，剩余不足的空间会变成碎片。当然，如果 `Buffer Pool` 的大小设置的刚刚好的话，也可能不会产生 `碎片`。

每个控制块大约占用缓存页大小的 5%，而我们设置的 innodb_buffer_pool_size 并不包含这部分控制块占用的内存空间大小，也就是说 InnoDB 在为 Buffer Pool 向操作系统申请连续的内存空间时，这片连续的内存空间一般会比 innodb_buffer_pool_size 的值大 5%左右。

### 6.1.1. free 链表的管理

为了区分 `Buffer Pool` 中哪些缓存页是空闲的，哪些已经被使用了的，即为了记录 Buffer Pool 中哪些缓存页是可用的，我们可以把所有空闲的缓存页对应的控制块作为一个节点放到一个链表中，这个链表也可以被称作 `free链表`（或者说空闲链表）。

刚刚完成初始化的 `Buffer Pool` 中所有的缓存页都是空闲的，所以每一个缓存页对应的控制块都会被加入到 `free链表` 中，假设该 `Buffer Pool` 中可容纳的缓存页数量为 `n`，那增加了 `free链表` 的效果图就是这样的：

![](https://varg-my-images.oss-cn-beijing.aliyuncs.com/img/202209182253199.png)

为了管理好这个 `free链表`，特意为这个链表定义了一个 `基节点`，里边儿包含着链表的头节点地址，尾节点地址，以及当前链表中节点的数量等信息。这里需要注意的是，**链表的基节点占用的内存空间并不包含在为 `Buffer Pool` 申请的一大片连续内存空间之内，而是单独申请的一块内存空间**。

此后每当需要从磁盘中加载一个页到 `Buffer Pool` 中时，就从 `free链表` 中取一个空闲的缓存页，并且把该缓存页对应的 `控制块` 的信息填上（就是该页所在的表空间、页号之类的信息），然后把该缓存页对应的 `free链表` 节点从链表中移除，表示该缓存页已经被使用了。

### 6.1.2. 缓存页的哈希处理

为了判断某个页面是否被加入到了缓冲区，我们可以**用 `表空间号 + 页号` 作为 `key`，`缓存页` 作为 `value` 创建一个哈希表**。在需要访问某个页的数据时，先从哈希表中根据 `表空间号 + 页号` 看看有没有对应的缓存页：如果有，直接使用该缓存页就好；如果没有，那就从 `free链表` 中选一个空闲的缓存页，然后把磁盘中对应的页加载到该缓存页的位置。

### 6.1.3. flush 链表的管理

修改了 `Buffer Pool` 中某个缓存页的数据后它就和磁盘上的页变得不一致了，这样的缓存页也被称为脏页（dirty page）。因为**磁盘的交互速度太慢了，所以脏页并不会立马刷新到磁盘上，而是在未来的某个时间点进行同步**。

为了记录这些被修改过而未刷新到磁盘上的脏页，Mysql 设计了一个 `flush链表`，链表的构造和 `free链表` 差不多，假设某个时间点 `Buffer Pool` 中的脏页数量为 `n`，那么对应的 `flush链表` 就长这样：

![](https://varg-my-images.oss-cn-beijing.aliyuncs.com/img/202209182312152.png)

### 6.1.4. LRU 链表的管理

缓冲区的空间总是有限的，为了提高缓存命中率，所以我们不得不将一些缓存页移出缓冲区。为了实现这一功能，Mysql 使用了 LRU 链表。

#### 6.1.4.1. 划分区域的 LRU 链表

传统的 LRU 链表将新读取的页面放到链表的头部，淘汰时淘汰链表的尾部，这对于 Mysql 来说存在一些问题：

- Mysql 的预读
	`InnoDB` 提供了一个看起来比较贴心的服务—— `预读`（英文名：`read ahead`）。所谓 `预读`，就是 `InnoDB` 认为执行当前的请求可能之后会读取某些页面，就预先把它们加载到 `Buffer Pool` 中。根据触发方式的不同，`预读` 又可以细分为下边两种：
	- 线性预读
		设计 `InnoDB` 的大叔提供了一个系统变量 `innodb_read_ahead_threshold`，**如果顺序访问了某个[[Mysql的存储结构#5 2 1 1 区（exient）的概述|区]]（`extent`）的页面超过这个系统变量的值，就会触发一次 `异步` 读取下一个区中全部的页面到 `Buffer Pool`** 的请求，注意 `异步` 读取意味着从磁盘中加载这些被预读的页面并不会影响到当前工作线程的正常执行。
	- 随机预读
		如果 `Buffer Pool` 中已经缓存了某个[[Mysql的存储结构#5 2 1 1 区（exient）的概述|区]]的 13 个连续的页面（这 13 个页面需要在 [[Mysql的存储结构#6 1 4 2 LRU 链表的进一步优化|LRU链表的前1/4页面]]），不论这些页面是不是顺序读取的，都会触发一次 `异步` 读取本区中所有其的页面到 `Buffer Pool` 的请求。该功能由 `innodb_random_read_ahead` 系统变量控制，它的默认值为 `OFF`。

	`预读` 本来是个好事儿，如果预读到 `Buffer Pool` 中的页成功的被使用到，那就可以极大的提高语句执行的效率。可是如果用不到呢？这些预读的页都会放到 `LRU` 链表的头部，但是如果此时 `Buffer Pool` 的容量不太大而且很多预读的页面都没有用到的话，这就会导致处在 `LRU链表` 尾部的一些缓存页会很快的被淘汰掉，也就是所谓的 `劣币驱逐良币`，会大大降低缓存命中率。
	
- Mysql 的大批量读取
	有时候我们会进行大量数据的查询，如某些表的全表扫描。这意味着将访问到该表所在的所有页！假设这个表中记录非常多的话，那该表会占用特别多的 `页`，当需要访问这些页时，会把它们统统都加载到 `Buffer Pool` 中，所以原缓冲区中的页将被置换。

为了避免上述情况，Mysql 把这个 `LRU链表` 按照一定比例分成两截，分别是：
- 一部分存储使用频率非常高的缓存页，所以这一部分链表也叫做 `热数据`，或者称 `young区域`。
- 一部分存储使用频率不是很高的缓存页，所以这一部分链表也叫做 `冷数据`，或者称 `old区域`。

![](https://varg-my-images.oss-cn-beijing.aliyuncs.com/img/202209182321578.png)

默认情况下，`old` 区域在 `LRU链表` 中所占的比例是 `37%`，也就是说 `old` 区域大约占 `LRU链表` 的 `3/8`。这个比例我们是可以设置的，我们可以在启动时修改 `innodb_old_blocks_pct` 参数来控制 `old` 区域在 `LRU链表` 中所占的比例。

有了这个被划分成 `young` 和 `old` 区域的 `LRU` 链表之后，Mysql 就可以针对我们上边提到的两种可能降低缓存命中率的情况进行优化了：

- 针对预读的页面可能不进行后续访问情况的优化
    当磁盘上的某个页面在初次加载到 Buffer Pool 中的某个缓存页时，该缓存页对应的控制块会被放到 old 区域的头部。这样针对预读到 `Buffer Pool` 却不进行后续访问的页面就会被逐渐从 `old` 区域逐出，而不会影响 `young` 区域中被使用比较频繁的缓存页。
- 针对全表扫描时，短时间内访问大量使用频率非常低的页面情况的优化
    全表扫描有一个特点，那就是它的执行频率非常低，而且在执行全表扫描的过程中，即使某个页面中有很多条记录，也就是去多次访问这个页面所花费的时间也是非常少的。所以 Mysql 规定，在对某个处在 `old` 区域的缓存页进行第一次访问时就在它对应的控制块中记录下来这个访问时间，**如果后续的访问时间与第一次访问的时间在某个时间间隔内，那么该页面就不会被从 old 区域移动到 young 区域的头部**，否则将它移动到 young 区域的头部。上述的这个[[Redis大纲#6 2 2 Redis-LRU 算法的实现|时间控制]]由系统变量 `innodb_old_blocks_time` 控制。

综上所述，正是因为将 `LRU` 链表划分为 `young` 和 `old` 区域这两个部分，又添加了 `innodb_old_blocks_time` 这个系统变量，才使得预读机制和全表扫描造成的缓存命中率降低的问题得到了遏制，因为用不到的预读页面以及全表扫描的页面都只会被放到 `old` 区域，而不影响 `young` 区域中的缓存页。

#### 6.1.4.2. LRU 链表的进一步优化

对于 `young` 区域的缓存页来说，我们每次访问一个缓存页就要把它移动到 `LRU链表` 的头部，这样开销会显得很大，毕竟在 `young` 区域的缓存页都是热点数据，也就是可能被经常访问的。

为了解决这个问题其实我们还可以提出一些优化策略，比如只有被访问的缓存页位于 `young` 区域的 `1/4` 的后边，才会被移动到 `LRU链表` 头部，这样就可以降低调整 `LRU链表` 的频率，从而提升性能（也就是说如果某个缓存页对应的节点在 `young` 区域的 `1/4` 中，再次访问该缓存页时也不会将其移动到 `LRU` 链表头部）。

当然除此之外 Mysql 进行了非常多的优化，此处就不再介绍了。

### 6.1.5. 刷新脏页到磁盘

后台有专门的线程每隔一段时间负责把脏页刷新到磁盘，这样可以不影响用户线程处理正常的请求。主要有两种刷新路径：

- 从 `LRU链表` 的冷数据中刷新一部分页面到磁盘。
    后台线程会定时从 `LRU链表` 尾部开始扫描一些页面，扫描的页面数量可以通过系统变量 `innodb_lru_scan_depth` 来指定，如果从里边儿发现脏页，会把它们刷新到磁盘。这种刷新页面的方式被称之为 `BUF_FLUSH_LRU`。
- 从 `flush链表` 中刷新一部分页面到磁盘。
    后台线程也会定时从 `flush链表` 中刷新一部分页面到磁盘，刷新的速率取决于当时系统是不是很繁忙。这种刷新页面的方式被称之为 `BUF_FLUSH_LIST`。

有时候后台线程刷新脏页的进度比较慢，导致用户线程在准备加载一个磁盘页到 `Buffer Pool` 时没有可用的缓存页，这时就会尝试看看 `LRU链表` 尾部有没有可以直接释放掉的未修改页面，如果没有的话会不得不将 `LRU链表` 尾部的一个脏页同步刷新到磁盘（和磁盘交互是很慢的，这会降低处理用户请求的速度）。这种刷新单个页面到磁盘中的刷新方式被称之为 `BUF_FLUSH_SINGLE_PAGE`。

当然，有时候系统特别繁忙时，也可能出现用户线程批量的从 `flush链表` 中刷新脏页的情况，很显然在处理用户请求过程中去刷新脏页是一种严重降低处理速度的行为（毕竟磁盘的速度慢的要死），这属于一种迫不得已的情况。

## 6.2. Buffer Pool 的配置

### 6.2.1. 多个 Buffer Pool 实例

`Buffer Pool` 本质是 `InnoDB` 向操作系统申请的一块连续的内存空间，**在多线程环境下，访问 `Buffer Pool` 中的各种链表都需要加锁处理等操作，在 `Buffer Pool` 特别大而且多线程并发访问特别高的情况下，单一的 `Buffer Pool` 可能会影响请求的处理速度**。

所以在 `Buffer Pool` 特别大的时候，我们可以把它们拆分成若干个小的 `Buffer Pool`，每个 `Buffer Pool` 都称为一个 `实例`，它们都是独立的，独立的去申请内存空间，独立的管理各种链表，所以在多线程并发访问时并不会相互影响，从而提高并发处理能力。我们可以在服务器启动的时候通过设置 `innodb_buffer_pool_instances` 的值来修改 `Buffer Pool` 实例的个数，如以下的配置：

![](https://varg-my-images.oss-cn-beijing.aliyuncs.com/img/202209182338137.png)

### 6.2.2. innodb_buffer_pool_chunk_size

在 `MySQL 5.7.5` 之前，`Buffer Pool` 的大小只能在服务器启动时通过配置 `innodb_buffer_pool_size` 启动参数来调整大小，在服务器运行过程中是不允许调整该值的。

`MySQL` 的在 `5.7.5` 以及之后的版本中支持了在服务器运行过程中调整 `Buffer Pool` 大小的功能，但是有一个问题，就是每次当我们要重新调整 `Buffer Pool` 大小时，都需要重新向操作系统申请一块连续的内存空间，然后将旧的 `Buffer Pool` 中的内容复制到这一块新空间，这是极其耗时的。所以 `MySQL` 决定不再一次性为某个 `Buffer Pool` 实例向操作系统申请一大片连续的内存空间，而是以一个所谓的 `chunk` 为单位向操作系统申请空间。也就是说一个 `Buffer Pool` 实例其实是由若干个 `chunk` 组成的，一个 `chunk` 就代表一片连续的内存空间，里边儿包含了若干缓存页与其对应的控制块：

![](https://varg-my-images.oss-cn-beijing.aliyuncs.com/img/202209182339908.png)

上图代表的 `Buffer Pool` 就是由 2 个实例组成的，每个实例中又包含 2 个 `chunk`。

正是因为发明了这个 `chunk` 的概念，我们在服务器运行期间调整 `Buffer Pool` 的大小时就是以 `chunk` 为单位增加或者删除内存空间，而不需要重新向操作系统申请一片大的内存，然后进行缓存页的复制。`chunk` 的大小是我们在启动操作 `MySQL` 服务器时通过 `innodb_buffer_pool_chunk_size` 启动参数指定的，它的默认值是 `134217728`，也就是 `128M`。不过需要注意的是，innodb_buffer_pool_chunk_size 的值只能在服务器启动时指定，在服务器运行过程中是不可以修改的。

需要注意的是，`innodb_buffer_pool_size` 必须是 `innodb_buffer_pool_chunk_size × innodb_buffer_pool_instances` 的倍数（这主要是想保证每一个 `Buffer Pool` 实例中包含的 `chunk` 数量相同）。

## 6.3. Buffer Pool 信息的查看

我们可以通过 `SHOW ENGINE INNODB STATUS` 语句来查看关于 `InnoDB` 存储引擎运行过程中的一些状态信息，其中就包括 `Buffer Pool` 的一些信息：

```sql
mysql> SHOW ENGINE INNODB STATUS\G

(...省略前边的许多状态)
----------------------
BUFFER POOL AND MEMORY
----------------------
Total memory allocated 13218349056;
Dictionary memory allocated 4014231
Buffer pool size   786432
Free buffers       8174
Database pages     710576
Old database pages 262143
Modified db pages  124941
Pending reads 0
Pending writes: LRU 0, flush list 0, single page 0
Pages made young 6195930012, not young 78247510485
108.18 youngs/s, 226.15 non-youngs/s
Pages read 2748866728, created 29217873, written 4845680877
160.77 reads/s, 3.80 creates/s, 190.16 writes/s
Buffer pool hit rate 956 / 1000, young-making rate 30 / 1000 not 605 / 1000
Pages read ahead 0.00/s, evicted without access 0.00/s, Random read ahead 0.00/s
LRU len: 710576, unzip_LRU len: 118
I/O sum[134264]:cur[144], unzip sum[16]:cur[0]
--------------
(...省略后边的许多状态)

mysql>
```

## 6.4. ChangeBuffer 的使用

`ChangeBuffer` 仅对普通索引生效。对于产生的 `ChangeBuffer` 数据，当数据被读取时，会从磁盘中加载然后与 `ChangeBuffer` 合并，从而产生最新的数据。后台也会定时刷新 `ChangerBuffer` 到缓存中。这个过程称为 `ChangeBuffer` 的 `Merge`。对于写后立即读的场景，使用 `ChangeBuffer` 会带来一定负担，所以如果数据库中所有表更新操作都会立即读取最新数据，那么关闭该功能反而会有不错的效果。

在 `ChangeBuffer` 产生后，就会将 `ChangeBuffer` 相关的操作写入 `redolog` 而后写入磁盘，因此无需担心 `ChangeBuffer` 丢失后造成的数据一致性问题。**`redolog` 主要节省的是随机写磁盘的 IO 消耗 (转成顺序写)，而 `ChangeBuffer` 主要节省的则是随机读磁盘的 IO 消耗**。

![](https://varg-my-images.oss-cn-beijing.aliyuncs.com/img/20220511222449.png)
