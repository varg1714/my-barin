#数据库
> 本文由 [简悦 SimpRead](http://ksria.com/simpread/) 转码， 原文地址 [blog.csdn.net](https://blog.csdn.net/weixin_39651041/article/details/79985715)

**锁**是网络数据库中的一个非常重要的概念，当多个用户同时对数据库并发操作时，会带来数据不一致的问题，所以，锁主要用于多用户环境下保证数据库完整性和一致性。

## 锁分类
---

从数据库系统角度分为两种：排他锁、共享锁。  
　　共享锁和排它锁是具体的锁，是数据库机制上的锁，存在以下关系：

　　![](https://r2.129870.xyz/img/20210406220218.png)

（x 表示是排它锁 (Exclusive)，s 表示共享锁 (Share)，Y 表示 yes，N 表示 no）

### 悲观锁（Pessimistic Lock）

顾名思义，很悲观，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人拿这个数据就会 block（阻塞），直到它拿锁。

> 悲观锁（Pessimistic Lock）：正如其名，具有强烈的独占和排他特性。它指的是对数据被外界（包括本系统当前的其他事务，以及来自外部系统的事务处理）修改持保守态度，因此，在整个数据处理过程中，将数据处于锁定状态。悲观锁的实现，往往依靠数据库提供的锁机制（也只有数据库层提供的锁机制才能真正保证数据访问的排他性，否则，即使在本系统中实现了加锁机制，也无法保证外部系统不会修改数据）。

传统的关系数据库里用到了很多这种锁机制，比如行锁、表锁、读锁、写锁等，都是在操作之前先上锁。

#### 悲观锁按使用性质划分

##### 共享锁（Share Lock）

S 锁，也叫读锁，用于所有的只读数据操作。共享锁是非独占的，允许多个并发事务读取其锁定的资源。  
以下sql将会触发共享锁：
```sql
select * from t in share mode;
```
**性质**  
1. 多个事务可封锁同一个共享页；  
2. 任何事务都不能修改该页；  
3. 通常是该页被读取完毕，S 锁立即被释放。

> 在 SQL Server 中，默认情况下，数据被读取后，立即释放共享锁。  
> 例如，执行查询语句 “select * from my_table” 时，首先锁定第一页，读取之后，释放对第一页的锁定，然后锁定第二页。这样，就允许在读操作过程中，修改未被锁定的第一页。  
> 例如，语句 “SELECT * FROM my_table `HOLDLOCK`” 就要求在整个查询过程中，保持对表的锁定，直到查询完成才释放锁定。

##### 排他锁（Exclusive Lock）

X 锁，也叫写锁，表示对数据进行写操作。如果一个事务对对象加了排他锁，其他事务就不能再给它加任何锁了。（某个顾客把试衣间从里面反锁了，其他顾客想要使用这个试衣间，就只有等待锁从里面打开了。）  
**性质**  
1. 仅允许一个事务封锁此页；  
2. 其他任何事务必须等到 X 锁被释放才能对该页进行访问；  
3. X 锁一直到事务结束才能被释放。
```sql
select * from ad_plan for update;
insert ...
delete ...
update ...
```

#### 悲观锁按作用范围划分为：行锁、表锁。
##### 行锁
锁的作用范围是行级别。**行级锁**是一种排他锁，防止其他事务修改此行；在使用以下语句时，Oracle 会自动应用行级锁：  
INSERT、UPDATE、DELETE、SELECT … FOR UPDATE [OF columns] [WAIT n | NOWAIT];  
SELECT … FOR UPDATE 语句允许用户一次锁定多条记录进行更新  
使用 COMMIT 或 ROLLBACK 语句释放锁
##### 表锁
锁的作用范围是整张表。**表级锁**又分为 5 类：

行共享 (ROW SHARE) : 禁止排他锁定表  
行排他 (ROW EXCLUSIVE) : 禁止使用排他锁和共享锁  
共享锁 (SHARE) : 锁定表，对记录只读不写，多个用户可以同时在同一个表上应用此锁  
共享行排他 (SHARE ROW EXCLUSIVE) : 比共享锁更多的限制，禁止使用共享锁及更高的锁  
排他 (EXCLUSIVE) : 限制最强的表锁，仅允许其他用户查询该表的行。禁止修改和锁定表。

数据库能够确定那些行需要锁的情况下使用行锁，如果不知道会影响哪些行的时候就会使用表锁。

> 举个例子，一个用户表 user，有主键 id 和用户生日 birthday。  
> 当你使用 update … where id=? 这样的语句时，数据库明确知道会影响哪一行，它就会使用行锁；  
> 当你使用 update … where birthday=? 这样的的语句时，因为事先不知道会影响哪些行就可能会使用表锁。

#### 悲观锁的优化

##### 隐式锁

为了降低锁的开销，innodb采用了延迟加锁机制，即隐式锁(implicit lock)\[7\]。  
 从数据存储结构上看，每张表的数据都是挂在聚簇索引的B+树下面的叶子节点上（每个节点代表一个page，每个page存放着多行数据）。每行存储的信息项中都会存有一隐藏列事务id。当有事务对这条记录进行修改时，需要先判断该行记录是否有隐式锁（原记录的事务id是否是活动的事务），如果有则为其真正创建锁并等待，否则直接更新数据并写入自己的事务id。  
 二级索引虽然存储上没有记录事务id，但同样可以存在隐式锁，只不过判断逻辑复杂一些，需要依赖对应的聚簇索引做计算。  
 **当然，隐式锁只是一个实现细节，显示还是隐式加锁并不影响上文对加锁的判断。隐式锁只是将加锁时机延后了而已**  
 另外，聚簇索引每行记录的事务id，还有一个重要作用就是实现MVCC快照读：由于事务id是全局递增的，那么进行快照读的时候，如果数据的事务id小于当前事务id并且不在活跃事务列表内（尚未提交），则直接返回当前行数据。否则需要根据roll pointer（和事务id一样，也在每行的隐藏列中）去查找undo日志。

### 乐观锁（Optimistic Lock）

顾名思义，就是很乐观，每次去拿数据的时候都认为别人不会修改，所以，不会上锁。但是在更新的时候会判断一下在此期间别人有没有更新这个数据，可以使用`版本号`等机制。

> 乐观锁（ Optimistic Locking ）： 相对悲观锁而言，乐观锁机制采取了更加宽松的加锁机制。  
> **悲观锁**大多数情况下依靠数据库的锁机制实现，以保证操作最大程度的独占性。但随之而来的就是数据库性能的大量开销，特别是对长事务而言，这样的开销往往无法承受。而乐观锁机制在一定程度上解决了这个问题。  
> **乐观锁**，大多是基于数据版本（ Version ）记录机制实现。  
> **数据版本**：为数据增加一个版本标识，在基于数据库表的版本解决方案中，一般是通过为数据库表增加一个 “version” 字段来实现。读取出数据时，将此版本号一同读出，之后更新时，对此版本号加一。此时，将提交数据的版本数据与数据库表对应记录的当前版本信息进行比对，如果提交的数据版本号大于数据库表当前版本号，则予以更新，否则认为是过期数据。

乐观锁适用于多读的应用类型，这样可以提高吞吐量，像数据库如果提供类似于 write_condition 机制的其实都是提供的乐观锁。

#### 乐观锁的[实现方式](https://www.jianshu.com/p/eb41df600775)

- 版本号（version）

> 就是给数据增加一个版本标识，在数据库上就是表中增加一个 version 字段，每次更新把这个字段加 1，读取数据的时候把 version 读出来，更新的时候比较 version，如果还是开始读取的 version 就可以更新了，如果现在的 version 比老的 version 大，说明有其他事务更新了该数据，并增加了版本号，这时候得到一个无法更新的通知，用户自行根据这个通知来决定怎么处理，比如重新开始一遍。这里的关键是判断 version 和更新两个动作需要作为一个原子单元执行，否则在你判断可以更新以后正式更新之前有别的事务修改了 version，这个时候你再去更新就可能会覆盖前一个事务做的更新，造成第二类丢失更新，所以你可以使用 update … where … and version=”old version” 这样的语句，根据返回结果是 0 还是非 0 来得到通知，如果是 0 说明更新没有成功，因为 version 被改了，如果返回非 0 说明更新成功。

- 时间戳（使用数据库服务器的时间戳）
  
> 和版本号基本一样，只是通过时间戳来判断而已，注意时间戳要使用数据库服务器的时间戳不能是业务系统的时间。

   - 待更新字段

> 和版本号方式相似，只是不增加额外字段，直接使用有效数据字段做版本控制信息，因为有时候我们可能无法改变旧系统的数据库表结构。假设有个待更新字段叫 count, 先去读取这个 count, 更新的时候去比较数据库中 count 的值是不是我期望的值（即开始读的值），如果是就把我修改的 count 的值更新到该字段，否则更新失败。java 的基本类型的原子类型对象如 AtomicInteger 就是这种思想。

   - 所有字段  

> 和待更新字段类似，只是使用所有字段做版本控制信息，只有所有字段都没变化才会执行更新。

<br/>

#### 乐观锁几种方式的[区别](https://www.jianshu.com/p/eb41df600775)

新系统设计可以使用 version 方式和 timestamp 方式，需要增加字段，应用范围是整条数据，不论那个字段修改都会更新 version, 也就是说两个事务更新同一条记录的两个不相关字段也是互斥的，不能同步进行。旧系统不能修改数据库表结构的时候使用数据字段作为版本控制信息，不需要新增字段，待更新字段方式只要其他事务修改的字段和当前事务修改的字段没有重叠就可以同步进行，并发性更高。

## 锁协议

### 一级加锁协议
在对数据进行写操作之前需要加X锁，直到**事务结束**才释放锁。一级协议保证数据不会丢失更改，但仍有脏读，不可重复读与幻读的危险。

### 二级加锁协议
在一级加锁协议的基础上，对数据进行读操作时需要加S锁，**读取完毕(不一定要事务结束)**即可释放。二级加锁协议保证了数据不会丢失更改和脏读，但是仍有不可重复读与幻读的危险。

### 三级加锁协议
在二级协议的基础上，在对数据进行读操作是需要加S锁，且**事务结束**才可释放。三级加锁协议保证了数据不会丢失修改，脏读和不可重复读。但是仍有幻读的危险。

## 锁带来的问题

并发控制会造成活锁和死锁，就像操作系统那样，会因为互相等待而导致。

### 活锁

**定义**：指的是 T1 封锁了数据 R，T2 同时也请求封锁数据 R，T3 也请求封锁数据 R，当 T1 释放了锁之后，T3 会锁住 R，T4 也请求封锁 R，则 T2 就会一直等待下去。  
**解决方法**：采用 “先来先服务” 策略可以避免。

### 死锁

#### 死锁的定义

多个进行相互等待对方资源，在得到所有资源继续运行之前，都不会释放自己已有的资源，这样造成了循环等待的现象，称为死锁。

#### 产生死锁的四大必要条件

- 资源互斥 / 资源不共享

	每个资源要么已经分配给了一个进程，要么是可用的，只有这两种状态，资源不可以被共享使用，所以所谓的互斥是指：资源不共享，如果被使用，只能被一个进程使用。

- 占有和等待 / 请求并保持

	已经得到资源的进程还能继续请求新的资源，所以个人觉得叫占有并请求也许更好理解。

- 资源不可剥夺

	当一个资源分配给了一个进程后，其它需要该资源的进程不能强制性获得该资源，除非该资源的当前占有者显示地释放该资源。

- 环路等待

	死锁发生时，系统中一定有由两个或两个以上的进程组成的一条环路，环路上的每个进程都在等待下一个进程所占有的资源。

**举个例子▼**

小明有键盘，小白有鼠标，小明要用电脑打游戏，小白要用电脑做 PPT，小明没有鼠标没法打游戏，小白没有键盘没法做 PPT，小明等小白把鼠标给自己，小白也等小明把键盘给自己，但是小明不愿意把键盘给小白，小白也不愿意把鼠标给小明，小明和小白也不能互相抢键盘和鼠标，他俩之间就形成了死锁。

![](https://r2.129870.xyz/img/20210406220230.png)

#### 死锁预防

防止死锁的发生只需破坏死锁产生的四个必要条件之一即可，但目前下述方法开销很大，不易实现,因此，目前使用的方法是避免死锁，而不是防止死锁。  

1. 破坏互斥条件

	如果允许系统资源都能共享使用，则系统不会进入死锁状态。

	缺点：有些资源根本不能同时访问，如打印机等临界资源只能互斥使用。所以，破坏互斥条件而预防死锁的方法不太可行，而且在有的场合应该保护这种互斥性。

2. 破坏请求并保持条件

	釆用预先静态分配方法，即进程在运行前一次申请完它所需要的全部资源，在它的资源未满足前，不把它投入运行。一旦投入运行后，这些资源就一直归它所有，也不再提出其他资源请求，这样就可以保证系统不会发生死锁。

	缺点：系统资源被严重浪费，其中有些资源可能仅在运行初期或运行快结束时才使用，甚至根本不使用。而且还会导致 “饥饿” 现象，当由于个别资源长期被其他进程占用时，将致使等待该资源的进程迟迟不能开始运行。

3. 破坏不可剥夺条件

	当一个已保持了某些不可剥夺资源的进程，请求新的资源而得不到满足时，它必须释放已经保持的所有资源，待以后需要时再重新申请。这意味着，一个进程已占有的资源会被暂时释放，或者说是被剥夺了，或从而破坏了不可剥夺条件。

	缺点：该策略实现起来比较复杂，释放已获得的资源可能造成前一阶段工作的失效，反复地申请和释放资源会增加系统开销，降低系统吞吐量。这种方法常用于状态易于保存和恢复的资源，如 CPU 的寄存器及内存资源，一般不能用于打印机之类的资源。

4. 破坏循环等待条件

	为了破坏循环等待条件，可釆用顺序资源分配法。首先给系统中的资源编号，规定每个进程，必须按编号递增的顺序请求资源，同类资源一次申请完。也就是说，只要进程提出申请分配资源 Ri，则该进程在以后的资源申请中，只能申请编号大于 Ri 的资源。

	缺点：这种方法存在的问题是，编号必须相对稳定，这就限制了新类型设备的增加；尽管在为资源编号时已考虑到大多数作业实际使用这些资源的顺序，但也经常会发生作业使用资源的顺序与系统规定顺序不同的情况，造成资源的浪费；此外，这种按规定次序申请资源的方法，也必然会给用户的编程带来麻烦。

#### 死锁避免

1. 判断 “系统安全状态” 法

	在进行系统资源分配之前，先计算此次资源分配的安全性。若此次分配不会导致系统进入不安全状态，则将资源分配给进程； 否则，让进程等待。 
	
	**银行家算法**

	1. 申请的贷款额度不能超过银行现有的资金总额

	2. 分批次向银行提款，但是贷款额度不能超过一开始最大需求量的总额

	3. 暂时不能满足客户申请的资金额度时，在有限时间内给予贷款

	4. 客户要在规定的时间内还款

2. 一次封锁法

	一次性把所需要的数据全部封锁住，但是这样会扩大了封锁的范围，降低系统的并发度；  
3. 顺序封锁法

	事先对数据对象指定一个封锁顺序，要对数据进行封锁，只能按照规定的顺序来封锁，但是这个一般不大可能的。

#### 死锁检测

1. 资源分配图法

	系统死锁，可利用资源分配图来描述。如下图所示，用长方形代表一个进程，用框代表一类资源。由于一种类型的资源可能有多个，用框中的一个点代表一类资源中的一个资源。从进程到资源的有向边叫请求边，表示该进程申请一个单位的该类资源；从资源到进程的边叫分配边，表示该类资源已经有一个资源被分配给了该进程。

![](https://img-blog.csdn.net/20180731103654409?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2pnbTIwNDc1/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)![](https://r2.129870.xyz/img/20210406220237.png)

**简化资源分配图**

第一步：先看 A 资源，它有三个箭头是向外的，因此它一共给进程分配了 3 个资源，此时，A 没有空闲的资源剩余。

第二步：再看 B 资源，它有一个箭头是向外的，因此它一共给进程分配了 1 个资源，此时，B 还剩余一个空闲的资源没分配。 

第三步：看完资源，再来看进程，先看进程 P2，它只申请一个 A 资源，但此时 A 资源已经用光了，所以，进程 P2 进入阻塞状态，因此，进程 P2 暂时不能化成孤立的点。 

第四步：再看进程 P1，它只申请一个 B 资源，此时，系统还剩余一个 B 资源没分配，因此，可以满足 P1 的申请。这样，进程 P1 便得到了它的全部所需资源，所以它不会进入阻塞状态，可以一直运行，等它运行完后，我们再把它的所有的资源释放。相当于：可以把 P1 的所有的边去掉，变成一个孤立的点，如下图所示：

![](https://r2.129870.xyz/img/20210406220251.png)

第五步：进程 P1 运行完后，释放其所占有的资源（2 个 A 资源和 1 个 B 资源），系统回收这些资源后，空闲的资源便变成 2 个 A 资源和 1 个 B 资源，由于进程 P2 一直在申请一个 A 资源，所以此时，系统能满足它的申请。这样，进程 P2 便得到了它的全部所需资源，所以它不会进入阻塞状态，可以一直运行，等它运行完后，我们再把它的所有的资源释放。相当于：可以把 P2 的所有的边都去掉，化成一个孤立的点，变成下图： 

![](https://r2.129870.xyz/img/20210406220300.png)

（若能消去图中所有的边，则称该图是**可完全简化**的，如上图）

**死锁定理：**   

如果资源分配图中没有环路，则系统没有死锁；
如果资源分配图中出现了环路，则系统可能有死锁。  
当且仅当 S 状态的资源分配图是不可完全简化的时候，系统状态则是死锁状态

2. 超时法
	
	如果某个事物的等待时间超过指定时限，则判定为出现死锁
3. 等待图法
	
	如果事务等待图中出现了回路，则判断出现了死锁。

#### 死锁解除

1. 资源剥夺法

	挂起某些死锁进程，并抢占它的资源，将这些资源分配给其他的死锁进程。但应防止被挂起的进程长时间得不到资源，而处于资源匮乏的状态。

2. 撤销进程法

	强制撤销部分、甚至全部死锁进程并剥夺这些进程的资源。撤销的原则可以按进程优先级和撤销进程代价的高低进行。

3. 进程回退法

	让一（多）个进程回退到足以回避死锁的地步，进程回退时自愿释放资源而不是被剥夺。要求系统保持进程的历史信息，设置还原点。