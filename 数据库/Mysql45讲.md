#数据库 #Mysql

# 1. Mysql45 讲

## 1.1. Sql 语句在 Mysql 的执行过程

 ![](https://varg-my-images.oss-cn-beijing.aliyuncs.com/img/20220508232841.png)

- 缓存在 8.0 中已经移除了，不建议使用缓存。Mysql 维护缓存有非常大的性能开销。

- 权限的判断是在执行器的时候进行的。因为部分操作 Mysql 无法在前面的步骤进行，比如触发器只能到执行阶段才能确认。

- 在分析器就完成了 SQL 语句的检查。分析器处理语法和解析查询，生成一颗解析树。进而检查解析树是否合法，列名是否有歧义等。通过则生成新的解析树再交给优化器。

## 1.2. 普通索引和唯一索引的选择

对于唯一索引，限制数据是唯一的，因此在执行插入或者修改操作的时候必须判断该数据是否重复。而对于普通索引则没有这个限制。

### 1.2.1. 普通索引和唯一索引查询的区别

- 唯一索引

	- 查询时通过 B+树查找，找到第一个满足条件的记录后就停止检索。
	
	- 更新时首先判断内存中是否有该数据，有的话就直接更新，否则需要加载到内存中然后更新。
	
- 普通索引

	- 查询时通过 B+树查找，找到满足条件的数据后还要判断下一条数据是否满足条件。大部分情况下这两条数据都在同一个页中，因此这个多出来的判断时间其实很小。但当下一条数据不在同一页，正好分页的时候，就需要多一次磁盘 IO 操作将其加载到页中了。当然这种情况比较少。
	
	- 更新时如果发现内存中有该数据，则直接更新内存。**内存中没有的话就在 ChangeBuffer 中记录该更新操作然后返回。**所以这个会比唯一索引的操作快很多。
	
	- ChangeBuffer 记录仅针对二级索引有效，**因为主键索引和唯一索引需要确定唯一性，所以就必须要把数据页加载到内存中进行检查。**当操作的二级索引不在内存中时就会缓存下来。等到下次读取该页时就与 ChangeBuffer 合并。

## 1.3. 问题列表

### 1.3.1. 在 GTID 模式下，如果一个新的从库接上主库，但是需要的 binlog 已经没了，要怎么做？

- 如果业务允许主从不一致的情况，那么可以在主库上先执行 `show global variables like ‘gtid_purged’;`，得到主库已经删除的 GTID 集合，假设是 gtid_purged1；然后先在从库上执行 `reset master`，再执行 `set global gtid_purged =‘gtid_purged1’;` 最后执行 `start slave`，就会从主库现存的 binlog 开始同步。Binlog 缺失的那一部分，数据在从库上就可能会有丢失，造成主从不一致。

- 如果需要主从数据一致的话，最好还是通过重新搭建从库来做。

- 如果有其他的从库保留有全量的 binlog 的话，可以把新的从库先接到这个保留了全量 binlog 的从库，追上日志以后，如果有需要，再接回主库。

- 如果 binlog 有备份的情况，可以先在从库上应用缺失的 binlog，然后再执行 `start slave`。

### 1.3.2. MySQL 是怎么快速定位 binlog 里面的某一个 GTID 位置的？

在 binlog 文件头部的 Previous_gtids 可以解决这个问题。

### 1.3.3. 若采用 GTID 等定位方法做读写分离，对大表做 DDL 操作该如何进行？

假设，这条语句在主库上要执行 10 分钟，提交后传到备库就要 10 分钟（典型的大事务）。那么，在主库 DDL 之后再提交的事务的 GTID，去备库查的时候，就会等 10 分钟才出现。这样，这个读写分离机制在这 10 分钟之内都会超时，然后走主库。这种预期内的操作，应该在业务低峰期的时候，确保主库能够支持所有业务查询，然后把读请求都切到主库，再在主库上做 DDL。等备库延迟追上以后，再把读请求切回备库。

### 1.3.4. 如果一个事务被 kill 之后，持续处于回滚状态，从恢复速度的角度看，你是应该重启等它执行结束，还是应该强行重启整个 MySQL 进程?

因为重启之后该做的回滚动作还是不能少的，所以从恢复速度的角度来说，应该让它自己结束。

当然，如果这个语句可能会占用别的锁，或者由于占用 IO 资源过多，从而影响到了别的语句执行的话，就需要先做主备切换，切到新主库提供服务。切换之后别的线程都断开了连接，自动停止执行。接下来还是等它自己执行完成。这个操作属于我们在文章中说到的，减少系统压力，加速终止逻辑。

### 1.3.5. 如果客户端由于压力过大，迟迟不能接收数据，会对服务端造成什么严重的影响？

这个问题的核心是，造成了“长事务”。至于长事务的影响，就要结合我们前面文章中提到的锁、MVCC 的知识点了。

如果前面的语句有更新，意味着它们在占用着行锁，会导致别的语句更新被锁住。

当然读的事务也有问题，就是会导致 undo log 不能被回收，导致回滚段空间膨胀。

### 1.3.6. 以下语句如何建立索引及关联查询合适？

```sql

select * from t1 join t2 on(t1.a=t2.a) join t3 on (t2.b=t3.b) where t1.c>=X and t2.c>=Y and t3.c>=Z;

```

第一原则是要尽量使用 BKA 算法。需要注意的是，使用 BKA 算法的时候，并不是“先计算两个表 join 的结果，再跟第三个表 join”，而是直接嵌套查询的。

具体实现是：在 t1. c>=X、t2. c>=Y、t3. c>=Z 这三个条件里，选择一个经过过滤以后，数据最少的那个表，作为第一个驱动表。

此时，可能会出现如下两种情况：

- 第一种情况，如果选出来是表 t1 或者 t3，那剩下的部分就固定了。

	- 如果驱动表是 t1，则连接顺序是 t1->t2->t3，要在**被驱动表字段创建上索引**，也就是 t2. a 和 t3. b 上创建索引；
	
	- 如果驱动表是 t3，则连接顺序是 t3->t2->t1，需要在 t2. b 和 t1. a 上创建索引。
	
	- 同时，我们还需要在第一个驱动表的字段 c 上创建索引。
	
- 第二种情况是，如果选出来的第一个驱动表是表 t2 的话，则需要评估另外两个条件的过滤效果。

总之，整体的思路就是，尽量让每一次参与 join 的驱动表的数据集，越小越好，因为这样我们的驱动表就会越小。

### 1.3.7. 为什么不能用 rename 修改临时表的改名？

在实现上，执行 rename table 语句的时候，要求按照“库名 / 表名. frm”的规则去磁盘找文件，但是临时表在磁盘上的 frm 文件是放在 tmpdir 目录下的，并且文件名的规则是 `“#sql{进程 id}\_{线程 id}\_ 序列号.frm”`，因此会报“找不到文件名”的错误。