#数据库 #Mysql

# 1. Mysql45 讲

## 1.1. 问题列表

### 1.1.1. 在 GTID 模式下，如果一个新的从库接上主库，但是需要的 binlog 已经没了，要怎么做？

- 如果业务允许主从不一致的情况，那么可以在主库上先执行 `show global variables like ‘gtid_purged’;`，得到主库已经删除的 GTID 集合，假设是 gtid_purged1；然后先在从库上执行 `reset master`，再执行 `set global gtid_purged =‘gtid_purged1’;` 最后执行 `start slave`，就会从主库现存的 binlog 开始同步。Binlog 缺失的那一部分，数据在从库上就可能会有丢失，造成主从不一致。
- 如果需要主从数据一致的话，最好还是通过重新搭建从库来做。
- 如果有其他的从库保留有全量的 binlog 的话，可以把新的从库先接到这个保留了全量 binlog 的从库，追上日志以后，如果有需要，再接回主库。
- 如果 binlog 有备份的情况，可以先在从库上应用缺失的 binlog，然后再执行 `start slave`。

### 1.1.2. MySQL 是怎么快速定位 binlog 里面的某一个 GTID 位置的？

在 binlog 文件头部的 Previous_gtids 可以解决这个问题。

### 1.1.3. 若采用 GTID 等定位方法做读写分离，对大表做 DDL 操作该如何进行？

假设，这条语句在主库上要执行 10 分钟，提交后传到备库就要 10 分钟（典型的大事务）。那么，在主库 DDL 之后再提交的事务的 GTID，去备库查的时候，就会等 10 分钟才出现。这样，这个读写分离机制在这 10 分钟之内都会超时，然后走主库。这种预期内的操作，应该在业务低峰期的时候，确保主库能够支持所有业务查询，然后把读请求都切到主库，再在主库上做 DDL。等备库延迟追上以后，再把读请求切回备库。

### 1.1.4. 如果一个事务被 kill 之后，持续处于回滚状态，从恢复速度的角度看，你是应该重启等它执行结束，还是应该强行重启整个 MySQL 进程?

因为重启之后该做的回滚动作还是不能少的，所以从恢复速度的角度来说，应该让它自己结束。

当然，如果这个语句可能会占用别的锁，或者由于占用 IO 资源过多，从而影响到了别的语句执行的话，就需要先做主备切换，切到新主库提供服务。切换之后别的线程都断开了连接，自动停止执行。接下来还是等它自己执行完成。这个操作属于我们在文章中说到的，减少系统压力，加速终止逻辑。

### 1.1.5. 如果客户端由于压力过大，迟迟不能接收数据，会对服务端造成什么严重的影响？

这个问题的核心是，造成了“长事务”。至于长事务的影响，就要结合我们前面文章中提到的锁、MVCC 的知识点了。

如果前面的语句有更新，意味着它们在占用着行锁，会导致别的语句更新被锁住。

当然读的事务也有问题，就是会导致 undo log 不能被回收，导致回滚段空间膨胀。

### 1.1.6. 以下语句如何建立索引及关联查询合适？

```sql

select * from t1 join t2 on(t1.a=t2.a) join t3 on (t2.b=t3.b) where t1.c>=X and t2.c>=Y and t3.c>=Z;

```

第一原则是要尽量使用 BKA 算法。需要注意的是，使用 BKA 算法的时候，并不是“先计算两个表 join 的结果，再跟第三个表 join”，而是直接嵌套查询的。

具体实现是：在 t1. c>=X、t2. c>=Y、t3. c>=Z 这三个条件里，选择一个经过过滤以后，数据最少的那个表，作为第一个驱动表。

此时，可能会出现如下两种情况：

- 第一种情况，如果选出来是表 t1 或者 t3，那剩下的部分就固定了。
	- 如果驱动表是 t1，则连接顺序是 t1->t2->t3，要在**被驱动表字段创建上索引**，也就是 t2. a 和 t3. b 上创建索引；
	- 如果驱动表是 t3，则连接顺序是 t3->t2->t1，需要在 t2. b 和 t1. a 上创建索引。
	- 同时，我们还需要在第一个驱动表的字段 c 上创建索引。
- 第二种情况是，如果选出来的第一个驱动表是表 t2 的话，则需要评估另外两个条件的过滤效果。

总之，整体的思路就是，尽量让每一次参与 join 的驱动表的数据集，越小越好，因为这样我们的驱动表就会越小。

### 1.1.7. 为什么不能用 rename 修改临时表的改名？

在实现上，执行 rename table 语句的时候，要求按照“库名 / 表名. frm”的规则去磁盘找文件，但是临时表在磁盘上的 frm 文件是放在 tmpdir 目录下的，并且文件名的规则是 `“#sql{进程 id}\_{线程 id}\_ 序列号.frm”`，因此会报“找不到文件名”的错误。