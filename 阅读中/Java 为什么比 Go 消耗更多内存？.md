---
create: 2023-11-13 14:53
source: https://zhuanlan.zhihu.com/p/409158265
---
　　Java 比 Go 语言消耗更多的内存基本成为了一个共识，这是一个实践自然发现的事实。但是要说明其原因，却需要非常多细致的工作。，很多人归结于 Java 框架臃肿，比如 spring boot 的依赖就是非常多的，但是框架的臃肿是 Java 内存消耗巨大的核心因素吗？如果只是框架的问题，那么我们去实现或者等待别人实现一个更优质的框架即可。

　　我怀着探究的态度去看来 language benchmark 网站上对语言的通用内存消耗对比，我简单整理了一个 10 种不同场景下 Go 和 Java 的内存消耗对比如下：

![](https://pic2.zhimg.com/v2-6a2d5c3c18ca1fed4b43a6a938b95ab1_r.jpg)

  
　　我们发现除了 reverse-complement 场景，其他 9 个场景下都是 Go 语言大幅度领先于 Java 语言。那么我们基本得到一个实践事实：在一般场景和现代后端微服务场景下，Java 比 Go 语言消耗更多的内存。

　　有了事实，我们更想探究这个事实背后的因素。主要是要厘清为什么会发生这样的情况，这种情况究竟是短暂的，还是本质无法改善的？接下来，我接下来就一一拆解这背后因素。

（一）JIT 和 AOT 的架构差异  
　　一个很显然的观点是认为 Java 运行态中包含了一个完整的解释器、一个 JIT 编译期以及一个垃圾回收器，这会显著地增加内存。Go 语言直接编译到机器码，运行态只包含机器码和一个垃圾回收器。显然 Go 的运行态更小。

![](https://pic1.zhimg.com/v2-89b22e45d0ad4cc8ccba53df8088ed4c_r.jpg)

　　这是一个正确的观点，但是却不是 Java 程序内存消耗显著大于 Go 程序的主要因素。事实上 Java 经过多年的优化和调整，解释器和 JIT 消耗的内存显著小于很多人的预期。我在我的笔记本上尝试了一个最小的 Java 可运行程序，就是一个 for 循环无限等待，其内存消耗如下：

![](https://pic2.zhimg.com/v2-b15532224d3882d3b09e7f5b427b282d_r.jpg)

　　在不同的平台和机器上，最小的 Java 内存消耗可能变化，但是总体这部分的大小并不足以成为 Java 程序内存消耗几倍于 Go 程序的主导因素。

（二）面向对象的内存布局和面向值的内存布局

　　Java 是一种面向对象的语言，万物皆对象，这个重要的抽象原则是要付出一定的代价的。最重要的代价就是每个对象需要一个对象头，简单的示意图如下：

![](https://pic3.zhimg.com/v2-2bc06f4c57b15c1acf11065d0cf4a6da_r.jpg)

　　也就是说每个 Java 的对象都要包含一个 96 bits 的对象头，比如一个 32bits 的 integer 占用的内存是多少呢？答案是 96bits+32bits=128bits。

　　那么 Go 语言每个对象消耗多少呢？首先，Go 没有对象，Go 不是一个面向对象的语言，Go 是面向值的语言。这里简化掉 Go 语言中基于 span 的内存管理机制细节讨论，我们给出直观的结论是每一个存储到 span 中的值至少需要消耗 2bits 用于内存分配和垃圾回收管理：

![](https://pic1.zhimg.com/v2-c8c6d3492789132f429a08ff978ece14_r.jpg)

　　显然，Go 在选择不支持面向对象时，选择了一种更加简单的内存布局方式，这种内存布局方式减省了内存消耗。

（三）垃圾回收机制导致的内存利用率不同

　　Java 的垃圾回收机制有着悠久的历史，Java 的垃圾回收机制某种意义上就是现在垃圾回收机制的发展史，我们简单看看 Java 的垃圾回收机制历程，大致如下：

![](https://pic4.zhimg.com/v2-7652d0104780918a45c3fc7b14c08523_r.jpg)

　　其中我们真正值得关注的应该是 ParallelGC，G1 和 ZGC 这 3 种，ParallelGC 是广泛使用的 JDK8 的默认垃圾回收器，G1 是 JDK9 以后的默认垃圾回收器，ZGC 是未来的默认垃圾回收器。

　　我们先简单看看 ParallelGC 的机制，这里不打算讨论每个细节，但是需要对这套垃圾回收机制有个大概的认知，方便我们后续的讨论，这套机制下把堆内存按照如下图所示区域划分：

![](https://pic4.zhimg.com/v2-43542b9d9afec3851a07de15fe4a64d3_r.jpg)

　　主要来看是划分出了新生代和老年代，其运行机制如下图所示：

![](https://pic3.zhimg.com/v2-09123c2fa85bfe3858c793c033074082_r.jpg)

　　在这套管理机制下，我们知道新生代的 To 区域一定要是空置的，按照正常默认的 JDK 配置参数，1/3 的堆内存是新生代，新生代中 1/8 的区域是 To 区域，综合而言也就是说至少有 1/24 的内存区域是需要一直空置浪费的。

　　我们再看看新的默认垃圾回收器 G1，G1 显著转变了区域的划分，转而使用一种基于 region 的管理策略，简单而言就是把内存等分成不同 region，每个 region 在不同时刻扮演 eden、survivor、old、humongous 这 4 种不同的角色。这种划分下，理论上只要任意时刻有一个 region 是空置的就能够进行垃圾回收，这个比例极大概览小于 1/24，所以 G1 的内存利用率更高。

![](https://pic1.zhimg.com/v2-bdd05e5125e1cf66e7525736f8e2138c_r.jpg)

　　对于 Java，我们最后看看下一代垃圾回收器 ZGC，ZGC 目前没有基于分代实现，而是显式地把内存划分成不同大小的块，不同大小的对象从不同块上去分配内存，如果我们对比后续介绍的 Go 的内存管理方式，你会发现 2 者有着一定的共通之处。当然需要指出的是，这种不同大小对象从不同地方分配的策略最早起源自 C 语言的各种内存分配器，只是慢慢 开始被垃圾回收器吸取精华思想。ZGC 下的内存布局如下图所示：

![](https://pic1.zhimg.com/v2-14c8a34d9e1c1876bb6859c086c0061c_r.jpg)

　　综合而言，Java 在发展到 G1 和 ZGC 之后，内存的利用率已经显著增加了很多，就空间利用率而言甚至某些情况下甚至是高于 Go 语言的，所以垃圾回收器不是 Java 的短板。

　　我们再来看看 Go 语言的垃圾回收机制，这里也不会讨论 Go 垃圾回收的所有细节，仅仅针对内存布局来聊聊，首先我们要明确 Go 语言的内存管理是基于 span 的，简单而言一个 span 就是一组大小固定的空槽，每有一个 size 小于等于这个空槽的值申请内存，就分配一个空槽给这个值。

![](https://pic3.zhimg.com/v2-8620991b5f49284bb2b6045fc28bac2a_r.jpg)

　　我小心地避免了使用对象这个词，因为 Go 语言不是面向对象的，Go 是面向值的语言。这种基于 span 和空槽（slot）的管理方式，显然会浪费内存，但是能够显著简化垃圾回收器的设计，同时也能够简化辅助内存的使用，事实上我们提到过，Go 只需要使用 2bits 就能够跟踪和管理每个值在垃圾回收器中的状态。

　　综合而言，在垃圾回收领域，Java 目前在某种程度上还是领先于 Go 的，至少在垃圾回收器的内存利用率上，Java 目前是优于 Go 的，Go 的 span 管理方式简化了内存管理，增加了内存浪费率。

（四）栈的利用效率

　　这一点可能是很少有人提及的一点，但是我却认为非常重要的一个因素，就是 Go 语言倾向于优先把可能的值分配在栈上，这样随着函数的调用和返回，许多临时的小对象就会被释放，Java 虽然也有逃逸分析，但是做得更加保守，远远没有达到栈优先的地步。这和 Go 是面向值的策略非常相关，面向对象的语言做逃逸分析要相对复杂一些，一些不敢保证正确性的场景下就会选择保守策略。

（五）并发模型的区别

　　Java 的并发模型是基于线程的，每个线程默认需要消耗 1MB 左右的内存。Go 的并发模型是基于 coroutine 协程的，每个协程默认消耗 2KB（不足时可扩展）的内存。在后端微服务场景下，通常需要创建大量的线程 / 协程来处理高并发。比如我们设定系统处理能力为 100 个并发（并发和并行需要区分看待），那么 Java 程序需要 100 个线程，消耗 100MB 左右，而相同并发情况下 Go 程序需要 100 个协程，消耗 200KB 左右。

（六）反射机制和框架实现策略

　　最后一个不得不提的点就是框架的实现策略，其中最为重要的就是反射和 hashmap 的使用，Java 的框架实现中大量使用反射，并使用 hashmap 缓存信息，这 2 个都是极度消耗内存的行为。要想佐证这个观点，只需要启动一个最流行的 spring boot 应用，写一个 hello world 接口，然后通过对象分析，看看 hashmap 对象有多少个，以及 reflect 相关对象的数量就可以映证了。

　　反射是某种意义上的元编程，几乎是框架实现的必经之路，Go 的框架就不使用反射来编写框架吗？就不使用 map 缓存相关信息吗？答案是 Go 的框架中也使用 reflect，当然也使用 map。但是 Go 又占了面向 interface 和值的便宜，Go 的反射模型要比 Java 的反射模型简单非常多，反射过程要产生的对象数量也少非常多。

　　全篇总结而言，在内存利用效率上，Go 语言确实比 Java 做得更好，在 6 个不同的角度来总结：

（1）Java 的 JIT 策略比 Go 的 AOT 策略，在运行时上多占用了一些内存

（2）Java 的面向对象抽象策略比 Go 的面向值的抽象策略在每个对象 / 值上多消耗了内存

（3）内存分配和垃圾回收器上，Java 目前在内存利用率上领先

（4）在栈的利用方面，Go 语言做得比 Java 更加激进

（5）并发模型上，协程模型比线程模型更加节省内存。

（5）Go 的反射更加简单，导致框架的内存消耗上 Go 程序比 Java 程序优秀。

　　协程这种用户态的调度模型在并发上的优越性已经被各种语言证明，当然更多语言选择的是 async/await 语法来支持协程。Java 自己也意识到了这个问题，开启了 loom project 来添加相关支持，只是这个项目的进度远远慢于人们的预期。相信将来的某一天 Java 也能够用上协程，但是短期内在这个领域还是 Go 更为领先。

　　多说几句题外话，我们发现 Go 在内存消耗上的领先，一大部分源自其砍掉了面向对象。原来的软件思潮里面，面向对象几乎就是正统的皇皇大道，但是后来我们慢慢发现继承也许不是一个好的抽象，很多时候是组合优于继承。如果把继承砍掉，那么面向对象的概念几乎也就不再那么必要了。

　　如果面向对象没有带来本质上的概念优越性，又带来了许多不必要的负担和麻烦，那么可能面向对象就不是编程的必须思想。例如现在在内存利用率上看到的情况，基本都是由于 Go 的值模型更加简单才占到了便宜。

　　我们发现在 Go 中利用 struct 和 interface 也能很好地抽象客观世界。另外一个编程语言界新星 Rust 也抛弃了面向对象的概念，在 Rust 中利用 struct 和 trait 抽象客观世界，也没有发现明显的短板和无法逾越的逻辑难题。Go 之于 Java，Rust 之于 C++，新生力量都不约而同的选择了砍掉面向对象，也许有时候适当做减法也是一种更大的智慧。

　　那么面向对象所声称的 “对象 = 数据 + 方法” 是否是正确的呢？我们是否只需要孤立的值和方法？就像 C 语言那样，只要值和方法就足够了？我个人的观点是，数据和方法的紧密结合仍然是必要的，面向对象中多余的概念可能就是继承，没有继承的面向对象可能是一个更加优秀的选择。就像 Rust 中一样，struct 上依然可以有方法，但是没有继承的概念。也许将来的某一天，我们像本文一样审视 C++ 和 Rust，我们说不定会发现 Rust 的大部分优势都是源自于砍掉了复杂的面向对象继承机制。