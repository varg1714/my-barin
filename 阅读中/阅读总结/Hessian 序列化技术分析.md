---
source: "[[0 基础带你精通 Java 对象序列化 -- 以 Hessian 为例｜得物技术]]"
---

## 1. 核心观点

文章的核心观点是：在分布式系统中，Java 对象（Object）必须被转换成字节流（byte\[]）才能在网络中传输，这个过程称为**序列化（编码）**。Hessian 是一个专为 Java 优化的、高效的二进制序列化框架，它通过精巧的编码设计，在效率和数据压缩率上表现优异。

## 2. 文章结构与主要内容分析

文章可以分为四个主要部分：

1.  **背景与问题引入 (一、概述)**
    *   **根本矛盾**：高级编程语言处理的是**对象（Object）**，而网络传输介质只能理解扁平化的**字节流（byte\[]）**。
    *   **解决方案**：引入一个转换层，即序列化（编码）和反序列化（解码）工具。
    *   **Hessian 的优势**：
        *   **深度适配 Java**：原生支持泛型、多态等 Java 特性。
        *   **高效二进制协议**：相比 JSON 等文本协议，编码效率和数据压缩率更高。

2.  **序列化的两大基本原理 (二、基础编码原理)**
    *   **对象图遍历**：通过反射等技术，按深度优先的原则遍历对象及其所有属性，直到最底层的基本数据类型。这是所有序列化框架的基础。
    *   **编码格式**：定义如何将遍历得到的数据组织成字节流。这是不同框架体现竞争力的关键。文章通过一个简单的例子说明，若没有元数据（如边界标识），解码端将无法还原对象。JSON 使用 `{}`、`,`、`:` 等符号作为元数据，而 Hessian 使用二进制的 **tag**。

3.  **Hessian 的核心编码格式 (三、Hessian 编码格式)**
    *   **数据块 (Data Block)**：对象图中的每个节点（对象、字段、基本类型）都是一个数据块。
    *   **数据块标签 (Tag)**：Hessian 的精髓所在。它在每个数据块前都加上一个**前缀字节 (tag)**，用来标识该数据块的类型（如整数、字符串、布尔值等），解码端根据 tag 来决定如何解析后续的字节。
    *   **POJO 编码与结构复用**：
        *   Hessian 将 POJO 的**结构**（类名、字段名列表）和**字段值**分开编码。
        *   结构信息（tag `C`）只会在第一次遇到该类型的 POJO 时被编码，并分配一个**结构序号**。
        *   后续再编码同类型的 POJO 时，只需编码字段值（tag `O`）并引用该结构序号即可，避免了重复传输类名和字段名，大大节省了空间。

4.  **Hessian 的高级优化技巧 (四、Hessian 编码细节)**
    *   **重复对象复用**：为每个**对象实例**分配一个从 0 开始的序号。当再次遇到同一个对象引用（包括循环引用）时，直接写入该对象的引用序号，而不是再次编码整个对象，解决了循环引用导致的栈溢出和数据冗余问题。
    *   **小整数/短长度内联 (Direct)**：巧妙地利用了 tag 字节（0-255）的空闲区间。将一些常用的、数值较小的数据（如短字符串的长度、小整数值、POJO 结构序号）直接编码在 tag 值本身，从而节省了额外的字节。例如，长度为 5 的字符串，其 tag 本身就代表了“这是一个长度为 5 的字符串”。
    *   **字符串编码**：对长字符串进行分块处理，并根据最后一块的长度选择不同的 tag，进一步优化编码效率。
    *   **整数压缩**：采用**变长编码**。对于常用的、绝对值较小的整数，使用 1-3 个字节编码；只有对于非常大的整数，才使用标准的 5 字节（1 byte tag + 4 bytes data）编码。这极大地压缩了常见整数的存储空间。

## 3. 总结

这篇文章通过清晰的图示和伪代码，系统地解释了 Hessian 从基本原理到高级优化的完整设计思路。它不仅告诉我们 Hessian 是如何工作的，更重要的是揭示了其“为什么”这样设计——一切都是为了在 Java RPC 场景下实现极致的**编码效率**和**数据压缩率**。对于想要深入理解序列化或网络通信底层原理的开发者来说，这是一篇非常有价值的文章。