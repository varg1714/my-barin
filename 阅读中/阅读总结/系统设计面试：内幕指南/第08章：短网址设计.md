---
source:
  - "[[阅读中/文章列表/系统设计面试：内幕指南/第08章：短网址设计]]"
  - "[[面试官：如何设计一个十亿级的 URL 短链系统？]]"
create: 2025-10-03
---

## 1. 短网址系统设计学习笔记

本文档是对短网址（URL Shortener）系统设计的全面总结，结合了基础设计原则与业界进阶实践方案。

## 2. 核心需求与系统估算

### 2.1. 功能需求

1. **URL 缩短 (Write)**：输入一个长网址（long URL），返回一个唯一的、尽可能短的短网址（short URL）。
2. **URL 重定向 (Read)**：访问一个短网址，服务器能将其重定向到原始的长网址。

### 2.2. 性能与规模估算 (Back-of-the-envelope)

- **写入量**：每天新增 1 亿个 URL。
- **写入 QPS**：$10^8 / (24 * 3600) \approx 1160$ writes/sec。
- **读写比**：假设为 10:1。
- **读取 QPS**：$1160 * 10 = 11,600$ reads/sec。
- **存储需求**：假设服务运行 10 年，平均 URL 长度为 100 字节。
  - 总记录数：$10^8 * 365 * 10 = 3650$ 亿条。
  - 存储空间：$3650亿 * 100字节 \approx 36.5$ TB (原文计算有误，应为 36.5TB，非 365TB)。
- **短链长度**：字符集为 `[0-9, a-z, A-Z]` (62 个字符)。为支持 3650 亿个 URL，需满足 $62^n \ge 3.65 \times 10^{11}$。
  - 当 $n=7$ 时，$62^7 \approx 3.5 \times 10^{12}$ (3.5 万亿)，足够支持。因此，短链核心部分长度定为 **7 位**。

## 3. 高层设计

### 3.1. API 端点 (RESTful API)

- **创建短链**：`POST /api/v1/data/shorten`
  - 请求体：`{ "longUrl": "https://..." }`
  - 成功响应：`{ "shortUrl": "https://tiny.url/xxxxxxx" }`
- **访问短链**：`GET /api/v1/{shortUrl}`
  - 成功响应：HTTP 301 或 302 重定向到 longUrl。

### 3.2. URL 重定向策略：301 vs 302

- **301 Moved Permanently (永久重定向)**
  - **优点**：浏览器会缓存结果，后续访问直接从浏览器缓存重定向，极大降低我方服务器压力。
  - **缺点**：无法追踪后续的点击分析（如点击次数、来源等），因为请求不再经过我们的服务器。
- **302 Found (临时重定向)**
  - **优点**：每次访问都会请求我们的服务器，便于进行详细的点击分析和数据追踪。
  - **缺点**：服务器负载更高。

**选择**：取决于业务目标。若追求性能和低成本，选 301；若数据分析是核心，选 302。

## 4. 深入设计

### 4.1. 数据模型

使用关系型数据库（如 MySQL, PostgreSQL）即可，一张表足以。

| 字段名 | 类型 | 描述 |
| :--- | :--- | :--- |
| `id` | BIGINT | 主键，唯一 ID，可用于生成短链 |
| `short_url` | VARCHAR(7) | 7 位短链码，建立索引以加速查询 |
| `long_url` | TEXT | 原始长链接，可建立哈希索引 |
| `created_at` | DATETIME | 创建时间 |

### 4.2. 核心：短链生成策略

#### 4.2.1. 方法一：哈希 + 冲突解决

此方法不依赖于数据库 ID，而是直接对长链接进行哈希。

- **基础思路**：`short_url = base62(truncate(hash(long_url), 7))`
- **问题**：哈希截断后，冲突概率大大增加（哈希雪崩效应被破坏）。

**如何减少冲突？**
- **选择更好的哈希函数**：使用为速度和分布性优化的非加密哈希函数，如 **MurmurHash** 或 **xxHash**，它们在截断或取模后通常有更好的分布性，能天然降低冲突。

**冲突后处理策略**

| 策略名称 | 描述 | 优点 | 缺点 |
| :--- | :--- | :--- | :--- |
| **开放寻址法** | 冲突后按规则探测下一个空位。 | 实现简单。 | 易产生聚集，影响性能。 |
| **再哈希法 (Salting)** | 冲突后对 `long_url + salt` 进行哈希，`salt` 可以是递增数字或随机串。 | 简单有效。 | 每次重试都需查询 DB，开销大。 |
| **链地址法** | 数据库层面允许多个长链接映射到同一个短链接“桶”，通过增加后缀区分，如 `xxxxxx-1`。 | 逻辑清晰。 | 短链长度不固定。 |

**优化**：结合**布隆过滤器 (Bloom Filter)**，可以快速判断一个短链“一定不存在”或“可能存在”，大幅减少对数据库的无效查询。

#### 4.2.2. 方法二：唯一 ID + Base62 转换 (主流方案)

此方法是目前业界更常用、更可靠的方案。

- **基础思路**：`ID -> Base62编码 -> short_url`
- **问题**：若 ID 是简单的数据库自增 ID，生成的短链（如 `.../100`, `.../101`）是连续的，容易被遍历爬取，存在安全风险。

**如何生成不可预测的 ID？**

**进阶方案 1：预生成随机码 (号池方案)**
- **思路**：后台服务持续生成大量唯一的、随机的 7 位短码，存入一个“号池”表中。当需要生成短链时，从池中取一个未使用的码即可。
- **优点**：性能极高（取号操作快），完全随机不可预测，长度固定。
- **缺点**：需要额外维护号池，有一定运维成本。

**进阶方案 2：ID 混淆/费斯妥密码网络 (Feistel Network)**
- **思路**：这是一种对数字进行可逆乱序的加密思想。它能将一个连续的 ID 序列（如 `1, 2, 3`）映射成一个看起来完全随机的、不连续的 ID 序列（如 `54321, 123, 98765`）。
- **核心特性**：
  1. **无冲突**：它是一种**双射（Bijection）**，只要输入 ID 唯一，输出 ID 也必然唯一。
  2. **位数不变**：输入一个 40 位的 ID，输出的乱序 ID 也一定是 40 位。
- **流程**：
  1. **获取唯一 ID**：从唯一 ID 生成器（如雪花算法的变种，或数据库）获取一个 ID（如 40 位，足够支持万亿级别）。
  2. **ID 乱序**：使用 Feistel 网络将该 ID 转换为一个乱序 ID。
  3. **Base62 编码**：将乱序后的 ID 进行 Base62 编码，得到最终的 7 位短链码。

### 4.3. 核心：URL 重定向流程

由于读多写少，缓存是关键。

1. 用户点击短链 `https://tiny.url/Abc123X`。
2. 请求经过负载均衡器（Load Balancer）到达 Web 服务器。
3. 服务器提取短链码 `Abc123X`。
4. **查询缓存**（如 Redis）：以 `Abc123X` 为 key 查询是否存在对应的长链接。
5. **缓存命中 (Cache Hit)**：直接获取长链接，返回 301/302 重定向。流程结束。
6. **缓存未命中 (Cache Miss)**：
    a. **查询数据库**：根据 `short_url` 字段 `Abc123X` 查找对应的 `long_url`。
    b. 如果数据库中不存在，说明该短链无效，返回 404 Not Found。
    c. 如果存在，获取 `long_url`。
    d. **更新缓存**：将 `<Abc123X, long_url>` 键值对写入缓存，并设置过期时间（TTL）。
    e. 返回 301/302 重定向。

### 4.4. 过期链接清理：

- **挑战**：主动扫描 TB 级数据库删除过期链接，成本极高且影响性能。
- **策略：惰性删除 + 异步清理**
    1. **惰性删除 (Lazy Deletion)**：当用户访问一个链接时，系统在查询到数据后检查其 `expiration_date`。如果已过期，则不执行重定向，而是直接删除该记录，并返回“链接已失效”的提示。
    2. **异步清理**：部署一个低优先级的后台服务，在系统负载较低时（如凌晨）分批、缓慢地扫描并清理那些已过期但长期未被访问的“僵尸”链接。
    3. **密钥复用**：删除过期链接后，可将其对应的短码回收至 KGS 的“号池”中，实现循环利用。

## 5. 系统扩展与优化

- **速率限制器 (Rate Limiter)**：防止恶意用户通过 API 大量生成短链，可基于 IP 或 API Key 进行限制。
- **Web 服务器扩展**：Web 层是无状态的，可以通过增加服务器实例轻松实现水平扩展。
- **数据库扩展**：
  - **读写分离**：主库处理写请求，从库处理读请求。
  - **分片 (Sharding)**：当数据量巨大时，可根据 `id` 或 `short_url` 的哈希值进行分库分表。
- **数据分析**：将点击事件异步发送到消息队列（如 Kafka），由后端分析服务处理，统计点击数据，避免影响主重定向流程的性能。
- **高可用、高可靠**：数据库多副本、缓存集群、多数据中心部署等，保证系统在部分组件故障时仍能提供服务。