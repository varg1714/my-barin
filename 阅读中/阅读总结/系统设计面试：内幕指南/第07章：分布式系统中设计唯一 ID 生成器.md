---
source: "[[阅读中/文章列表/系统设计面试：内幕指南/第07章：分布式系统中设计唯一 ID 生成器]]"
create: 2025-10-02
---

## 1. 核心内容摘要

这篇文章探讨了在分布式系统中设计一个唯一 ID 生成器的几种方案。文章首先明确了设计需求，然后逐一分析了四种主流方法，并最终选择并深入阐述了 **Twitter 的雪花算法 (Snowflake)** 作为最佳实践。

## 2. 设计需求

文章开篇通过与面试官的对话，明确了对唯一 ID 的核心要求：

* **唯一性**：ID 必须是全局唯一的。
* **可排序性**：ID 需要按时间大致递增，可以进行排序。
* **数值类型**：ID 必须是纯数字。
* **长度限制**：ID 长度应为 64 位。
* **高性能**：系统需要支持每秒生成超过 10,000 个 ID。

## 3. 方案对比分析

文章对比了四种不同的 ID 生成方案：

1. **多主复制 (Multi-master replication)**
    * **原理**：利用数据库的 `auto_increment` 特性，但步长设置为数据库服务器的数量 `k`。
    * **优点**：可以随数据库服务器数量扩展。
    * **缺点**：难以跨数据中心扩展、ID 在多服务器间不随时间增长、增删服务器困难。

2. **通用唯一标识符 (UUID)**
    * **原理**：一个 128 位的数字，冲突概率极低，可由各服务器独立生成。
    * **优点**：生成简单，无需协调，易于扩展。
    * **缺点**：长度为 128 位（不满足 64 位要求）、ID 不随时间递增、可能包含非数字字符。

3. **Ticket 服务器**
    * **原理**：使用一个中心化的数据库服务器来生成自增 ID。
    * **优点**：实现简单，ID 是纯数字，适用于中小型应用。
    * **缺点**：存在**单点故障**，若要实现高可用，会引入数据同步的复杂性。

4. **推特雪花算法 (Twitter Snowflake)**
    * **原理**：这是一种分而治之的策略，将一个 64 位的 ID 拆分成几个部分。这是文章最终采纳的方案。
    * **优点**：满足所有设计要求，可扩展性强，在分布式环境中表现优异。

## 4. 雪花算法 (Snowflake) 深度解析

文章详细解释了雪花算法生成的 64 位 ID 的构成：

![](<https://github.com/Admol/SystemDesign/raw/main/images/chapter7/figure7-5.jpg>)

* **1 位符号位**：始终为 0，保留字段。
* **41 位时间戳**：记录自一个特定“纪元”（epoch）以来的毫秒数。
    * 这使得 ID 能够按时间排序。
    * 41 位最多可以使用约 69 年，可以通过设置较近的纪元时间来推迟溢出。
* **5 位数据中心 ID**：允许部署在 $2^5 = 32$ 个数据中心。
* **5 位机器 ID**：允许每个数据中心部署 $2^5 = 32$ 台机器。
* **12 位序列号**：用于区分同一毫秒、同一机器上生成的不同 ID。
    * 每毫秒重置为 0。
    * 允许每台机器每毫秒最多生成 $2^{12} = 4096$ 个 ID。

## 5. 总结与延伸思考

文章最后总结，雪花算法是满足所有需求的最佳方案。同时，也提出了一些需要进一步考虑的要点：

* **时钟同步**：该设计强依赖于服务器时钟的一致性。实际应用中需要使用网络时间协议 (NTP) 等技术来同步时钟。
* **各部分长度调整**：可以根据具体业务需求调整时间戳、机器 ID、序列号等部分的位数。例如，如果并发量不大但希望系统使用更久，可以增加时间戳位数，减少序列号位数。
* **高可用性**：ID 生成器作为关键任务系统，必须保证高可用。

总的来说，这篇文章清晰地介绍了在分布式系统中设计唯一 ID 生成器的思考过程，从需求分析到方案选型，再到对最终方案的深入剖析，逻辑严谨，内容详实，是一篇优秀的系统设计学习材料。