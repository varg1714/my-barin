---
source:
  - "[[阅读中/文章列表/系统设计面试：内幕指南/第15章：设计 Google Drive]]"
create: 2025-10-16
---

## 1. 需求分析与范围界定 (Requirement Analysis)

在设计开始前，首先明确系统的核心功能和约束。

**核心功能 (Core Features):**
* **文件上传/下载**：支持任意类型的文件，最大 10GB。
* **文件同步**：在一个设备上的修改能自动同步到其他设备。
* **文件修订历史 (Versioning)**：可以查看和恢复文件的历史版本。
* **文件共享**：与他人共享文件。
* **实时通知**：当文件被编辑、删除或共享时，发送通知。

**非功能性需求 (Non-Functional Requirements):**
* **高可靠性 (Reliability)**：数据绝不能丢失。
* **高可用性 (High Availability)**：系统在部分组件故障时仍能正常服务。
* **高性能 (Performance)**：同步速度快，上传下载延迟低。
* **可扩展性 (Scalability)**：能支持千万级日活用户 (10M DAU) 和 PB 级的数据存储。
* **带宽优化 (Bandwidth Efficiency)**：尽量减少网络数据传输量。

**关键指标估算 (Estimation):**
* **用户量**：5000 万注册用户，1000 万日活 (DAU)。
* **存储总量**：$5000万 \times 10GB = 500PB$。
* **上传 QPS**：约 240 QPS，峰值约 480 QPS。

## 2. 高层设计与演进 (High-Level Design & Evolution)

系统设计从一个简单的单体架构逐步演进为一个复杂的分布式系统。

### 2.1 演进过程

1. **单服务器架构**：最初，所有功能（Web 服务、数据库、文件存储）都部署在一台服务器上。这种架构简单但存在**单点故障**和**扩展性瓶颈**。
2. **引入分布式组件**：
    * **文件存储 -> Amazon S3**：为了解决存储容量和数据丢失的风险，将文件存储迁移到专业的对象存储服务如 Amazon S3。S3 提供了高持久性、高可用性和跨区域复制能力。
    * **数据库分离与分片**：将元数据数据库独立出来，并进行分片（Sharding）以支持海量数据。
    * **Web 服务器集群与负载均衡**：在 Web 服务器前增加负载均衡器（Load Balancer），并部署多个 Web 服务器实例，以提高可用性和处理能力。

### 2.2 最终高层架构

![](https://github.com/Admol/SystemDesign/raw/main/images/chapter15/figure15-10.png)

* **API 服务器 (API Servers)**：处理用户认证、元数据管理等核心业务逻辑（除文件上传外）。
* **元数据数据库 (Metadata Database)**：存储文件的元信息，如文件名、大小、版本、所有者以及构成文件的**块信息**。
* **块服务器 (Block Servers)**：处理文件上传的重活，负责**分块、压缩、加密**。
* **云存储 (Cloud Storage / S3)**：实际存储文件**块**的地方。
* **通知服务 (Notification Service)**：通过长轮询（Long Polling）实时通知客户端文件变更。
* **负载均衡器 (Load Balancer)**：分发流量到 API 服务器和块服务器。
* **其他组件**：元数据缓存、冷存储、离线备份队列等。

### 2.3 核心概念：分块存储 (Block Storage)

这是整个设计的基石，也是我们之前讨论的重点。

* **工作原理**：
    1. **上传时拆分**：大文件在上传时，由**块服务器**将其拆分成多个固定大小（如 4MB）的**块 (Block)**。
    2. **独立存储**：每个块被视为一个独立的对象，经过压缩和加密后，存储在 S3 中。
    3. **元数据记录**：文件的元数据中会记录它由哪些块、以何种顺序组成。
    4. **下载时拼接**：下载时，客户端先获取元数据，然后从 S3 下载所有必需的块，最后在本地按顺序拼接成完整文件。

* **核心优势**：
    * **增量同步**：当文件被修改时，只需上传发生变化的块，极大节省了带宽。
    * **数据去重 (Deduplication)**：如果不同文件或版本包含相同的块（哈希值相同），在 S3 中只需存储一份，节省了大量存储空间。

### 2.4 同步冲突处理 (Sync Conflict Resolution)

* **策略**：“先到先得”（First-in wins）。
* **处理方式**：当两个用户同时修改同一文件，服务器先处理完的请求成功。后到达的请求会失败，系统会向该用户提示冲突，并提供服务器上的最新版本和用户的本地版本，让用户选择合并或覆盖。

## 3. 深入设计 (Deep Dive)

### 3.1 块服务器 (Block Servers)

* **职责**：分块、压缩（如 gzip）、加密。
* **优化**：通过**增量同步**和**压缩**来最小化网络流量。只传输被修改和压缩后的块。

### 3.2 元数据数据库 (Metadata Database)

* **选型**：选择关系型数据库（如 MySQL），因为它原生支持**ACID**，可以轻松实现元数据操作的**强一致性**。
* **核心表结构**：
    * `User`: 用户信息。
    * `Device`: 用户设备信息，用于推送通知。
    * `File`: 最新版本的文件信息。
    * `File_version`: 文件的历史版本记录（只读）。
    * `Block`: 文件块的信息，包含哈希值和存储路径。

### 3.3 上传与下载流程

* **上传流程 (Upload Flow)**：
    1. 客户端**并行**发起两个请求：
        * **请求 1 (元数据)**：通知 API 服务器要上传新文件，API 服务器在数据库中创建一条状态为 `pending` 的元数据记录。
        * **请求 2 (文件内容)**：将文件发送给**块服务器**。
    2. 块服务器对文件进行分块、压缩、加密，然后上传到 S3。
    3. 上传完成后，S3 回调 API 服务器，API 服务器将数据库中的文件状态更新为 `uploaded`。
    4. **通知服务**将文件状态的变更（`pending` -> `uploaded`）通知给其他相关客户端。

* **下载流程 (Download Flow)**：
    1. 客户端通过**通知服务**得知文件有更新。
    2. 客户端向 API 服务器请求最新的**文件元数据**。
    3. 客户端根据元数据中记录的**块列表**，向块服务器（或直接向 S3）请求下载所有必需的块。
    4. 客户端在本地将下载的块**拼接**成完整文件。

### 3.4 通知服务 (Notification Service)

* **目的**：让客户端实时感知文件的变化。
* **技术选型**：**长轮询 (Long Polling)**。
    * **原因**：对于 Google Drive 这种场景，通信主要是单向的（服务器 -> 客户端），且数据不是高频突发，长轮询比 WebSocket 更轻量、简单。
    * **工作方式**：客户端向服务器发起一个长时间等待的 HTTP 请求。服务器持有该连接，直到有事件发生（如文件变更）才返回响应。客户端收到响应后立即发起下一个长轮询请求。

### 3.5 存储空间优化 (Storage Saving)

* **数据去重 (Deduplication)**：在账户或全局级别，对拥有相同哈希值的块只存储一份。
* **智能备份策略**：
    * 限制版本数量，删除最旧的版本。
    * 只保留有价值的版本，例如对于频繁修改的文件，可以降低版本保存的频率。
* **冷存储 (Cold Storage)**：将长期不活跃的数据迁移到更便宜的存储介质中（如 Amazon S3 Glacier）。

### 3.6 故障处理 (Fault Handling)

* **无状态服务 (API Server, Block Server)**：通过负载均衡器将流量重定向到其他健康节点。
* **有状态服务 (Database, Cache)**：采用主从复制（Master-Slave Replication）和多副本策略。主节点故障时，从节点提升为新主节点。
* **云存储 (S3)**：本身已具备跨区域复制和高可用性。
* **通知服务**：服务器故障会导致大量长轮询连接断开，客户端需要有重连机制，连接到其他可用的通知服务器。

## 4. 总结与权衡 (Conclusion & Trade-offs)

* **设计核心**：该设计的精髓在于通过**分块存储**和**增量同步**，在保证**强一致性**的同时，实现了高效的同步和存储。
* **设计权衡**：
    * **客户端上传 vs. 服务器端上传**：
        * **方案**：让客户端直接分块并上传到 S3，而不是通过块服务器。
        * **优点**：上传速度更快（少一跳网络传输）。
        * **缺点**：分块、压缩、加密的逻辑需要在所有客户端（iOS, Android, Web）上重复实现，维护成本高且不安全（客户端易被破解）。
    * 因此，文章中的设计（通过**块服务器**集中处理）是更稳健的选择。