---
source:
  - "[[第14章：设计 YouTube]]"
create: 2025-10-15
---

## 1. 需求分析与范围界定 (Step 1)

**1. 核心功能:**
* 用户能够上传视频。
* 用户能够观看视频。

**2. 关键非功能性需求:**
* **高可用性、可扩展性、可靠性**：系统必须稳定，能应对海量用户和数据增长。
* **低延迟**：视频上传和播放必须快速、流畅。
* **低成本**：尤其需要关注存储和 CDN 带宽成本。
* **多客户端支持**：移动端、Web 浏览器、智能电视。
* **国际化**：支持全球用户。
* **安全**：需要加密和版权保护。

**3. 粗略估算 (Back-of-the-envelope estimation):**
* **日活用户 (DAU)**: 500 万
* **日均视频观看量**: 5 个/人
* **日均上传用户比例**: 10%
* **平均视频大小**: 300MB
* **每日新增存储**: $500万 \times 10\% \times 300MB = 150 TB/天$
* **每日 CDN 成本估算**: $500万 \times 5个视频 \times 0.3GB \times \$0.02/GB = \$150,000/天$
* **核心结论**: **CDN 成本是系统开销的主要部分**，必须进行优化。

## 2. 高层架构设计 (Step 2)

系统整体分为三个主要部分：

![高层架构](https://github.com/Admol/SystemDesign/raw/main/images/chapter14/figure14-3.jpg)

1. **客户端 (Client)**: 用户交互的界面，如手机 App、网页等。
2. **CDN (内容分发网络)**: 缓存并向用户分发视频流，是保证流畅播放的关键。
3. **API 服务器 (Backend)**: 处理除视频流之外的所有业务逻辑，如用户认证、元数据管理、上传请求处理、推荐等。

### 2.1. 视频上传流程

这是一个由多个组件协作的复杂流程，被分解为两个并行执行的过程：**上传视频文件**和**更新元数据**。

![视频上传流程概览](https://github.com/Admol/SystemDesign/raw/main/images/chapter14/figure14-4.jpg)

**组件说明:**
* **元数据数据库/缓存**: 存储视频信息（标题、大小、格式、URL 等）。
* **原始存储 (Original Storage)**: Blob 存储，用于存放用户上传的原始视频文件。
* **转码服务器 (Transcoding Servers)**: 将原始视频转换为多种格式和分辨率。
* **转码存储 (Transcoded Storage)**: Blob 存储，用于存放转码后的视频文件。
* **完成队列/处理器**: 使用消息队列解耦，当转码完成后，通知后端更新数据库和缓存。

**流程分解:**
1. **上传视频文件 (Process 1)**:
    * 用户视频上传至**原始存储**。
    * **转码服务器**从原始存储拉取视频进行转码。
    * 转码完成后，视频被存入**转码存储**，并分发至 **CDN**。
    * 同时，一个“转码完成”事件被推入**完成队列**。
    * **完成处理器**消费该事件，更新**元数据数据库**，标记视频为“可播放”。
2. **更新元数据 (Process 2)**:
    * 在上传视频的同时，客户端向 **API 服务器**发送请求，更新视频的标题、描述等元数据。

### 2.2. 视频流媒体流程

![视频流媒体流程](https://github.com/Admol/SystemDesign/raw/main/images/chapter14/figure14-7.jpg)

* **核心思想**: 流媒体 (Streaming) 不是下载整个文件，而是边下载边播放。客户端持续从服务器接收一小段一小段的视频流。
* **流媒体协议**: 控制数据传输的标准化方式，如 `MPEG-DASH`, `Apple HLS` 等。它们支持自适应码率，能根据网络状况自动切换清晰度。
* **播放流程**: 视频直接从离用户最近的 **CDN 边缘节点**进行流式传输，以实现最低延迟。

## 3. 深度设计：视频转码 (Step 3)

视频转码是整个系统中最核心、最复杂的环节之一。

### 3.1. 为什么需要转码？

* **节省存储空间**: 原始视频文件通常非常大。
* **兼容性**: 不同设备和浏览器支持的视频格式不同。
* **自适应码率流 (Adaptive Bitrate Streaming)**: 为不同网络条件的用户提供不同分辨率（如 1080p, 720p），保证流畅播放。

### 3.2. 有向无环图 (DAG) 模型

为了灵活、并行地处理复杂的转码任务（如提取音频、加水印、生成缩略图等），系统采用 DAG 模型来定义任务流程。

![DAG 模型示例](https://github.com/Admol/SystemDesign/raw/main/images/chapter14/figure14-8.jpg)

### 3.3. 视频转码架构

![视频转码架构](https://github.com/Admol/SystemDesign/raw/main/images/chapter14/figure14-10.jpg)

1. **预处理器 (Preprocessor)**:
    * **视频分割**: 将视频流拆分为更小的、可独立播放的**图片组 (GOP)**。这是实现大规模并行的关键。
    * **DAG 生成**: 根据配置文件生成任务图。
    * **数据缓存**: 将 GOP 和元数据存入临时存储，用于失败重试。

2. **DAG 调度器 (DAG Scheduler)**: 将 DAG 图分解为具体的任务阶段，并放入任务队列。
3. **资源管理器 (Resource Manager)**: 负责高效地将任务队列中的任务分配给最合适的任务工作者。
4. **任务工作者 (Task Workers)**: 实际执行转码、加水印等具体任务的计算单元。
5. **临时存储 (Temporary Storage)**: 存放转码过程中的中间数据（如 GOP），提高容错性。
6. **编码后的视频 (Encoded Video)**: 最终的输出产物，如 `funny_720p.mp4`。

### 3.4. 核心概念深度解析：图片组 (GOP) 与 .ts 文件

这是我们对话中深入探讨的部分，是理解视频流媒体的关键。

| 概念            | 描述                                                                                                       |
| :------------ | :------------------------------------------------------------------------------------------------------- |
| **图片组 (GOP)** | **逻辑单元**：视频压缩数据流的内部结构，由一个完整的关键帧（I 帧）和若干个只记录变化量的帧（P/B 帧）组成。它是一个可以**独立解码和播放**的最小视频片段。                      |
| **.ts 文件**  | **物理文件**：一种名为 "MPEG Transport Stream" 的容器格式，用于封装视频、音频数据。它是 **HLS (HTTP Live Streaming) 协议**中视频分片的标准文件格式。 |

**关系与流程:**
1. **为何在预处理阶段拆分 GOP？**
    * **实现并行化**：将大视频拆成多个独立的 GOP，就可以将这些 GOP 分发给成百上千个任务工作者同时处理，极大缩短总转码时间。
    * **提高容错性**：如果某个 GOP 转码失败，只需重试这一个几秒钟的小片段，而无需重做整个视频。
2. **GOP 如何变成 .ts 文件？**
    * 在转码过程中，当目标是生成 HLS 流时，转码器会以 **GOP 的边界**为切割点，将视频流切成一个个时长几秒的片段。
    * 然后，每个片段被封装成一个独立的 `.ts` 文件。
    * 最终，转码会产出一系列 `.ts` 文件和一个 `.m3u8` 索引文件（播放列表），播放器通过该索引文件按顺序请求 `.ts` 文件进行播放。
3. 图片组 (GOP) 的大小是相同的吗？
    不相同：
    
    - **逻辑时长 vs. 物理大小**：一个 GOP 通常代表一个固定的**播放时长**（例如 2 秒），但它的**文件大小**（KB/MB）是动态变化的。
    - **原因**：GOP 的大小取决于其内部画面的**复杂度**。一个包含静态、变化不大的画面的 GOP 会很小；而一个包含激烈动作、色彩丰富的画面的 GOP 会大得多。
4. `.ts` 文件的大小是相同的吗？
    不相同：
    
    - **`.ts` 文件是 GOP 的容器**：在 HLS 流媒体中，一个 `.ts` 文件通常包含一个或多个完整的 GOP。
    - **原因**：由于 `.ts` 文件所包含的 GOP 大小是可变的，因此 `.ts` 文件本身的大小也是可变的。它们通常被设置为固定的**播放时长**（如 2 秒、6 秒或 10 秒），但文件大小会随内容变化。
5. 播放器如何精准定位到视频的任意时间点？
    视频的快进和后退（Seeking）不依赖于对单个大文件进行 `range` 请求，而是通过 HLS 协议中的 **`.m3u8` 索引文件** 来实现的。这个过程分为两步：
    
    1. **宏观定位（通过 `.m3u8` 文件）**
        
        - 播放器首先获取 `.m3u8` 播放列表，其中记录了所有 `.ts` 分片的顺序和各自的时长。
        - 当用户拖动进度条到一个时间点时（例如 15 分 30 秒），播放器会通过累加时长，快速计算出该时间点位于哪个 `.ts` 文件中。
        - 然后，播放器会直接发起 HTTP 请求，下载那个特定的 `.ts` 文件。
    2. **微观定位（在 `.ts` 文件内部）**
        
        - 下载完目标 `.ts` 文件后，播放器从该文件的开头（总是一个可独立解码的 I 帧）开始解码。
        - 它会快速处理（但不渲染）帧数据，直到达到用户指定的精确时间点（例如，在该分片的第 3 秒），然后才开始将画面显示出来。

    这个“先定位分片，再在分片内定位”的机制，结合了 GOP 的独立解码特性，实现了高效流畅的视频拖动体验。

## 4. 系统优化

### 4.1. 速度优化

* **并行上传**: 客户端在上传前就将视频按 GOP 分割，并行上传多个分片。
* **就近上传**: 在全球部署多个上传中心（可利用 CDN），让用户上传到最近的服务器。
* **消息队列解耦**: 在处理流程的各个阶段之间使用消息队列，使各模块可以独立、并行地工作，避免相互等待。

### 4.2. 安全优化

* **预签名上传 URL (Pre-signed URL)**: 客户端先向 API 服务器申请一个有时效性、有权限的上传 URL，然后使用该 URL 直接将文件上传到云存储。这避免了文件数据流经后端服务器，且保证了上传的安全性。
* **视频内容保护**:
    * **DRM (数字版权管理)**: 如 Google Widevine, Apple FairPlay。
    * **AES 加密**: 对视频内容进行加密，只有授权用户才能获取密钥解密播放。
    * **视频水印**: 在视频上叠加版权信息图像。

### 4.3. 成本节约优化

* **分析视频流行度**: 视频访问遵循**长尾分布**（少数热门视频占据绝大部分播放量）。
* **分级存储/服务**:
    * **热门视频**: 存储在 CDN，保证最佳播放体验。
    * **冷门视频**: 存储在成本更低的视频服务器上，不推送到 CDN，或只在用户首次请求时再推送到 CDN。
* **按需编码**: 对于不热门的视频，可以不预先转码所有格式，而是在首次请求时再进行转码。
* **自建 CDN**: 对于超大规模的流媒体公司（如 Netflix），与 ISP 合作自建 CDN 网络，长期来看可以节约巨大成本。

## 5. 错误处理

* **可恢复错误** (如单个视频分片转码失败): 进行有限次数的重试。
* **不可恢复错误** (如视频格式损坏): 停止任务，并向客户端返回错误。
* **组件故障处理**:
    * **API 服务器/任务工作者 (无状态)**: 故障时，负载均衡器将请求重定向到其他健康节点。
    * **数据库/缓存 (有状态)**: 采用主从复制和副本。主节点宕机，从节点提升为新主节点。

## 6. 总结与扩展 (Step 4)

* **直播 (Live Streaming)**: 与点播（VOD）相比，直播对延迟要求更高，可能需要不同的流媒体协议（如 WebRTC），且错误处理策略更严格（不能长时间重试）。
* **视频下架**: 系统需要有机制处理侵权、违规视频，可以通过自动检测或用户举报实现。