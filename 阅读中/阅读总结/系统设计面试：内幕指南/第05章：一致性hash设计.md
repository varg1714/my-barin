---
source: "[[阅读中/文章列表/系统设计面试：内幕指南/第05章：一致性hash设计|第05章：一致性hash设计]]"
create: 2025-09-19
---

## 1. 核心问题：为什么需要一致性哈希？

在分布式系统中，我们常常需要将数据或请求分散到多个服务器上。传统方法是使用简单的取模运算：

$serverIndex = hash(key) \mod N$

其中 `N` 是服务器的数量。

**这种方法的致命缺陷（再哈希问题）**：
当服务器数量 `N` 发生变化时（增加或移除服务器），几乎所有 `key` 的计算结果都会改变，导致大规模的数据迁移。这会引发缓存雪崩、数据库压力剧增等问题，使得系统扩展性极差。

## 2. 一致性哈希的核心原理

一致性哈希通过构建一个抽象的“哈希环”来解决再哈希问题，使得节点增删只影响局部数据。

### 2.1. 哈希空间与哈希环

1. **哈希空间**：选择一个哈希函数（如 SHA-1），其输出范围是一个巨大的数字空间（例如 0 到 $2^{160}-1$）。
2. **哈希环**：将这个线性的哈希空间想象成一个首尾相连的环。

![哈希环](https://github.com/Admol/SystemDesign/raw/main/images/chapter5/figure5-4.jpg)

### 2.2. 服务器与键的映射

-  **映射服务器**：使用相同的哈希函数，对每个服务器的唯一标识（如 IP 地址或名称）进行哈希计算，将得到的值作为服务器在环上的位置。
-  **映射数据键**：对数据的 `key` 进行哈希计算，同样得到一个在环上的位置。

### 2.3. 数据定位：顺时针查找

要确定一个 `key` 应该存储在哪个服务器上，规则是：**从 `key` 在环上的位置开始，沿顺时针方向寻找，遇到的第一个服务器节点即为目标服务器。**

![服务器查找](https://github.com/Admol/SystemDesign/raw/main/images/chapter5/figure5-7.jpg)

## 3. 动态节点管理的优势

一致性哈希的最大优点在于处理服务器节点数量变化时的表现。

-  **添加服务器**：当一个新服务器（如 `s4`）加入环中时，只有落在它与它**逆时针方向**上第一个服务器（`s3`）之间的数据需要被重新分配到新服务器 `s4` 上。其他服务器上的数据完全不受影响。
-  **移除服务器**：当一个服务器（如 `s1`）被移除时，原本属于它的数据会根据“顺时针查找”规则，自动重新映射到它**顺时针方向**上的下一个服务器（`s2`）。同样，影响范围也仅限于被移除节点的数据。

## 4. 挑战与优化：虚拟节点 (Virtual Nodes)

基本的哈希算法存在两个主要问题：

1. **分区大小不均**：服务器在环上随机分布，可能导致某些服务器负责的哈希空间（分区）远大于其他服务器。
2. **数据分布不均（热点问题）**：即使分区大小均匀，数据的哈希结果也可能集中在某个小范围，导致少数服务器负载过高。

**解决方案：虚拟节点**：

为每个物理服务器（真实节点）在环上创建多个虚拟节点。例如，`server0` 可以由 `s0_0, s0_1, s0_2` 等多个虚拟节点代表。

![虚拟节点](https://github.com/Admol/SystemDesign/raw/main/images/chapter5/figure5-12.jpg)

**好处**：
-  **负载均衡**：虚拟节点数量越多，每个物理服务器在环上的位置就越多，数据和请求被更均匀地分散到所有物理服务器上。
-  **高可用性**：当一个物理节点下线时，它所对应的多个虚拟节点会同时失效，其上的负载会平滑地分散给环上其他多个物理节点，而不是全部压给顺时针的下一个节点。

## 5. 代码层面的设计与实现方案

将理论落地到代码，我们需要关注具体的数据结构和操作流程。

| 功能点 | 设计方案 | 关键代码/逻辑 |
| :--- | :--- | :--- |
| **模拟哈希环** | 使用**有序字典/树**，如 Java 的 `TreeMap` 或 C++ 的 `std::map`。Key 是哈希值（`Long` 或 `uint`），Value 是虚拟节点标识符（`String`）。 | `TreeMap<Long, String> ring;` |
| **节点映射** | 1. 为每个物理节点生成多个唯一的虚拟节点 ID（如 `"IP#1"`）。<br>2. 计算每个虚拟节点 ID 的哈希值。<br>3. 将 `(hash, virtualNodeId)` 存入 `TreeMap`。 | `ring.put(hash(virtualNodeId), virtualNodeId);` |
| **数据查找** | 1. 计算数据 `key` 的哈希值 `dataHash`。<br>2. 在 `TreeMap` 中查找**第一个大于或等于** `dataHash` 的节点。<br>3. 如果找不到（即 `dataHash` 大于所有节点），则**回绕**到环的起点，取 `TreeMap` 的第一个节点。 | `Map.Entry<Long, String> entry = ring.ceilingEntry(dataHash);`<br>`if (entry == null) { entry = ring.firstEntry(); }` |
| **虚拟-物理节点关系** | 使用一个**哈希表**，如 `HashMap`，独立维护虚拟节点 ID 到物理节点对象（包含 IP、连接池等）的映射。 | `Map<String, PhysicalNode> virtualToPhysicalMap;` |
| **节点动态增/删** | **增加**：循环创建虚拟节点，同时更新 `TreeMap` 和 `HashMap`。<br>**移除**：根据物理节点信息，生成其所有虚拟节点 ID，然后从 `TreeMap` 和 `HashMap` 中逐一删除。 | `ring.remove(hash);`<br>`virtualToPhysicalMap.remove(virtualNodeId);` |

**完整查找流程**：
1. 客户端提供数据 `key`。
2. 通过 `TreeMap` 查找到对应的**虚拟节点 ID**。
3. 使用该虚拟节点 ID 在 `HashMap` 中查找到对应的**物理节点对象**。
4. 获取物理节点的连接信息，发起请求。

## 6. 数据迁移的实现

当节点发生变动时，需要确定受影响的数据范围以进行迁移。

-  **添加节点 `s_new`**：受影响的数据范围是 `s_new` 与其**逆时针方向**第一个节点 `s_prev` 之间的区域 `(s_prev, s_new]`。需要将这部分数据从 `s_new` 的顺时针节点迁移到 `s_new`。
-  **移除节点 `s_removed`**：受影响的数据是原本分配给 `s_removed` 的部分。这些数据需要迁移到 `s_removed` **顺时针方向**的第一个节点 `s_next`。

## 7. 总结与应用

**一致性哈希的优点**：
-  **最小化数据迁移**：节点增删时，只有少量数据需要重新映射。
-  **良好的水平扩展性**：可以平滑地增加或减少服务器数量。
-  **缓解热点问题**：通过虚拟节点技术，数据分布更均匀，避免单点过载。

**现实世界应用**：
-  Amazon DynamoDB、Apache Cassandra 的数据分区。
-  Discord 聊天应用的用户状态路由。
-  Akamai CDN 的内容缓存。
-  Google Maglev 网络负载均衡器。