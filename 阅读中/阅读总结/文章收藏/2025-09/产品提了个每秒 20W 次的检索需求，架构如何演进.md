---
source: "[[产品提了个每秒 20W 次的检索需求，架构如何演进？（第 97 讲，收藏）]]"
create: 2025-09-30
---

文章的核心思想是，架构并非一步到位，而是随着业务需求（特别是数据量和并发量）的增长而逐步演进的。作者将这个过程分为了四个阶段：

## 1. 原始阶段 - LIKE 查询

这是最简单、最快速的实现方式，在创业初期非常常见。

* **实现方式：** 直接在数据库中使用 SQL 的 `LIKE '%keyword%'` 进行模糊匹配。
* **优点：** 实现简单快速。
* **缺点：**
    * **效率极低：** 需要全表扫描，并发高时会导致 CPU 飙升。
    * **功能有限：** 不支持分词，无法满足复杂的搜索需求。

## 2. 初级阶段 - 全文索引

为了解决 `LIKE` 查询的性能问题，可以利用数据库自带的全文索引功能。

* **实现方式：** 在数据库表的相关字段上（如 `title`, `content`）建立全文索引 (`FULLTEXT index`)。
* **优点：**
    * **性能提升：** 通过倒排索引，避免了全表扫描，性能远高于 `LIKE`。
    * **支持分词：** 满足了基本的搜索需求。
    * **架构改动小：** 无需引入新的外部系统。
* **缺点：**
    * **耦合度高：** 搜索和常规的增删改查（CURD）请求耦合在同一个数据库中，会相互影响。
    * **性能瓶颈：** 数据量达到百万级别后，性能会显著下降。
    * **扩展性差：** 难以水平扩展。

## 3. 中级阶段 - 开源外置索引

当数据量和并发量进一步增长（千万级别），就需要将索引功能从数据库中分离出来，使用专门的搜索引擎。

* **核心思路：** 索引数据与原始数据分离，前者满足搜索需求，后者满足 CURD 需求。
* **实现方式：** 引入开源搜索引擎，如 Solr、Lucene，目前最流行的是 **Elasticsearch (ES)**。
* **ES 的优势：**
    * 它是一个基于 Lucene 内核的、提供 RESTful 接口的服务，屏蔽了 Lucene 的复杂性。
    * 天然支持集群，易于实现高可用、水平扩展和负载均衡。
    * 能够支持 10 亿级别的数据量和数千级别的并发量。

## 4. 高级阶段 - 自研搜索引擎

当数据量达到百亿级别，并发量达到每秒十万级别，并且有高度定制化的业务需求时，开源方案可能无法满足，需要走上自研的道路。

* **设计重点：** 极致的扩展性，目标是“增加机器就能扩容”。
* **文章中的架构示例 (E-search)：**
    * **接入集群 (Proxy)：** 无状态，负责接收请求，易于水平扩展。
    * **逻辑集群 (Merger)：** 无状态，负责合并检索结果、打分排序等业务逻辑，易于水平扩展。
    * **检索集群 (Searcher)：** 核心数据和检索服务层。
        * **数据容量扩展：** 通过对索引数据进行水平切分（Sharding）来解决。
        * **并发性能扩展：** 通过为每个数据分片创建多个副本（Replica）来解决。

## 5. 总结

这篇文章清晰地描绘了一条从简单到复杂的搜索架构演进路线图。它强调了**“思路比结论更重要”**，即架构师需要根据业务所处的不同阶段，选择最合适的技术方案，而不是盲目追求高大上的架构。