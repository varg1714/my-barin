---
source: "[[哈罗面试：有个 redis 大 key 需要在线优化_ 不能影响现有业务， 怎么优化？]]"
create: 2025-09-12
---

## 1. 文章核心内容分析

### 1.1. 什么是 Big Key？

文章首先明确了 Big Key 的定义：并非指 Key 本身大，而是指 **Key 对应的 Value 过大**。这包括两种情况：

*   **单个 Value 体积过大**：例如一个 String 类型的 Key，其 Value 达到了 5MB。
*   **集合类型成员过多**：例如一个 Hash、List 或 ZSET 类型的 Key，其成员数量达到上万个。

### 1.2. Big Key 的成因与危害

文章分析了 Big Key 产生的常见场景，如数据结构使用不当、垃圾数据未清理、业务预估不足以及热点事件（如网红粉丝列表）等。其主要危害包括：

*   **阻塞请求**：Redis 是单线程模型，操作 Big Key 会耗费较长时间，阻塞后续请求。
*   **内存增大**：可能引发 OOM (内存溢出) 或导致重要 Key 被内存淘汰策略逐出。
*   **网络阻塞**：读取 Big Key 会占用大量网络带宽。
*   **影响主从同步**：删除一个巨大的 Key 可能导致主库长时间阻塞，影响主从同步。

### 1.3. 在线优化方案（核心）

这是文章的重点，提供了一个六步走的平滑迁移方案，确保在优化过程中不影响线上业务：

| 步骤                   | 操作                                                                                       | 关键点                                                                                    |
| :------------------- | :--------------------------------------------------------------------------------------- | :------------------------------------------------------------------------------------- |
| **Step 1: 大 Key 拆分** | 将一个大 Key（如 `user:info:all`）按业务逻辑（如用户 ID 哈希）拆分成多个小 Key（如 `user:info:0` 到 `user:info:99`）。 | 这是解决问题的根本思路，化整为零。                                                                      |
| **Step 2: 同步双写**     | 修改应用代码，在执行写操作时，同时写入新 Key 和老 Key。                                                         | 保证在迁移过程中，新老数据的一致性，为后续切换做准备。                                                            |
| **Step 3: 渐进式迁移**    | 编写后台脚本，使用 `HSCAN` 命令分批次、小批量地将老 Key 中的数据迁移到对应的新 Key 中。                                    | **强调不能使用 `HGETALL`**，因为它会一次性加载所有数据，导致 Redis 阻塞。`HSCAN` 可以无阻塞地迭代数据。                     |
| **Step 4: 灰度切换**     | 数据迁移完成后，通过配置中心等方式，逐步将读请求从老 Key 切换到新 Key（例如，从 10% 流量开始，逐步增加到 100%）。                       | 包含**兜底设计**：当新 Key 查询不到时，先查老 Key，再查数据库，防止缓存穿透。                                          |
| **Step 5: 非阻塞删除**    | 确认所有读写流量都已切换到新 Key 后，使用 `UNLINK` 命令异步删除老 Key。                                            | **强调不能使用 `DEL`**，因为它会同步阻塞 Redis。对于特别巨大的 Key，甚至可以先用 `HSCAN` + `HDEL` 分批清空内容，最后再删除空 Key。 |
| **Step 6: 监控与回滚**    | 在整个过程中，实时监控 Redis 性能指标和业务指标，并准备好回滚预案（如通过配置中心一键切回老 Key）。                                  | 确保整个过程的安全可控。                                                                           |

## 2. 总结

这篇文章不仅回答了一个面试题，更提供了一套在生产环境中处理类似问题的成熟解决方案。其核心思想是 **“拆分、双写、渐进、灰度、监控”**，通过一系列精细化的操作，将一个高风险的变更过程分解为多个低风险、可控、可回滚的步骤，最终实现对 Redis 大 Key 的平滑、无感优化。

文章中反复强调**避免使用阻塞性命令**（如 `HGETALL`, `DEL`）并采用其非阻塞替代方案（如 `HSCAN`, `UNLINK`），这是 Redis 运维中的一个重要实践原则。