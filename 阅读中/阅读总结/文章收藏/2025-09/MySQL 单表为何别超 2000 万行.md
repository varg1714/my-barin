---
source: "[[MySQL 单表为何别超 2000 万行？揭秘 B + 树与 16KB 页的生死博弈｜得物技术]]"
create: 2025-09-30
---

## 1. 核心论点分析

文章的核心在于 **B+ 树的高度** 与 **磁盘 I/O 次数** 之间的关系。

1. **存储结构**：MySQL (InnoDB) 的数据是存储在固定大小（默认为 16KB）的“页”（Page）中的。这些页通过 B+ 树的结构组织起来，形成索引。
2. **B+ 树特点**：
    * **叶子节点** (Leaf Nodes)：存储完整的行数据。
    * **非叶子节点** (Non-Leaf Nodes)：不存储行数据，只存储索引键（如主键）和指向下一层数据页的指针。这个设计使得非叶子节点可以容纳大量指针，从而拥有很高的“扇出”（Fan-out），让整棵树变得“矮胖”。
3. **性能关键**：查询一条数据需要从 B+ 树的根节点逐层向下查找，直到找到叶子节点中的数据。树的高度（层数）基本决定了查询时磁盘 I/O 的最大次数。树越矮，查询性能越高。
4. **“2000 万” 的由来**：这是一个估算值，代表了当 B+ 树的高度从 **3 层** 变为 **4 层** 时的临界数据量。
    * **3 层树**：查询最多需要 3 次磁盘 I/O。
    * **4 层树**：查询最多需要 4 次磁盘 I/O。
    * 从 3 到 4 的变化，意味着 I/O 次数增加了 33%，在高并发场景下，这会导致性能的“断崖式下跌”。

## 2. 关键计算过程拆解

文章通过一个公式来估算 B+ 树能容纳的总行数：

`单表最大行数 = (非叶子节点扇出数) ^ (树高 - 1) × (单个叶子节点页的行数)`

文章给出了一个估算示例：

1. **非叶子节点扇出数 (x)**：
    * 一个数据页大小为 16KB，除去页头页尾等元数据，可用空间约 15KB。
    * 非叶子节点存储 `主键 (bigint, 8字节)` + `页指针 (4字节)`，一条索引记录约 12 字节。
    * 扇出数 `x` ≈ 15KB / 12 字节 ≈ **1280**。

2. **单个叶子节点页的行数 (y)**：
    * 这个值取决于单行数据的大小。假设一个比较大的行，大小为 1KB。
    * 单页行数 `y` ≈ 15KB / 1KB = **15**。

3. **总行数计算**：
    * 当树高 `z=2` 时：`1280 ^ (2-1) * 15` ≈ 2 万行。
    * 当树高 `z=3` 时：`1280 ^ (3-1) * 15` ≈ **2500 万行**。

这个 **2500 万** 就是常说的 “2000 万” 建议值的理论来源。一旦超过这个数量级，B+ 树就可能需要增加到 4 层来存储数据。

## 3. 为什么 2000 万不是绝对值？

文章明确指出，这个值与 **单行数据的大小** 强相关。如果单行数据很小（例如只有 250 字节），那么一个叶子节点页可以存储约 60 行数据。在这种情况下，一个 3 层的 B+ 树可以支持近 **1 亿** 行数据，查询性能依然很高（最多 3 次 I/O）。

因此，**关键不在于具体的行数，而在于 B+ 树的高度是否会增加**。

## 4. B+ 树与 B 树的对比

文章还对比了 B+ 树和 B 树，解释了为何 MySQL 选择 B+ 树：

* **B 树**：在所有节点（包括非叶子节点）上都存储数据。这导致非叶子节点的扇出非常低，树会变得更高更瘦。
* **B+ 树**：只有叶子节点存储完整数据，非叶子节点只存索引和指针。这带来了极高的扇出，使得树的高度非常低。

结论是，在存储同样量级数据时，B+ 树的查询 I/O 次数远少于 B 树，因此更适合做数据库索引。

## 5. 总结与建议

* **核心博弈**：MySQL 通过 16KB 页和 B+ 树结构，在磁盘 I/O 效率和内存使用之间取得了精妙的平衡。
* **2000 万是警示线**：它不是一个硬性规定，而是一个基于“典型”行大小的性能拐点。当单表数据量接近这个级别时，就应该警惕 B+ 树层级增加可能带来的性能问题。
* **优化建议**：
    1. **控制行大小**：避免使用 TEXT/BLOB 等大字段，或将其分离存储。
    2. **分库分表**：在数据量达到千万级之前进行规划。
    3. **冷热分离**：将不常用的历史数据归档到其他表或数据库。

总的来说，这篇文章通过对 MySQL 底层存储结构的剖析，清晰地解释了“单表 2000 万行”这一经验法则背后的技术原理，并指出了其适用前提和局限性，具有很强的实践指导意义。