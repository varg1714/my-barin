---
source:
  - "[[理解 Go 协程调度的本质]]"
create: 2025-10-27
---

## 基础知识：为理解调度做铺垫

要理解 Goroutine 调度，首先需要明白程序执行和线程调度的基本原理。

### 1. 函数调用栈 (Stack)

* **作用**：每个正在执行的函数都有一个自己的内存区域，称为**栈帧 (Stack Frame)**，用于存储：
    * 局部变量
    * 函数参数与返回值
    * 函数返回地址（调用结束后要回到哪里）
* **关键寄存器 (AMD64)**：
    * `$rsp$` (Stack Pointer): 始终指向**栈顶**（低地址）。
    * `$rbp$` (Base Pointer): 指向当前函数栈帧的**栈底**（高地址）。
    * `$ip$` (Instruction Pointer): 指向下一条要执行的指令的内存地址。
* **核心概念**：函数调用就是栈帧的入栈 (Push)，函数返回就是出栈 (Pop)。CPU 通过 `ip` 寄存器顺序执行指令，通过 `rsp` 和 `rbp` 管理栈内存。

### 2. 操作系统线程调度

* **本质**：线程是操作系统调度的基本单位。调度可以简单理解为**上下文切换**。
* **上下文切换过程**：
    1. **保存当前线程上下文**：将 CPU 的寄存器（如 `ip`, `sp`, `bp` 及通用寄存器）的值保存到该线程的内存区域中。
    2. **选择下一个线程**：根据调度算法（如时间片轮转）选择一个就绪的线程。
    3. **恢复新线程上下文**：将新线程之前保存的寄存器值加载回 CPU 的寄存器中。
* **核心**：线程调度的核心就是**保存和恢复 CPU 寄存器的值**，这使得 CPU 的控制权从一个线程的执行流“跳转”到另一个线程的执行流。这个过程需要陷入内核，开销较大（微秒级）。

## Go 调度器模型：从 GM 到 GMP

Go 在操作系统线程之上实现了一个更高效的 M:N 两级线程模型。

### 1. Goroutine 的轻量级特性

* **用户态调度**：Goroutine 的创建、销毁和切换都在用户态完成，无需陷入内核，速度极快（纳秒级）。
* **动态伸缩栈**：Goroutine 初始栈非常小（仅 2KB），远小于线程的兆字节级别。栈空间会根据需要自动增长和收缩，既避免了栈溢出，又节省了内存。

### 2. GM 模型 (Go 1.1 之前)

* **G (Goroutine)**：Go 语言中的执行单元。
* **M (Machine)**：操作系统的工作线程。
* **模型**：多个 G 运行在多个 M 之上。所有的 G 都放在一个**全局队列**中，M 需要加锁从全局队列中获取 G 来执行。
* **缺点**：
    1. **全局锁竞争**：所有 M 都从同一个队列取 G，导致严重的锁竞争，性能瓶颈明显。
    2. **资源浪费**：M 进行系统调用阻塞时，其关联的内存缓存 `mcache` (约 2MB) 被闲置，造成浪费。
    3. **局部性差**：一个 G 创建的新 G' 可能会被分配到另一个 M 上执行，不利于利用 CPU 缓存。

### 3. GMP 模型 (现代 Go)

为了解决 GM 模型的缺陷，引入了 `P` (Processor)。

* **P (Processor)**：一个逻辑处理器，是 G 和 M 之间的中间层。P 的数量默认等于 CPU 核心数，可通过 `GOMAXPROCS` 设置。
* **核心改进**：
    1. **本地队列 (Local Run Queue)**：每个 P 都有一个自己的 G 队列。M 想要运行 G，必须先与一个 P 绑定，然后**优先从该 P 的本地队列获取 G**。访问本地队列**无需加锁**，极大地减少了锁竞争。
    2. **工作窃取 (Work Stealing)**：当一个 P 的本地队列为空时，它会去“偷”其他 P 本地队列中一半的 G 来执行，从而实现负载均衡。
    3. **全局队列 (Global Run Queue)**：依然存在，但作用被弱化。当 P 的本地队列满了，会把一半的 G 转移到全局队列。当 P 从本地队列和“偷取”都找不到 G 时，才会尝试从全局队列获取。

* **为什么需要 P？**
    * P 的数量相对稳定（等于 `GOMAXPROCS`），而 M 的数量可能因为系统调用阻塞而动态增减（最多可达 10000）。将本地队列挂在 P 上，使得队列管理和工作窃取机制更加稳定高效。
    * 当 M 因为系统调用而阻塞时，它会与 P 解绑，Go 运行时会启动一个新的或唤醒一个休眠的 M 来接管这个 P，继续执行 P 队列中的其他 G，避免了因一个 M 阻塞导致整个处理能力下降的问题。

## 调度器源码剖析：GMP 世界的构建之旅

这部分通过跟踪一个简单 Go 程序的启动过程，揭示 GMP 模型是如何从无到有被初始化并开始工作的。

### 1. 核心数据结构

* `g` (Goroutine):
    * `stack`: 描述了 G 的栈内存范围 (`lo` 和 `hi`)。
    * `sched` (`gobuf` 类型): **G 的调度上下文**，保存了 G 暂停时的状态，最重要的是 `sp` (栈指针) 和 `pc` (程序计数器)。
* `m` (Machine):
    * `g0`: 一个特殊的 G，拥有较大的栈，专门用来执行**调度代码**，每个 M 都有一个。
    * `curg`: 指向当前 M 正在执行的用户 G。
    * `p`: 指向当前 M 绑定的 P。
    * `tls`: **线程本地存储 (Thread Local Storage)**，用于将 M 结构体与具体的 OS 线程关联起来。
* `p` (Processor):
    * `runq`: **本地可运行 G 队列**，是 GMP 模型性能提升的关键。
    * `m`: 指向绑定它的 M。
    * `status`: P 的状态（如 `_Pidle`, `_Prunning` 等）。
* `schedt`: 全局唯一的调度器结构体，包含：
    * `runq`: 全局 G 队列。
    * `pidle`: 空闲 P 列表。
    * `midle`: 空闲 M 列表。
    * `lock`: 用于保护全局队列的锁。

### 2. 程序启动与调度器初始化 (The "Cold Start")

一个 Go 程序的启动过程，就是一部从零开始构建 GMP 世界的史诗。

1. **入口 (`runtime·rt0_go`)**: 程序从汇编代码开始，进行最底层的准备工作。
2. **创建 `m0` 和 `g0`**:
    * `m0`: 代表主线程的 M 结构体。
    * `g0`: 主线程的调度 G (`m0.g0`)，其栈直接使用主线程的系统栈。
    * **绑定**: 通过**线程本地存储 (TLS)** 机制，将 `m0` 和 `g0` 与主线程牢牢绑定。这样，运行时代码可以随时通过 `getg()` 获取到当前线程的 `g0`，进而找到 `m0`。

3. **调度器初始化 (`runtime·schedinit`)**:
    * `mcommoninit(&m0)`: 对 `m0` 进行基本初始化，并将其加入全局 M 列表 `allm`。
    * `procresize(GOMAXPROCS)`: **这是构建 P 的关键步骤**。
        * 创建 `GOMAXPROCS` 个 `p` 结构体，并存入全局切片 `allp`。
        * 将 `m0` 与 `allp[0]` 绑定 (`m0.p = allp[0]`, `allp[0].m = &m0`)。
        * 将除了 `allp[0]` 之外的所有 P 放入全局空闲 P 列表 `sched.pidle`。
    * 至此，我们有了一个随时可以工作的 `M-P` 对 (`m0-p[0]`) 和一堆待命的 P。

4. **创建 `main` Goroutine (`runtime·newproc`)**:
    * Go 程序的 `main` 函数本身也是在一个 Goroutine 中执行的。`newproc` 负责创建这个 `main goroutine`。
    * **核心操作**:
        1. **分配 G 和栈**: 在堆上分配一个新的 `g` 结构体和一块 2KB 的栈空间。
        2. **设置上下文 (`g.sched`)**:
            * `pc` (程序计数器) 指向 `runtime.main` (该函数最终会调用我们写的 `main.main`)。
            * `sp` (栈指针) 指向新分配栈的栈顶。
        3. **设置返回地址 (The `goexit` Trick)**: 在新 G 的栈顶巧妙地压入 `goexit` 函数的地址。这伪造了一个“调用”，确保当 `main` 函数执行完毕后，会 `ret` 到 `goexit`，进行资源清理并重新进入调度循环，而不是让程序崩溃。
        4. **入队**: 将这个新创建的 `main goroutine` 放入 `p[0]` 的本地运行队列 `runq` 中，状态为 `_Grunnable`。
5. **启动调度循环 (`runtime·mstart`)**:
    * `mstart` 调用 `schedule()`，正式开启调度循环。
    * `schedule()`:
        1. 在 `g0` 的栈上执行。
        2. 它会寻找一个可运行的 G。此时，它会从 `p[0]` 的本地队列中找到 `main goroutine`。
    * `execute(main_goroutine)`:
        1. 将 `main_goroutine` 的状态从 `_Grunnable` 变为 `_Grunning`。
        2. 调用汇编函数 `gogo(&main_goroutine.sched)`。
    * `gogo()`: **魔法发生的地方，执行真正的上下文切换**。
        1. 将 `main_goroutine.sched` 中保存的 `sp` 和 `pc` 值，加载到 CPU 的 `SP` 和 `IP` 寄存器中。
        2. `JMP` 到 `IP` 寄存器指向的地址 (`runtime.main`)。
    * **切换完成**: CPU 的控制权从 `g0` 的调度栈切换到了 `main goroutine` 的用户栈，我们编写的 `main` 函数开始执行。

## 调度循环 (The Loop of Life)

一旦启动，每个工作线程 M 就在一个永不停歇的调度循环中工作：

```
schedule() -> execute() -> gogo() -> [用户G代码] -> goexit() -> schedule()
```

* **`schedule()` 的查找逻辑**:
    1. **优先**从当前 P 的**本地队列**获取 G。
    2. 若本地队列为空，**周期性地**（每 61 次调度）检查**全局队列**，以保证公平性。
    3. 若仍为空，则调用 `findrunnable()` 进行**工作窃取**，从其他 P 的本地队列偷取 G。
    4. 如果连偷都偷不到，M 会进入休眠，直到被新的 G 唤醒。

* **`goexit()` 的作用**: 当一个非 `main` 的 Goroutine 执行完毕，它会返回到 `goexit`，在这里它会被标记为 `_Gdead`，其资源可以被回收，然后 M 会再次调用 `schedule()` 寻找下一个 G 来执行。

**总结**: Go 的高并发能力源于其高效的 GMP 调度模型。该模型通过为每个 P 设置无锁的本地 G 队列，并辅以工作窃取机制，实现了 G 在 M 上的高效、均衡的调度。其核心调度原理与操作系统类似，都是通过保存和恢复 CPU 寄存器（特别是 `sp` 和 `pc`）来实现上下文切换，但 Go 将这一过程移至用户态，极大地降低了开销。整个调度系统的精妙之处在于其启动过程的自举和调度循环的闭环设计。