---
source:
  - "[[阅读中/文章列表/文章收藏/2025-09/MySQL 8_0：filesort 性能退化的问题分析]]"
create: 2025-10-29
---

## 1. 文章核心内容分析

这篇文章深入剖析了一个 MySQL 数据库从 5.6 版本升级到 8.0 版本后，特定 SQL 查询性能急剧下降十几倍的问题。作者通过一系列的性能分析工具和源码研读，最终定位到问题根源在于 **MySQL 8.0 在 `filesort`（文件排序）过程中的机制变化**，导致对无关列（特别是存储在溢出页的大字段）进行了不必要的数据转换，从而引发了严重的性能退化。

## 2. 问题排查过程

文章的排查思路清晰，层层递进：

1. **初步分析**：
    * **`EXPLAIN` 和 `Optimizer Trace`**：对比 5.6 和 8.0 版本，发现执行计划完全相同，都是全表扫描 + `filesort`。
    * **`profiling`**：显示 8.0 版本在 `executing` 阶段耗时显著增加，但无法定位具体原因。
    * **`perf`**：初步发现热点函数集中在 `row_sel_store_mysql_rec`，该函数负责将数据从 InnoDB 存储层转换到 Server 层。

2. **问题复现**：
    * 作者通过简化表结构（包含一个 `varchar(8192)` 的大字段）和 SQL (`SELECT * FROM t1 ORDER BY paytime LIMIT 1;`)，在社区版 MySQL 上成功复现了问题，排除了云厂商定制化的影响。
    * **复现结果**：8.0 版本耗时 1.14s，而 5.6 版本仅为 0.14s，性能差距巨大。

3. **深入分析 (关键步骤)**：
    * **`perf` 火焰图**：再次分析发现，8.0 版本在 `row_sel_store_mysql_rec` 函数中存在大量内存拷贝操作。
    * **`bpftrace` 追踪**：这是定位问题的关键。
        * 追踪 `row_sel_store_mysql_rec` 函数，发现其在 8.0 中的单次执行耗时远高于 5.6。
        * 进一步追踪处理溢出页的函数 `btr_copy_externally_stored_field`，发现了惊人的差异：
            * **MySQL 5.6**：该函数仅执行 **1** 次，与 `LIMIT 1` 的结果匹配。
            * **MySQL 8.0**：该函数执行了 **300,000** 次，与全表扫描的行数匹配。

## 3. 根本原因分析 (源码层面)

`filesort` 排序时，需要从存储引擎读取数据。读取哪些列由一个名为 `read_set` 的位图（bitmap）决定。

* **MySQL 5.6 的高效做法**：
    1. **排序过程**：在进行 `filesort` 之前，临时修改 `read_set`，使其**只包含排序所需的列**（本例中为 `paytime` 字段和主键）。因此，在扫描全表的 300,000 行时，只读取和转换了极少量的数据。
    2. **排序完成**：排序找到最终需要的 1 行后，恢复 `read_set` 为 `SELECT *` 所需的全部字段，然后只对这 **1** 行数据进行完整的列转换（包括那个大的溢出列）。

* **MySQL 8.0 的低效做法**：
    1. **排序过程**：8.0 版本**移除了在 `filesort` 中临时修改 `read_set` 的优化逻辑**。
    2. 这意味着，在扫描全表的 300,000 行时，MySQL 8.0 会根据 `SELECT *` 的要求，**对每一行都进行所有列的转换**，包括那个处理起来非常耗时的溢出列 `col4`。这导致了大量不必要的 I/O 和 CPU 计算，造成了严重的性能下降。

## 4. 结论与启示

1. **问题根源**：MySQL 8.0 在 `filesort` 排序过程中，会读取并转换查询 (`SELECT`) 中所有字段的数据，而不仅仅是排序 (`ORDER BY`) 所需的字段。当查询中包含大字段（溢出列）时，这个问题会被急剧放大。
2. **影响版本**：该性能退化问题在 MySQL 5.7 中不存在，但在 **8.0、8.4 及 9.0** 版本中均存在，且在 8.4 中影响更严重。
3. **给用户的建议**：
    * 最有效的规避方法是**为 `ORDER BY` 的列创建索引**，从而避免 `filesort`。
    * 在无法添加索引的情况下，需要意识到 MySQL 8.0+ 版本存在这个性能陷阱，尤其是在处理包含大字段的表时。查询时应尽量只选择需要的列，避免使用 `SELECT *`。