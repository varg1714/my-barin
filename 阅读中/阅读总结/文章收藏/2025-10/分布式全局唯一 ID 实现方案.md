---
source: "[[分布式系统 - 全局唯一 ID 实现方案 _ Java 全栈知识体系]]"
create: 2025-10-02
---

## 1. 分布式全局唯一 ID 实现方案

### 1.1. 一、核心问题与两大流派

在分布式系统中，由于分库分表和多服务实例的存在，传统的数据库自增 ID 无法保证全局唯一性。一个理想的分布式 ID 应具备：全局唯一、趋势递增（利于数据库索引）、高可用、高性能等特点。

所有方案基本可以归为两大流派：

1. **中心化发号器模式**：依赖一个中心的权威组件（如数据库、Redis）来管理和分发 ID。ID 的生成逻辑由中心节点控制。
2. **类雪花算法模式 (Snowflake-like)**：ID 在各个服务节点本地生成，不依赖中心组件（或仅在启动时弱依赖）。通过将 64 位 ID 划分为不同含义的段（如时间戳、机器 ID、序列号）来保证全局唯一。

### 1.2. 二、方案详解

#### 1.2.1. (一) 中心化发号器模式

##### 1.2.1.1. 数据库步长模式

* **核心思想**：利用数据库的自增特性，但通过设置不同的起始值 (`auto_increment_offset`) 和步长 (`auto_increment_increment`) 来避免冲突。
    * 例如：3 台机器，步长都设为 3。机器 1 起始值为 1（生成 1, 4, 7...），机器 2 起始值为 2（生成 2, 5, 8...），机器 3 起始值为 3（生成 3, 6, 9...）。
* **优点**：
    * 实现简单，ID 严格有序递增。
    * 不引入新的技术组件。
* **缺点**：
    * **性能瓶颈**：每次获取 ID 都需要访问数据库，并发能力受限于数据库性能。
    * **强依赖数据库**：数据库宕机则整个发号服务不可用。
    * **扩展性差**：增加或减少机器时，需要重新计算和调整所有机器的步长和起始值，维护困难。

##### 1.2.1.2. Redis `INCR` 命令

* **核心思想**：利用 Redis 单线程模型的原子自增命令 `INCR` 或 `INCRBY` 来生成序列号。
* **优点**：
    * 性能远高于数据库，能满足高并发需求。
    * ID 有序递增。
* **缺点**：
    * 引入新的技术栈（Redis）。
    * 同样存在中心化问题，Redis 宕机则服务不可用。需要部署 Redis 集群来保证高可用，但这又会引入类似数据库步长模式的复杂性。

##### 1.2.1.3. 数据库号段模式 (美团 Leaf-segment)

这是对“数据库步长模式”的重大优化，解决了其性能瓶颈。

* **核心思想**：**ID 批发的思想**。不再逐个去数据库获取 ID，而是一次性从数据库获取一个 ID“号段”（Segment）到服务内存中。
    * **流程**：服务内存中的 ID 即将用尽时 -> 访问数据库，执行 `UPDATE table SET max_id = max_id + step` -> 服务获得 `[max_id - step, max_id - 1]` 这个号段的使用权 -> 在内存中快速发号。
* **优点**：
    * **极高性能**：将数据库的访问频率从“每次”降低到“每 `step` 次”，发号过程绝大部分是纯内存操作。
    * **数据库压力小**：大大减轻了数据库的负担。
* **优化（双 Buffer）**：为了防止在号段用尽、去数据库申请新号段时发生网络抖动或慢查询导致的服务卡顿，`Leaf` 采用了双 Buffer 机制。当一个 Buffer 的号段消耗到一定阈值（如 10%）时，就异步去加载下一个 Buffer，从而实现平滑无感的号段切换。
* **缺点**：
    * 仍然依赖数据库的可用性（但容忍度更高，DB 宕机一段时间服务仍可继续发号）。
    * ID 在单个号段内连续，容易被预测，可能暴露业务信息（如日订单量）。

#### 1.2.2. (二) 类雪花算法模式 (Snowflake-like)

##### 1.2.2.1. 原版 Snowflake 算法

* **核心思想**：将一个 64 位的 `long` 型 ID 划分为 4 个部分。
    * `1位` 符号位 (固定为 0)
    * `41位` 时间戳 (毫秒级，可使用约 69 年)
    * `10位` 机器 ID (`workerId`)
    * `12位` 序列号 (同一毫秒内可生成 4096 个 ID)
* **并发处理**：
    * `nextId()` 方法使用 `synchronized` 关键字，保证了在**同一实例**上，同一时刻只有一个线程能生成 ID，从而避免了 `sequence` 的并发修改问题。
    * 当同一毫秒内的序列号用尽（溢出为 0），代码会**自旋等待**，直到进入下一毫秒，然后将序列号重置为 0。
* **优点**：
    * **本地生成，高性能**：ID 生成不依赖任何网络请求，纯本地计算。
    * **趋势递增**：ID 整体按时间趋势递增，对数据库索引友好。
* **缺点**：
    * **时钟回拨问题**：强依赖机器时钟。如果时钟回拨，可能生成重复的 ID。原版实现是直接抛出异常，导致服务不可用。
    * **`workerId` 需手动配置**：在服务实例多或动态伸缩的场景下，手动管理 `workerId` 非常困难且容易出错。

##### 1.2.2.2. 百度 UidGenerator

这是对原版 Snowflake 的改进，主要解决了 `workerId` 分配和高并发性能问题。

* **`workerId` 自动分配**：
    * **核心**：利用数据库自增主键来自动分配 `workerId`。
    * **流程**：服务在**启动时**，向一个 `WORKER_NODE` 表中插入一条记录，并获取该记录的自增 ID 作为自己的 `workerId`。
    * **解决了什么**：完美解决了 `workerId` 需要手动配置的痛点，尤其适用于 Docker、K8s 等实例动态变化的云原生环境。
* **高并发性能优化 (`CachedUidGenerator`)**：
    * **核心**：采用**RingBuffer**作为 ID 缓存，实现了“预生成”和“无锁获取”。
    * **流程**：后台线程负责生成 ID 并填充到 RingBuffer 中（这个过程有锁）。业务线程需要 ID 时，直接从 Buffer 中无锁（或 CAS）获取一个现成的 ID。
    * **解决了什么**：将 ID 的“生成”和“获取”解耦，避免了 `synchronized` 在高并发下带来的性能瓶颈，极大提升了 QPS。
    ![RingBuffer示意图](https://pdai.tech/images/arch/arch-z-id-5.png)

##### 1.2.2.3. 美团 Leaf-snowflake

这也是对原版 Snowflake 的改进，采用了不同的方式解决 `workerId` 分配和时钟问题。

* **`workerId` 自动分配**：
    * **核心**：利用 **Zookeeper** 的持久顺序节点特性。
    * **流程**：服务启动时，在 Zookeeper 的一个父节点下创建一个持久顺序节点，ZK 会自动为其分配一个唯一的、递增的序号，服务便以此序号作为 `workerId`。
* **时钟回拨解决方案**：
    * 在 ZK 中记录节点的时间，并定期上报。如果发现本地时间小于 ZK 记录的时间，则判断为时钟回拨，拒绝发号并报警。
    * 官方建议关闭 NTP 同步，或在发生回拨时直接报错，等待时钟追上。

### 1.3. 三、方案横向对比总结

| 方案                      | 核心思想          | ID 特性      | 优点                  | 缺点                    | 解决的关键问题                               |
| :---------------------- | :------------ | :--------- | :------------------ | :-------------------- | :------------------------------------ |
| **UUID**                | 本地随机/哈希生成     | 无序，字符串     | 简单，无网络，无冲突          | 太长，无序（索引性能差），可能暴露信息   | 基础的唯一性需求                              |
| **UUID v7 (新)**         | 时间戳 + 随机数     | 趋势递增，不连续   | 索引友好，无需中心协调，部署极简    | 128 位，比 64 位 ID 占用更多存储     | 解决了传统 UUID 的无序问题和 Snowflake 的 workerId 依赖问题 |
| **DB 号段(Leaf-segment)** | 批量获取 ID 号段    | 趋势递增，号段内连续 | 高性能，减轻 DB 压力        | 依赖 DB，ID 可预测          | 原始 DB 方案的性能瓶颈                         |
| **原版 Snowflake**        | 时间戳+机器 ID+序列号 | 趋势递增，不连续   | 本地生成，高性能            | 依赖时钟，`workerId` 需手动配置 | 分布式环境下的高性能 ID 生成                      |
| **百度 UidGenerator**     | Snowflake 变种  | 趋势递增，不连续   | 高性能，`workerId` 自动分配 | 启动时依赖 DB              | `workerId` 的自动分配和高并发性能                |
| **美团 Leaf-snowflake**   | Snowflake 变种  | 趋势递增，不连续   | 高性能，`workerId` 自动分配 | 依赖 Zookeeper          | `workerId` 的自动分配和时钟回拨检测               |
