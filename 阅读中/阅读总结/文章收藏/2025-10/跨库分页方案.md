---
source:
  - "[[炸了！业界难题，跨库分页的几种常见方案（第 103 讲，万字收藏）]]"
create: 2025-10-15
---

## 一、问题的提出：为什么需要跨库分页？

在互联网业务中，当单一数据库无法承载海量数据时，通常会进行水平切分（分库分表）。这带来了一个经典难题：**如何跨越多个分库，实现一个全局有序的分页查询？**

**典型场景：**
- **业务需求：** 查询“最近注册的第 N 页用户”。
- **数据库状态：** 用户表 `t_user` 已根据 `uid`（分区键）水平切分成多个库（如 `db0`, `db1`）。
- **查询语句：** `SELECT * FROM t_user ORDER BY time OFFSET X LIMIT Y;`
- **核心矛盾：** 分库的依据是 `uid`，但排序的依据是 `time`。每个数据库都失去了 `time` 排序的全局视野，无法直接通过 `OFFSET` 和 `LIMIT` 得到全局正确的第 N 页数据。


## 二、四种解决方案详解

### 方法一：全局视野法（暴力合并排序）

- **核心思想：** 从每个分库获取足够多的数据，然后在服务层进行内存排序，最后取出目标分页的数据。
- **实现步骤：**
    1. 将原始查询 `ORDER BY time OFFSET X LIMIT Y;` 改写为 `ORDER BY time OFFSET 0 LIMIT X+Y;`。
    2. 将改写后的 SQL 发送到所有 `N` 个分库。
    3. 服务层收集所有分库返回的数据，总计最多 `N * (X+Y)` 条。
    4. 在服务层对所有数据进行内存排序。
    5. 从排序后的结果中，跳过 `X` 条，取 `Y` 条，作为最终结果。
- **优点：**
    - **数据精确：** 结果与单库查询完全一致，业务无损。
- **缺点：**
    - **性能瓶颈极其严重：** 随着查询页码 `X` 的增大，从各分库获取的数据量和内存排序的计算量会急剧上升，性能呈平方级下降。
    - **网络开销大：** 需要在数据库和服务层之间传输大量数据。
    - **服务层 CPU 消耗高：** 需要进行大规模的内存排序。

### 方法二：禁止跳页查询法（游标/Seek 法）

- **核心思想：** 通过牺牲“跳页”功能，只提供“下一页”查询，将分页查询转化为基于上一页最后一个元素的游标查询。
- **实现步骤：**
    1. **查询第一页：** 与方法一类似，但只需获取第一页数据。从各分库取 `LIMIT Y`，在服务层排序后得到最终的第一页，并记录下这一页数据中 `time` 的最大值 `time_max`。
    2. **查询下一页：** 将查询 `ORDER BY time OFFSET X LIMIT Y;` 改写为 `ORDER BY time WHERE time > $time_max LIMIT Y;`。
    3. 服务层收集各分库返回的 `Y` 条数据，排序后得到最终的下一页结果，并更新 `time_max`。
- **优点：**
    - **性能恒定：** 无论翻到多深的页码，每次查询从数据库获取的数据量和内存排序量都是固定的，性能不会下降。
- **缺点：**
    - **业务功能妥协：** 用户无法直接跳转到指定页码，只能一页一页向后翻。

### 方法三：允许数据精度损失法（近似/统计法）

- **核心思想：** 基于“数据均衡原理”的假设，认为数据在各个分库中是均匀分布的。因此，全局的第 N 页数据约等于每个分库的第 N/M 页数据（M 为分库数）的合集。
- **实现步骤：**
    1. 将原始查询 `ORDER BY time OFFSET X LIMIT Y;` 改写为 `ORDER BY time OFFSET X/N LIMIT Y/N;` (N 为分库数)。
    2. 将改写后的 SQL 发送到所有 `N` 个分库。
    3. 将各分库返回的结果直接合并，作为最终结果。
- **优点：**
    - **性能极高：** 查询和传输的数据量最小，且无需在服务层进行二次排序。
- **缺点：**
    - **结果不精确：** 结果只是一个近似值，与真实全局排序存在偏差。适用于对数据精度要求不高的场景（如用户翻到很深的页数时）。

### 方法四：二次查询法（精确高效的终极方案）

- **核心思想：** 通过两次查询，第一次做一个聪明的“猜测”来定位一个大致的数据窗口，第二次进行“校准”和“补全”，最终在极小的数据集上精确计算出结果。
- **实现步骤详解：**
    1. **第一次查询 (启发式猜测):**
        - **操作:** 将 `OFFSET X LIMIT Y` 改为 `OFFSET X/N LIMIT Y` (N 为分库数)，分发给所有分库。例如 `OFFSET 1000 LIMIT 5` 在 3 个库上变为 `OFFSET 333 LIMIT 5`。
        - **目的:** 基于数据均衡假设，快速定位到目标数据可能存在的“数据窗口”，避免全量拉取。
    2. **寻找全局锚点 (Find Anchor):**
        - **操作:** 比较第一次查询从各分库返回的所有结果，找到其中最小的时间戳 `time_min`。
        - **目的:** 建立一个全局的、统一的比较基准。任何我们最终需要的数据，其时间戳必然 `>= time_min`。
    3. **第二次查询 (校准与补全):**
        - **操作:** 对每个分库发起第二次查询，条件为 `WHERE time BETWEEN $time_min AND $shard_i_max_time` (其中 `$shard_i_max_time` 是第一次查询时该分库返回的最大时间)。
        - **目的:** “填补”因数据分布不均而在第一次查询中被遗漏的数据。确保我们拥有了从 `time_min` 开始的、在所有分库中连续无遗漏的数据。
    4. **计算全局 Offset (重建全局视野):**
        - **操作:** 计算出锚点 `time_min` 在全局数据中的准确排名（全局 Offset）。这通过推算每个分库中有多少条记录的 `time` 小于 `time_min` 来实现，然后求和。
        - **目的:** 在不拉取海量数据的前提下，精确地为我们的“锚点”在全局数据长河中进行坐标定位。
    5. **内存归并与定位 (Merge & Locate):**
        - **操作:** 我们已经知道 `time_min` 的全局排名（如 994），也想找全局排名 1000 的数据。同时，第二次查询已返回了从 `time_min` 开始的所有相关数据。只需在服务层对这几个小结果集进行归并排序，然后从头数 `(1000 - 994)` 条记录，即可找到目标页的起始位置。
        - **目的:** 在极小的数据集上完成最终的精确定位和数据提取。
- **优点：**
    - **数据精确：** 结果完全准确，无业务妥协。
    - **性能高且稳定：** 无论翻页多深，数据库返回的数据量和内存计算量都保持在很小的范围内，性能不会随页码增加而下降。
- **缺点：**
    - **实现复杂：** 逻辑比其他方案复杂，需要两次数据库交互。

## 三、总结与对比

| 方法            | 核心思想          | 优点          | 缺点              | 适用场景                |
| :------------ | :------------ | :---------- | :-------------- | :------------------ |
| **方法一：全局视野法** | 暴力拉取，内存排序     | 结果精确        | 性能随页码急剧下降，开销大   | 数据量小，或只允许查询前几页的场景   |
| **方法二：禁止跳页法** | 使用游标，只提供“下一页” | 性能恒定，开销小    | 功能受限，用户体验有损     | 无需跳页功能的流式加载场景，如信息流  |
| **方法三：近似法**   | 假设数据均匀，各取一部分  | 性能极高，实现简单   | 结果不精确           | 对数据精度要求不高的深分页场景     |
| **方法四：二次查询法** | 猜测+校准，精确重定位   | 结果精确，性能高且稳定 | 实现复杂，需要两次 DB 交互 | 对精度和性能都有高要求的通用深分页场景 |

**核心启示：** 架构设计没有银弹，解决复杂问题通常需要在**精度、性能、成本和业务需求**之间做出权衡。理解每种方案背后的思路，比单纯记住结论更为重要。