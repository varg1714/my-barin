---
source:
  - "[[轻量级的灰度 & 配置平台｜得物技术]]"
create: 2025-10-28
---

## 1. 核心设计思想：解耦与下沉

这篇文章介绍的系统，其设计的精髓可以概括为一句话：**“配置与执行解耦，逻辑向客户端下沉”**。

这意味着整个系统被清晰地划分为三个独立的部分，它们各司其职，通过标准化的“规则”进行协作：

1. **配置端 (UI & 后台服务)**：负责**“定义规则”**。运营或开发人员在这里通过可视化界面创建灰度策略，最终生成一份结构化的 JSON 配置（即 `Toggle` 对象）。
2. **分发/存储 (Nacos)**：扮演**“公告板”**的角色。它负责存储和分发由配置端生成的规则 JSON，并能实时将规则的变更推送给所有订阅者。
3. **执行端 (SDK)**：作为嵌入在业务应用中的**“规则解释器”**。它从 Nacos 订阅规则，缓存在本地内存中，并根据业务代码传入的实时上下文（如用户 ID、版本号等）进行**本地、高效**的判断。

这种设计的最大优势是**高性能**和**高可用**。因为核心的判断逻辑在客户端本地完成，无需每次都进行网络请求，即使配置中心短暂失效，SDK 也能依赖本地缓存继续工作。

## 2. 系统完整工作流

`sceneKey` (场景键) 是串联整个流程的“接头暗号”。

1. **定义 (Define)**：在**灰度平台**上创建一个灰度策略，并为其命名一个唯一的 `sceneKey`（例如 `new_payment_flow_v2`）。
2. **发布 (Publish)**：平台将生成的规则 JSON 以该 `sceneKey` 作为 `Data ID` 发布到 **Nacos**。
3. **订阅 (Subscribe)**：业务应用中的**灰度 SDK**在启动时，会自动向 Nacos 订阅其所属分组下的所有配置。当有更新时，Nacos 会主动推送，SDK 接收后更新其**本地内存缓存**（一个 `Map<String, Toggle>` 结构）。
4. **调用 (Invoke)**：业务代码在需要判断逻辑的地方，使用完全相同的 `sceneKey` (`new_payment_flow_v2`) 调用 SDK 提供的接口，如 `grayService.hitGray(sceneKey, attrs)`。
5. **执行 (Execute)**：SDK 根据传入的 `sceneKey` 从本地缓存中**瞬间**拿到规则，在内存中执行匹配逻辑，并返回最终结果 (`true` 或 `false`)。

## 3. 总体架构各模块解析

| 模块名             | 职责                                                                      |
| :-------------- | ----------------------------------------------------------------------- |
| **灰度运营平台**      | 提供可视化的 UI 界面，供用户进行灰度规则的增删改查。这是规则的“生产者”。                                 |
| **灰度服务端**       | 为运营平台提供后端 API 服务，负责权限控制、将前端操作转化为结构化的规则 JSON，并将其发布到 Nacos。               |
| **Nacos & Ark** | 作为高性能的配置中心。**核心作用**是存储规则配置，并提供动态推送能力，确保所有客户端（SDK）的规则都是最新的。              |
| **灰度 SDK**      | 系统的**核心执行单元**。它被集成在业务应用中，负责从 Nacos 订阅规则、在本地缓存规则、并提供 API 供业务代码调用以执行灰度判断。 |

## 4. 核心设计深度剖析

### 4.1. 规则引擎设计 (SDK 的大脑)

这是整个系统技术含量最高的部分，采用了**策略模式 (Strategy Pattern)**，实现了高度的可扩展性。

* **规则的“蓝图”：数据模型**
    * **`Toggle`**：代表一个完整的灰度开关，包含多个 `Rule`。
    * **`Rule`**：代表一组“与”关系的条件。多个 `Rule` 之间是**“或” (OR)** 关系。只要命中任意一个 `Rule`，整个开关就命中。
    * **`Condition`**：最基础的原子判断单元，包含 `subject` (检查字段), `type` (字段类型), `predicate` (判断谓词), `objects` (目标值)。一个 `Rule` 内的多个 `Condition` 是**“与” (AND)** 关系，必须全部满足。
    * **逻辑结构**：`(Condition1 AND Condition2) OR (Condition3 AND Condition4)`。
* **规则的“执行者”：`Matcher` 接口**
    * 这是实现**可扩展性**的关键。系统将不同数据类型（`string`, `number`, `version`）的判断逻辑抽象成 `Matcher` 接口。
    * 每种数据类型都有一个对应的实现类（如 `StringMatch`, `NumberMatch`），它们向系统“注册”自己能处理的判断方法（如 `eq`, `>`, `regex`）。
    * **优点**：当需要支持新的数据类型或判断逻辑时，只需新增一个 `Matcher` 实现类，无需修改引擎的核心调度代码，遵循了**开闭原则**。
* **规则的“调度流程”**
    1. SDK 启动时，扫描所有 `Matcher` 实现，建立一个 `Map<ConditionType, Matcher>` 的注册表。
    2. 调用 `hitGray` 时，外层循环遍历所有 `Rule` (OR 关系)。
    3. 内层循环遍历当前 `Rule` 下的所有 `Condition` (AND 关系)。
    4. 对于每个 `Condition`，根据其 `type` 找到对应的 `Matcher`，再根据 `predicate` 找到具体的判断函数，执行并返回结果。
    5. 只要有一个 `Condition` 不满足，内层循环就中断，当前 `Rule` 失败。
    6. 只要有一个 `Rule` 成功，外层循环就中断，整个 `Toggle` 命中。

### 4.2. 配置的存储与订阅 (Nacos 的应用)

* **发布过程**：
    1. 灰度服务端将 `Toggle` 对象序列化为 JSON 字符串。
    2. 调用 Nacos 的 `publishConfig` API，将 JSON 字符串作为 `content`，`sceneKey` 作为 `Data ID`，业务分组作为 `Group`，发布到 Nacos。

* **订阅过程**：
    1. SDK 启动时，向 Nacos 注册一个 `Listener`，监听指定 `Group` 下的所有配置变更。
    2. 当 Nacos 中的配置被修改时，Nacos Server 会主动将新的配置内容推送给所有监听的 SDK 实例。
    3. SDK 的 `Listener` 接收到新配置后，会反序列化为 `Toggle` 对象，并更新本地的 `Map<String, Toggle>` 缓存。

## 5. 其他关键功能设计

* **稳定的百分比流量调控**
    * **目的**：确保同一个用户在多次请求中，灰度结果保持一致，避免体验割裂。
    * **实现**：使用 `murmur3_32` 一致性哈希算法。将指定维度（如 `userId`）的哈希值对 10000 取模，得到一个 `[0, 9999]` 之间的稳定分桶值。通过比较这个值和设定的比例阈值，来决定是否命中。
* **灰度分组与白名单**
    * **灰度分组**：`Toggle` 数据结构中的 `List<Rule>` 天然支持了分组，每个 `Rule` 就是一个独立的实验组，它们之间是“或”关系。
    * **白名单**：在 `Toggle` 模型中设计一个高优先级的 `whiteLists` 字段。规则引擎在执行复杂的 `rules` 判断前，会**首先检查**当前请求是否命中白名单。如果命中，则直接返回 `true`，极大提升了内部测试和问题排查的效率。
* **配置服务与可视化**
    * 系统不仅是灰度开关，还是一个**动态配置平台**。
    * 通过集成**动态表单**技术，运营人员可以在 UI 上通过拖拽或配置的方式生成复杂的 JSON 配置，而不是手写，降低了门槛和风险。
    * SDK 提供了 `GrayConfigService` 接口，包含 `getStringValue`, `getBooleanValue` 等便利方法，并支持 `JSONPath`，让开发者能轻松地从下发的复杂 JSON 中安全地提取所需的值。

## 6. 总结与启示

该系统是一个优秀的轻量级分布式系统设计范例，其成功关键在于遵循了以下设计原则：

| 设计原则      | 实现方式                            | 带来的好处                 |
| :-------- | :------------------------------ | --------------------- |
| **解耦与分层** | 将 UI、服务、存储、执行(SDK) 彻底分开。        | 高性能、高可用、各部分可独立演进。     |
| **逻辑下沉** | 核心的规则判断逻辑在客户端 SDK 中完成。          | 极低的判断延迟，对服务端压力小，容错性强。 |
| **可扩展性** | 通过 `Matcher` 接口（策略模式）实现规则的灵活扩展。 | 易于维护，能快速响应新的业务需求。     |
| **易用性** | 提供可视化运营平台、动态表单和便利的 SDK 接口。      | 降低了开发和运营人员的使用门槛和出错率。  |
| **复用性** | 直接利用成熟的 Nacos 作为配置中心，而不是自研。     | 聚焦于核心业务逻辑，降低了系统整体复杂度。 |