---
source:
  - "[[微信：群消息，我们绝对不可能丢！（第 56 讲）]]"
create: 2025-10-29
---

## 1. 初始方案：区分在线和离线处理

这是最基础的思路，但存在明显缺陷。

* **流程**：
    1. 服务器收到消息后，查询群成员的在线状态。
    2. 对在线用户，进行实时推送。
    3. 对离线用户，将消息内容完整地存入离线消息表。
* **问题**：
    * **存储冗余**：一个 500 人的群，如果有 200 人离线，同一条消息就要存储 200 份，造成巨大的存储浪费。

## 2. 优化一：减少消息存储冗余

为了解决存储冗余问题，将消息内容和消息的归属关系分离。

* **流程**：
    1. 引入 `群消息表`，只存储一份消息内容。
    2. `群离线消息表` 只存储 `user_id` 和 `msg_id` 的关系。
    3. 离线用户上线后，先拉取 `msg_id` 列表，再根据 `msg_id` 去拉取具体消息内容。
* **问题**：
    * **消息丢失风险**：无论是实时推送还是离线拉取，在网络波动、服务器或客户端崩溃等情况下，都可能导致消息丢失。这个方案没有确认机制。

## 3. 优化二：引入应用层 ACK 机制

为了保证消息真正送达，引入了确认（ACK）机制。

* **流程**：
    1. 服务器收到消息后，先将消息存入 `群消息表`，然后**为所有群成员**（无论在线与否）都在 `离线消息表` 中创建一条记录。
    2. 向在线用户推送消息。
    3. 用户（客户端）收到消息后，向服务器发送一个 ACK。
    4. 服务器收到 ACK 后，才从 `离线消息表` 中删除该用户的对应记录。
* **优点**：
    * 通过 ACK 确保了消息的可靠送达。如果服务器没收到 ACK，就会认为用户没收到，用户下次登录时可以再次拉取。
* **问题**：
    * **离线记录数过多**：一个 500 人的群，发 10 条消息，`离线消息表` 就会增加 5000 条记录，即使用 ACK 机制不断清理，数据库写压力依然很大。
    * **重复消息**：如果用户收到了消息但 ACK 未成功发送，下次会拉取到重复消息（解决方案：客户端根据 `msg_id` 去重）。

## 4. 优化三：使用“游标”代替离线表

这是架构上的一个巨大飞跃，彻底解决了离线表记录过多的问题。

* **流程**：
    1. **废除 `群离线消息表`**。
    2. 在 `群成员表` 中增加一个字段 `last_ack_msg_id`，作为每个用户在该群中已成功接收消息的“游标”或“水位线”。
    3. 用户收到消息并 ACK 后，服务器不再是删除记录，而是更新这个 `last_ack_msg_id`。
    4. 用户拉取离线消息时，只需向服务器请求所有 `msg_id` 大于其 `last_ack_msg_id` 的消息。
* **优点**：
    * 极大地降低了数据库的写入压力，从为每条消息写入 N 条记录，变为只更新 N 次记录。
* **问题**：
    * **ACK 风暴**：在一个 500 人的大群里，每发一条消息，服务器理论上会收到 500 个 ACK 请求，对服务器造成巨大冲击。

## 5. 优化四：批量 ACK 与其他优化

针对 ACK 风暴和其他体验问题，引入了最后的优化策略。

* **批量 ACK**：客户端可以累积一定数量（N 条）或一定时间（T 秒）的消息后，再统一发送一次 ACK，将 `last_ack_msg_id` 更新为最新的即可。这能将 ACK 请求量降低为原来的 1/N。
* **客户端去重**：批量 ACK 增加了消息重复的概率（比如未到 ACK 时机就退出了），客户端去重是必须的兜底方案。
* **分页拉取**：如果离线消息过多，一次性拉取会很慢，可以分页按需拉取，提升用户体验。

## 总结

这篇文章通过层层递进的方式，清晰地展示了一个高可用的 IM 群消息系统的设计演进过程。其核心思想可以概括为：

1. **ACK 是可靠性的基石**：没有确认机制，就无法保证消息送达。
2. **数据结构决定系统上限**：从“为每个用户存离线消息”到“为每个用户记录一个游标”，是架构设计的关键性转变，极大地提升了系统的可扩展性。
3. **权衡与取舍**：为了降低服务器压力，采用批量 ACK，但牺牲了一定的实时性并把去重复杂性交给了客户端，这体现了架构设计中的权衡思想。
4. **思路比结论重要**：文章不仅给出了最终方案，更重要的是展示了如何一步步发现问题并找到更优解的思考路径。