---
source: "[[Redis、ZooKeeper、Etcd，谁有最好用的分布式锁？]]"
create: 2025-09-17
---

这篇文章深入、系统地探讨了分布式锁的实现原理、存在的安全问题以及不同技术方案（Redis、ZooKeeper、Etcd）之间的权衡。文章的核心思想是：**没有绝对安全的分布式锁，在追求效率的同时，必须为关键业务的正确性设计兜底方案。**

## 1. 文章主要脉络分析

文章通过一个层层递进的方式，从一个最简单的分布式锁实现开始，逐步揭示其存在的问题，并给出相应的优化方案，最终引出业界关于 Redlock 的著名争论，并对比了其他主流方案。

### 1.1. 基于 Redis 分布式锁的演进过程

文章首先展示了如何从零开始构建一个相对严谨的 Redis 分布式锁，这个过程解决了几个关键问题：

*   **问题：死锁**
    *   **原因**：客户端拿到锁后崩溃或代码异常，未能释放锁。
    *   **解决方案**：为锁设置过期时间（租期）。
*   **问题：设置过期时间的原子性**
    *   **原因**：`SETNX` 和 `EXPIRE` 是两条命令，可能只执行了第一条就发生故障。
    *   **解决方案**：使用 Redis 2.6.12+ 提供的原子命令 `SET lock_key unique_id EX expire_time NX`。
*   **问题：锁被错误释放**
    *   **原因**：客户端 A 的锁因超时自动释放，客户端 B 获得锁，此时客户端 A 操作完成，释放了客户端 B 的锁。
    *   **解决方案**：加锁时设置一个唯一的客户端标识（如 UUID），释放锁时先验证标识是否属于自己，并通过 **Lua 脚本** 保证“获取-判断-删除”操作的原子性。
*   **问题：锁提前过期**
    *   **原因**：业务逻辑执行时间超过了锁的预估过期时间。
    *   **解决方案**：引入“守护线程”（看门狗），在锁未释放前，定期为锁续期。Java 中的 `Redisson` 客户端就实现了这个功能。

### 1.2. Redlock 方案及其引发的世纪之争

当 Redis 采用主从架构时，主节点宕机但数据未同步到从节点，会导致锁丢失。为了解决这个问题，Redis 作者提出了 **Redlock（红锁）** 算法。

*   **Redlock 核心思想**：
    1.  部署多个独立的 Redis 主节点（官方建议 5 个）。
    2.  客户端向大多数（如 >=3 个）节点成功申请加锁。
    3.  加锁总耗时必须小于锁的过期时间。
    4.  释放锁时，向所有节点发起请求。

*   **两大专家的争论焦点**：
    *   **分布式专家 Martin 的质疑**：
        1.  **正确性 vs 效率**：为追求效率，单机 Redis 足矣；为追求正确性，Redlock 不够安全。
        2.  **NPC 问题**：Redlock 无法应对**网络延迟（Network Delay）、进程暂停（Process Pause，如 GC）、时钟漂移（Clock Drift）** 带来的问题。一个长时间的 GC 可能导致锁过期，从而使两个客户端都认为自己持有锁。
        3.  **时钟依赖**：Redlock 强依赖多个节点的时钟同步，这是不现实且危险的假设。
        4.  **提出 Fencing Token**：他认为更安全的方案是锁服务提供一个单调递增的 `token`，资源方通过验证 `token` 的新旧来拒绝过期的请求，从而保证操作的正确性。

    *   **Redis 作者 Antirez 的反驳**：
        1.  **时钟问题**：Redlock 不要求时钟完全精确，只需大体一致，并且可以通过良好的运维避免时钟大幅跳跃。
        2.  **NPC 问题**：Redlock 的设计（步骤 3 的耗时检查）可以在**加锁成功前**检测出长时间的 GC 或网络延迟。而**拿到锁之后**发生的 GC 问题，是所有分布式锁（包括 ZooKeeper）共同的难题。
        3.  **Fencing Token 的局限性**：该方案要求资源方（如数据库）具备验证 `token` 的能力，并非通用；并且 Redis 的唯一 ID 也可以通过类似 CAS 的方式实现类似效果，分布式锁的核心是**互斥**，而非**顺序性**。

### 1.3. ZooKeeper 和 Etcd 分布式锁的分析

文章进一步分析了基于 ZooKeeper 和 Etcd 的分布式锁，指出它们也并非绝对安全。

*   **ZooKeeper**：利用**临时节点**实现。客户端与服务端维持一个 Session，通过心跳保持连接。如果客户端长时间 GC，心跳中断，Session 过期，临时节点被删除，其他客户端就能获取锁，导致冲突。
*   **Etcd**：利用**租约（Lease）** 机制。客户端为锁关联一个租约并定时续期。同样地，长时间 GC 会导致续期失败，租约到期，锁被删除，引发冲突。

**结论**：无论是哪种方案，当客户端**成功拿到锁之后**发生长时间的进程暂停（GC），都可能导致锁失效，无法做到 100% 安全。

## 2. 作者的核心观点与建议

1.  **不要迷信分布式锁**：任何分布式锁在极端情况下都可能失效。不能假设拿到锁就绝对安全。
2.  **慎用 Redlock**：Redlock 部署成本高、性能较低，且其安全性建立在不稳定的“时钟正确”假设上，因此不推荐使用。
3.  **推荐的实践方案（两层防护）**：
    *   **上层（效率层）**：使用常规的 Redis 主从分布式锁。它能拦截绝大部分并发请求，非常适合高并发场景。
    *   **下层（正确性兜底层）**：在最终操作的资源层面（如数据库）做好防护。借鉴 **Fencing Token** 的思想，使用**乐观锁**（如版本号 `version` 或时间戳）来更新数据，确保即使锁失效，数据的最终一致性也能得到保证。

总而言之，这篇文章不仅清晰地讲解了分布式锁的技术细节，更重要的是传递了一种严谨的分布式系统设计思想：**承认系统的复杂性和不确定性，并通过多层设计来确保核心业务的正确性。**