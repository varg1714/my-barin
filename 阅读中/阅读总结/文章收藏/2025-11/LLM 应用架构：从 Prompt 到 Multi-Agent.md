---
source:
  - "[[彻底爆了！一文了解 LLM 应用架构：从 Prompt 到 Multi-Agent]]"
create: 2025-11-26
---

## 1. LLM 应用架构的四个演进阶段

LLM 的应用落地经历了一个从“挖掘智能”到“自动化执行”的过程，自动化程度逐级提升。

### 1.1. 第一阶段：Prompt 工程 (挖掘智能)

* **核心逻辑**：`人 --> 提示词 --> LLM`
* **定义**：通过设计特定的提示词（如角色扮演）来激活 LLM 内部的特定参数分布，挖掘其智能。
* **特点**：
    * **单次交互**：主要是问答形式。
    * **依赖人工**：需要人类手动补充上下文。
    * **局限**：仅停留在对话层面，无法与外部世界交互。
* **代表作**：各类 Prompt 市场、GPTs。

### 1.2. 第二阶段：Chain 编排 ("+AI" 模式)

* **核心逻辑**：`人 --> 固定流程编排 (DAG) --> 结果`
* **定义**：将 LLM 与工具结合，通过**固定的流水线**（Pipeline）串联执行。
* **特点**：
    * **有了“手脚”**：可以调用工具（如搜索、数据库查询）。
    * **流程固定**：程序的逻辑是写死的（DAG 有向无环图），LLM 只是流程中的一个处理节点。
    * **稳定性高**：适合生产环境，因为每一步都在预期内。
    * **局限性**：**缺乏泛化能力**。
        * *案例*：日志分析 Chain。如果日志编码格式发生变化（如从 Base64 变为 URL+Base64），固定的 Chain 就会失效，必须人工修改流程图，LLM 无法自主决定“多解密一次”。
* **代表作**：LangChain、RAG 应用（**Retrieval-Augmented Generation** ，**“检索增强生成”**）、Dify 工作流。

### 1.3. 第三阶段：Agent 智能体 ("AI+" 模式)

* **核心逻辑**：`人 --> 目标 + 工具 --> Agent (自主规划)`
* **定义**：LLM 具备感知、记忆、规划和使用工具的能力。不再需要设计固定流程，只需给定目标，Agent 自主规划路线。
* **特点**：
    * **自主规划**：从“如何做”转变为“做什么”。
    * **动态执行**：根据环境反馈调整策略（ReAct 范式）。
    * **缺点**：单 Agent 负担过重，容易陷入死循环或幻觉，难以控制。
* **代表作**：AutoGPT、Cursor (Agent 模式)、Devin。

### 1.4. 第四阶段：Multi-Agent (群体智能)

* **核心逻辑**：`人 --> 多个专家 Agent 协作`
* **定义**：将复杂任务拆解，由多个拥有不同人设（如产品经理、架构师、测试）的 Agent 协作完成。
* **原理**：
    * **专业分工**：降低单个 Agent 的上下文压力和幻觉风险。
    * **通信机制**：通过共享环境或消息路由（Controller）进行交互。
* **代表作**：MetaGPT（模拟软件公司）、ChatDev。

## 2. Agent 的核心实现原理 (ReAct Loop)

Agent 的本质是一个**循环（Loop）**，其核心架构通常被称为“规划器 + 执行器”。

### 2.1. 核心组件

1. **大脑 (LLM)**：负责理解意图、规划步骤、生成决策。
2. **工具 (Tools)**：函数或 API（如搜索、计算器、代码解释器、文件操作）。
3. **记忆 (Memory/Scratchpad)**：记录之前的思考过程、采取的行动以及环境返回的结果。

### 2.2. 运行机制 (ReAct 范式)

这是一个 `Think` (思考) -> `Act` (行动) -> `Observe` (观察) 的循环过程：

1. **构建 Prompt**：
    * **静态部分**：人设（你是一个专家...） + 工具描述（你可以使用工具 A、B...）。
    * **动态部分**：用户问题 + **Scratchpad（历史思考与观察记录）**。
2. **LLM 决策**：
    * LLM 阅读 Prompt，判断当前情况。
    * **分支 A**：认为任务未完成 -> 输出 `Action: [工具名]` 和 `Action Input: [参数]`。
    * **分支 B**：认为任务已完成 -> 输出 `Final Answer: [结果]` -> **结束循环**。
3. **程序执行 (DoAction)**：
    * 代码解析 LLM 的输出。
    * 调用对应的 Python/Golang 函数。
    * 获取运行结果（Observation）。
4. **更新记忆**：
    * 将 `Action` 和 `Observation` 追加到 `Scratchpad` 中。
5. **循环**：
    * 带着更新后的 Prompt 再次询问 LLM，直到得出最终答案或达到最大重试次数（防止死循环）。

## 3. Multi-Agent 的协作模式

当单 Agent 能力不足时，引入多 Agent 协作。

### 3.1. 交互形式

* **合作型 (Cooperative)**：
    * **无序**：头脑风暴，自由表达。
    * **有序**：流水线作业（如 SOP），按顺序发言。
* **对抗型 (Adversarial)**：
    * 通过辩论、反思来纠正错误（如 Self-RAG 中的 Critic 角色）。

### 3.2. 控制架构

* 需要一个 **Controller**（可以是规则状态机，也可以是另一个 LLM）来管理 Agent 之间的通信路由，决定下一个由谁行动。

## 4. 现实应用辨析：谁是真正的 Agent？

在编程辅助领域，我们可以根据“自主性”和“闭环能力”来区分工具属性。

### 4.1. 判定标准

一个真正的 Agent 必须具备以下特征：

1. **环境交互能力**：不仅能生成文本，还能直接操作文件（CRUD）、运行终端命令。
2. **自我修正闭环**：能看到运行报错（Observation），并根据报错自主修改代码，而不是等着人来修。
3. **多步规划**：能处理模糊目标（如“把这个应用容器化”），而不是单一指令（如“写个 Dockerfile”）。

### 4.2. 工具分类对照表

| 工具名称 | 归属阶段 | 核心行为 | 你的角色 |
| :--- | :--- | :--- | :--- |
| **GitHub Copilot (基础版)** | **Chain / 高级 Prompt** | RAG 检索上下文 -> 代码补全 | **机长**：你负责决策和操作，它负责建议。 |
| **Gemini-cli (问答模式)** | **Prompt** | 文本问答 | **操作员**：你手动复制粘贴命令去执行。 |
| **Cursor (Composer 模式)** | **Agent** | 读取全库 -> 规划 -> 修改多文件 -> (可选)运行测试 | **监督者**：你给目标，它执行并尝试解决问题。 |
| **Devin / OpenHands** | **Agent (完全体)** | 拥有独立沙盒环境，自主查文档、写代码、调试、部署 | **验收者**：它像一个远程员工，全自动干活。 |
| **MetaGPT / ChatDev** | **Multi-Agent** | 多个虚拟角色（PM, Dev, QA）互相吵架、协作、Code Review | **老板**：你只给一句话需求，它们产出整个项目。 |

## 5. 总结

* **从 Chain 到 Agent 的质变**：在于**去掉了硬编码的流程图**。Chain 是“如果你遇到 A，就执行 B”；Agent 是“这是目标和工具，你自己想办法解决”。
* **Agent 的核心是 Loop**：通过不断地将“执行结果”反馈给“大脑”，实现了对环境的感知和适应。
* **未来趋势**：单 Agent 容易钻牛角尖，**Multi-Agent** 通过角色分工（SOP）来提升复杂任务的稳定性和成功率。