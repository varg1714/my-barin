---
source:
  - "[[交易数据频繁变化，100W 用户如何实时通知，如何降低数据库压力？（第 112 讲，收藏）]]"
create: 2025-11-15
---
## 1. 核心问题

如何为百万级用户提供频繁变化的交易数据实时通知，同时有效降低数据库的压力。

**业务场景抽象：**
* **用户量：** 百万级别客户端
* **数据实体：** 万级别（如股票）
* **写入量：** 每秒百级别
* **计算复杂度：** 涉及求和、分组、排序等复杂操作

## 2. 架构设计与技术选型

### 2.1. 客户端与服务端连接

* **方案：** 采用 **TCP 长连接**。
* **优势：** 避免了短连接频繁建立和销毁的开销，极大提升性能，降低服务器压力。

### 2.2. 实时通知方案（推送模型）

当实时性要求高时，采用服务端推送。

* **推送集群：**
    * 建立独立的**推送集群**，专门维护与客户端的 TCP 长连接并负责推送。
    * 可水平扩展（例如：10 台服务器，每台维护 10W 连接，共服务 100W 用户）。
* **业务解耦：**
    * 使用 **MQ (消息队列)** 将**推送集群**与**业务集群**解耦。
    * **业务集群**负责复杂的计算，并将计算好的最终结果（待推送的消息内容）发送到 MQ。
    * **推送集群**仅消费 MQ 中的消息并推送给客户端，不包含任何业务逻辑。
* **推送优化：**
    * **消息量不大时：** 多线程并发推送。
    * **消息量巨大时：** **批量推送**。例如，将 1 秒内的消息暂存起来，然后一次性批量推送给客户端。

### 2.3. 数据库压力优化

* **写压力：**
    * **常规写入（秒级百/千次）：** 单个数据库通常可以承受。
    * **高写入（秒级万次）：** 采用**数据库水平切分**（如按股票 ID 分库），线性提升写入能力。
    * **极高写入（秒级十万/百万次）：** 在数据库前加入 **MQ**，用于缓冲请求，实现**削峰填谷**，保护数据库。
* **读压力（核心优化点）：**
    * **问题：** 频繁的 `sum/group by/order by` 等复杂查询会拖垮数据库。
    * **解决方案：** **缓存 + 定时计算**。
        1. 创建一个**异步线程**，每秒钟访问一次数据库。
        2. 该线程执行复杂的业务逻辑计算。
        3. 将计算结果存入**高可用缓存**（如 Redis）。
        4. 所有客户端的读请求都直接从缓存中获取数据，不再查询数据库。
    * **设计权衡 (Trade-off)：** 此方案带来了数据一致性上的延迟。用户最差情况下会读到 **1 秒前**的数据。这是性能与一致性之间的典型权衡。

## 3. 简化方案（拉取模型）

如果业务场景满足以下条件，可以采用更简单的轮询拉取方案：

* 在线用户量不大。
* 用户能接受较长的时延（例如 5 秒）。
* **架构：**
    1. 移除推送集群和 MQ。
    2. 业务数据仍然由异步线程每秒计算一次并写入缓存。
    3. 客户端每 5 秒**轮询拉取**一次数据，请求直接访问缓存。

## 4. 总结

1. **连接：** 优先使用**长连接**。
2. **推送：** 当推送量巨大时，通过**独立推送集群 + MQ** 与业务逻辑解耦。
3. **写入：** 通过**水平切分**和 **MQ 缓冲**来扩展写入能力和保护数据库。
4. **读取：** 核心优化是**避免让每个读请求都直接操作数据库进行复杂计算**。采用**缓存 + 异步定时计算**的策略，用可接受的延迟换取巨大的性能提升和数据库压力的降低。
5. **核心思路：** 思路比结论更重要，根据实际业务场景（用户量、实时性要求）选择合适的架构，避免过度设计。