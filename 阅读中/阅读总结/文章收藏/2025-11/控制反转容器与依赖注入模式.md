---
source:
  - "[[阅读中/文章列表/文章收藏/2025-11/控制反转容器与依赖注入模式|控制反转容器与依赖注入模式]]"
create: 2025-11-07
---
## 1. 核心问题

文章以一个 `MovieLister` 类需要查找电影的功能为例。`MovieLister` 依赖一个 `MovieFinder` 接口，但我们不希望 `MovieLister` 直接实例化一个具体的 `MovieFinder` 实现（如 `new ColonDelimitedMovieFinder(...)`），因为这会造成紧密耦合，使得更换数据源（如从文件换成数据库）变得困难。

**目标：** 让 `MovieLister` 依赖 `MovieFinder` 接口，但不知道其具体实现。应用程序的组装模块可以在运行时“插入”一个具体的实现。

## 2. 核心概念

### 2.1. 控制反转 (Inversion of Control - IoC)

- **是什么**：一个广泛的设计原则，指程序控制权的转移。通常，我们的代码调用框架；在 IoC 中，框架调用我们的代码。
- **在本文中**：特指 **依赖关系查找的控制权** 被反转了。组件不再主动创建或查找其依赖，而是被动地等待外部容器将依赖提供给它。

### 2.2. 依赖注入 (Dependency Injection - DI)

- **是什么**：IoC 的一种更具体的实现模式。它通过一个外部实体（组装器或容器）来解析组件的依赖，并将依赖的实例“注入”到组件中。
- **基本思想**：有一个独立的 **组装器 (assembler)**，它负责创建依赖的实例，并将其设置到需要它的组件中。

## 3. 依赖注入的三种主要形式

### 3.1. a. 构造函数注入 (Constructor Injection)

- **方式**：通过类的构造函数传入依赖。
- **示例**：

  ```java
  public class MovieLister {
      private MovieFinder finder;
      
      public MovieLister(MovieFinder finder) {
          this.finder = finder;
      }
  }
  ```

- **优点**：
  - 保证对象在创建后就是完整且有效的状态。
  - 可以清晰地将依赖声明为不可变（`final`）。
- **缺点**：
  - 当依赖项过多时，构造函数会变得很长。
  - 在继承体系中可能导致构造函数爆炸。

### 3.2. b. Setter 注入 (Setter Injection)

- **方式**：通过公开的 `setXxx` 方法传入依赖。
- **示例**：

  ```java
  public class MovieLister {
      private MovieFinder finder;
      
      public void setFinder(MovieFinder finder) {
          this.finder = finder;
      }
  }
  ```

- **优点**：
  - 更灵活，可以随时更改依赖（尽管不推荐）。
  - 对于可选依赖非常友好。
  - Setter 方法名可以清晰地表明依赖的用途。
- **缺点**：
  - 无法保证对象在所有依赖被设置前是完整的。

### 3.3. c. 接口注入 (Interface Injection)

- **方式**：组件实现一个特定的注入接口，容器通过该接口来注入依赖。
- **示例**：

  ```java
  public interface InjectFinder {
      void injectFinder(MovieFinder finder);
  }

  public class MovieLister implements InjectFinder {
      // ...
      public void injectFinder(MovieFinder finder) {
          this.finder = finder;
      }
  }
  ```

- **优点**：更明确。
- **缺点**：侵入性强，需要为不同的依赖定义大量接口，导致代码冗余。

## 4. 替代方案：服务定位器 (Service Locator)

- **是什么**：另一种解耦依赖的模式。它提供一个全局的注册表对象（定位器），组件可以从中主动“拉取”它需要的依赖。
- **与 DI 的区别**：
  - **DI 是“推” (Push)**：依赖被动地由容器推给组件。
  - **服务定位器是“拉” (Pull)**：组件主动向定位器请求依赖。
- **示例**：

  ```java
  public class MovieLister {
      private MovieFinder finder;
      
      public MovieLister() {
          // 主动从定位器获取依赖
          this.finder = ServiceLocator.getService("MovieFinder");
      }
  }
  ```

- **缺点**：
  - 组件依赖于服务定位器本身，引入了新的耦合。
  - 依赖关系被隐藏在代码内部，不够明确。

## 5. 如何选择？

| 比较维度 | 服务定位器 (Service Locator) | 依赖注入 (Dependency Injection) | 结论 |
| :--- | :--- | :--- | :--- |
| **依赖关系** | 组件依赖于定位器。 | 组件不依赖于容器。 | **DI 胜出**，尤其对于需要被复用的组件。 |
| **依赖可见性** | 依赖隐藏在代码中，不直观。 | 依赖在构造函数或 Setter 中清晰可见。 | **DI 胜出**，代码更易于理解和维护。 |
| **使用场景** | 适用于应用程序内部，当所有组件都共用一个定位器时。 | 适用于构建供外部使用的、独立的组件。 | 各有适用场景，但 DI 更通用。 |
| **测试** | 如果设计良好（非硬编码单例），同样易于测试。 | 非常易于测试，可以直接注入模拟（Mock）对象。 | 两者都可测试，但 DI 的方式更自然。 |

**构造函数注入 vs. Setter 注入**
> **经验法则**：默认使用 **构造函数注入**。当遇到参数过多、有多个可选依赖或需要更清晰的命名时，再考虑切换到 **Setter 注入**。

**代码配置 vs. 配置文件**
> **最佳实践**：始终提供一个 **编程接口** 来进行配置。配置文件（如 XML）应作为该接口之上的一个可选层，而不是唯一选择。

## 6. 最终结论

**最重要的原则不是选择哪种模式，而是实现“服务配置”与“服务使用”的分离。**

无论是使用依赖注入还是服务定位器，其最终目的都是为了让应用程序的业务逻辑与其依赖的具体实现和组装方式解耦。只要做到了这一点，你的系统就会更加灵活、可维护和可测试。