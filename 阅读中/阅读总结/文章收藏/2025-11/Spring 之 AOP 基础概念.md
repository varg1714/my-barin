---
source:
  - https://pdai.tech/md/spring/spring-x-framework-aop.html
create: 2025-11-07
---

## 1. AOP 是什么？(What is AOP?)

AOP（Aspect Oriented Programming），即**面向切面编程**，是一种编程思想，旨在通过**横向切割**的方式，将散布于多个业务逻辑中的通用功能（如日志记录、事务管理、权限校验等）抽取出来，形成独立的模块，即“切面”（Aspect）。

- **核心目标**：**解耦**。它将核心业务逻辑与非核心的、横切的关注点分离开来，提高了代码的模块化程度、可重用性和可维护性。
- **与 OOP 的关系**：
    - **OOP (面向对象编程)**：纵向的抽象，将事物的属性和行为封装成对象，构建业务实体。
    - **AOP (面向切面编程)**：横向的抽象，针对业务处理过程中的某个阶段或步骤进行提取，关注的是跨越多个对象的通用行为。

![AOP vs OOP](https://pdai.tech/images/spring/springframework/spring-framework-aop-2.png)

## 2. AOP 核心术语

理解 AOP 的关键在于掌握以下核心概念：

| 术语 | 英文 | 解释 | 通俗理解 |
| :--- | :--- | :--- | :--- |
| **连接点** | Jointpoint | 程序执行过程中的一个点，如方法执行、异常处理等。在 Spring AOP 中，仅支持**方法执行**连接点。 | **在哪里干** |
| **切入点** | Pointcut | 一个或多个连接点的集合。它定义了“在哪些方法上”应用切面逻辑。通常使用表达式来定义。 | **在哪里干的集合** |
| **通知** | Advice | 在切入点上执行的具体操作，即切面要做的具体工作。 | **干什么** |
| **切面** | Aspect | 通知（Advice）和切入点（Pointcut）的组合。它是一个完整的横切关注点的模块化实现。 | **在哪干和干什么集合** |
| **目标对象** | Target Object | 被一个或多个切面所通知的对象，即真正包含核心业务逻辑的类。 | **对谁干** |
| **织入** | Weaving | 将切面应用到目标对象上，并创建出代理对象的过程。 | **怎么实现的** |
| **AOP 代理** | AOP Proxy | AOP 框架创建的、用来实现切面功能的对象。在 Spring 中，它是 JDK 动态代理或 CGLIB 代理的实例。 | **实现方式的一种** |

### 2.1. 通知 (Advice) 的五种类型

1. **前置通知 (Before)**: 在目标方法执行**之前**执行。
2. **后置通知 (After Returning)**: 在目标方法**正常返回**后执行，可以获取到方法的返回值。
3. **异常通知 (After Throwing)**: 在目标方法抛出**异常**后执行，可以获取到异常信息。
4. **最终通知 (After/Finally)**: 无论目标方法是否正常执行完毕（无论是否抛出异常），**最终都会**执行。
5. **环绕通知 (Around)**: 最强大的通知类型。它包围了整个连接点，可以在方法执行前后自定义行为，并且可以决定是否执行目标方法、修改返回值或抛出异常。

## 3. Spring AOP 与 AspectJ 的关系 (核心解惑)

这是最容易混淆的部分，关键在于理解 Spring 是如何“借力”AspectJ 的。

| 对比项 | Spring AOP | AspectJ |
| :--- | :--- | :--- |
| **实现方式** | 纯 Java 实现，基于**运行时动态代理**。 | 对 Java 语言的扩展，基于**编译期/加载期织入**。 |
| **织入时机** | **运行时 (Runtime)** 创建代理对象。 | **编译时 (Compile-time)** 或 **类加载时 (Load-time)** 修改字节码。 |
| **侵入性** | 无侵入性，不需要特殊编译器。 | 需要 `ajc` 编译器或 LTW（加载时织入）配置。 |
| **功能强度** | 较弱，仅支持**方法执行**连接点。 | 非常强大，支持字段、构造函数、静态方法等几乎所有连接点。 |
| **应用对象** | 只能应用于 Spring 容器管理的 Bean。 | 可以应用于任何 Java 对象。 |
| **性能** | 略低于 AspectJ，因为涉及代理调用。 | 性能更高，因为代码在编译时已织入。 |

### 3.1. Spring 如何使用 AspectJ？

Spring AOP 并非 AspectJ 的完整实现，而是一种巧妙的结合：

1. **借用注解标准**：Spring 采纳了 AspectJ 定义的 `@Aspect`, `@Pointcut`, `@Before` 等注解作为其 AOP 的标准语法。因为这套语法非常成熟和强大。
2. **使用解析引擎**：Spring 框架内部集成了 AspectJ 的库，但**仅用于解析切入点表达式**（如 `execution(...)`）。当 Spring 启动时，它会找到 `@Aspect` 注解的类，并使用 AspectJ 的工具来确定哪些方法需要被增强。
3. **采用自身实现**：在确定了目标后，Spring **并不会**使用 AspectJ 的编译器去修改字节码。相反，它会回归到自己的核心实现——**动态代理**。在运行时为目标 Bean 创建一个代理对象，并将切面逻辑应用到这个代理上。

**总结一句话：Spring AOP 使用了 AspectJ 的“设计图纸”（注解和切入点表达式），但用了自己的“施工队”（动态代理）来完成工作。**

## 4. Spring AOP 的实现方式

Spring AOP 的织入是在**运行时**通过**动态代理**技术完成的。

- **JDK 动态代理**：
    - **条件**：目标对象必须实现一个或多个接口。
    - **原理**：在运行时动态创建一个实现了目标接口的代理类。
- **CGLIB 代理**：
    - **条件**：当目标对象没有实现任何接口时，Spring 会使用此方式。
    - **原理**：通过继承目标类，在运行时动态创建一个子类作为代理对象。

## 5. AOP 实用技巧与常见问题

### 5.1. 切入点表达式 (Pointcut Expression)

`execution` 表达式是最常用的，其格式为：

`execution(修饰符? 返回类型 声明类型? 方法名(参数) 异常?)`

- `*`：匹配任意单个元素。
- `..`：匹配任意多个元素。在方法参数中表示任意数量、任意类型的参数；在包名中表示当前包及其所有子包。

**常用示例**：

```java
// 匹配 service 包下所有类的所有公共方法
execution(public * tech.pdai.springframework.service.*.*(..))

// 匹配 service 包及其所有子包下所有类的所有方法
execution(* tech.pdai.springframework.service..*.*(..))

// 匹配任何以 "set" 开头的方法
execution(* set*(..))
```

### 5.2. 多通知的执行顺序

当多个切面的通知应用在同一个连接点时，执行顺序可以通过以下方式控制：

- 在切面类上实现 `org.springframework.core.Ordered` 接口。
- 在切面类上使用 `@org.springframework.core.annotation.Order(value)` 注解。

**规则**：`value` 值越小，优先级越高。
- **进入时**（如 `@Before`）：优先级高的先执行。
- **退出时**（如 `@After`）：优先级高的后执行。

### 5.3. Spring AOP 还是 AspectJ？

- **选择 Spring AOP**：如果你的需求只是对 Spring Bean 的方法进行增强（如事务、日志），并且追求简单、无侵入的开发体验，Spring AOP 是最佳选择。这是绝大多数企业应用场景。
- **选择 AspectJ**：如果你需要通知非 Spring 管理的对象，或者需要增强方法执行以外的连接点（如字段访问、构造函数调用），那么你需要功能更强大的 AspectJ。