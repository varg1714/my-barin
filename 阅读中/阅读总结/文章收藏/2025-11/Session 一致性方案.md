---
source:
  - "[[保证 session 一致性究的 5 种方法！（第 40 讲）]]"
create: 2025-11-04
---

## 1. 核心概念：Session 与 Session 一致性

1. **什么是 Session？**
    * Session（会话）是服务器为每个独立用户创建的上下文信息存储区。它使得基于 HTTP 这种无状态协议的应用，能够跟踪和识别用户的多次请求，从而保持用户的登录状态、购物车信息等。

2. **什么是 Session 一致性问题？**
    * 在单体服务器架构中，不存在此问题，因为所有请求都由同一台服务器处理。
    * 当系统为了高可用而部署了多台 Web-Server 时，用户的连续请求可能会被反向代理（如 Nginx）分发到不同的服务器上。如果用户的 Session 信息只存在于第一台服务器，那么当请求被转发到第二台服务器时，服务器会因为找不到 Session 而要求用户重新登录，这就是 **Session 一致性问题**。

## 2. 深入理解：Session 在服务端的具体实现 (以 Tomcat 为例)

Session 机制的核心是**数据在服务端，凭证在客户端**。

* **存储形式**：在 Tomcat 这类 Servlet 容器中，Session 是一个 `HttpSession` 对象，它以键值对的形式保存在**服务器的内存**中。Tomcat 内部维护着一个全局的 Map，`Key` 是 Session ID，`Value` 就是 `HttpSession` 对象。
* **关联机制**：
    1. **创建与下发**：当用户首次访问时，服务器会创建一个新的 `HttpSession` 对象，并为其生成一个全局唯一的 **Session ID**。
    2. **客户端保存**：服务器通过 HTTP 响应头 `Set-Cookie` 将这个 Session ID（通常 Cookie 名为 `JSESSIONID`）发送给客户端浏览器。
    3. **请求时携带**：浏览器在后续的每一次请求中，都会自动在 HTTP 请求头里带上这个存有 Session ID 的 Cookie。
* **服务端获取**：服务器收到请求后，会解析 Cookie 中的 Session ID，并用它在内存的全局 Map 中查找对应的 `HttpSession` 对象。找到后，业务代码便可以通过 `request.getSession()` 方法获取到这个对象，进而读写其中的数据。

## 3. 保证 Session 一致性的 5 种架构方案

### 3.1. 方案一：Session 同步法

* **思路**：在多台 Web-Server 之间实时同步所有 Session 数据，确保每台服务器都拥有全量的 Session 信息。
* **优点**：对应用程序完全透明，无需修改代码。
* **缺点**：
    * **占用内网带宽**：数据同步产生网络开销，且有延迟。
    * **内存限制**：每台服务器都需存储所有 Session，内存成本高，无法有效水平扩展。
    * **扩展性差**：服务器数量增多时，同步的网络拓扑会变得非常复杂，性能急剧下降。

### 3.2. 方案二：客户端存储法

* **思路**：将完整的 Session 数据（而不仅仅是 Session ID）直接存储在客户端的 Cookie 中。
* **优点**：服务端无需存储 Session，减轻了服务器的内存压力。
* **缺点**：
    * **占用外网带宽**：每次请求都携带完整的 Session 数据，增加了网络传输量。
    * **安全风险**：数据暴露在客户端，即使加密也存在泄露、篡改、窃取的风险。
    * **大小限制**：浏览器对 Cookie 的大小有严格限制（通常为 4KB），无法存储复杂数据。
* **特别说明**：
    * 文章中说此方案“不常用”，指的是这种**将所有动态、有状态的 Session 数据全部放在客户端**的模式。
    * 这与我们常用的 **JWT (JSON Web Token)** 不同。JWT 主要用于**无状态认证**，它将用户的身份信息和权限（Claims）签名后存储在客户端。服务器无需保存任何状态，只需验证 JWT 的签名即可信任其内容。JWT 解决了认证授权问题，但不适合存储像购物车这样需要频繁动态修改的业务状态。

### 3.3. 方案三 & 四：反向代理 Hash 一致性

* **思路**：通过配置反向代理（如 Nginx），使其根据特定规则进行 Hash 计算，确保来自同一用户的请求始终被转发到同一台 Web-Server。
* **两种实现**：
    1. **四层代理 Hash**：基于网络层信息，通常是用户的 **IP 地址**进行 Hash。
    2. **七层代理 Hash**：基于应用层信息，如 HTTP Header 中的 `user_id`、`session_id` 等业务字段进行 Hash，更灵活。
* **优点**：
    * 配置简单，无需修改应用代码。
    * 只要 Hash 键分布均匀，就能实现良好的负载均衡。
    * 支持 Web-Server 水平扩展。
* **缺点**：
    * **单点问题依旧**：如果某台 Web-Server 宕机或重启，存储在该服务器上的所有 Session 都会丢失。
    * **扩缩容问题**：当增加或减少服务器时，Hash 环会发生变化（rehash），导致大量用户的请求被重新路由，造成大部分 Session 失效。

### 3.4. 方案五：后端统一存储（业界最常用）

* **思路**：将 Session 数据从各个 Web-Server 的内存中抽离出来，统一存放到一个独立的、所有服务器都能访问的后端存储层。
* **常用存储**：高速缓存（如 **Redis**、Memcached）或数据库（不推荐）。
* **优点**：
    * **高可用**：Web-Server 变成无状态节点，可以随意重启、宕机或扩缩容，Session 数据不会丢失。
    * **扩展性好**：存储层自身可以做水平扩展，理论上没有瓶颈。
    * **安全性高**：数据存储在内网，没有客户端存储的安全风险。
* **缺点**：
    * **增加网络调用**：每次 Session 读写都增加了一次网络请求，会轻微增加响应延迟。
    * **需要代码改造**：应用程序需要修改代码以适配从外部存储读写 Session 的逻辑。
* **存储选型建议**：强烈推荐使用 **Redis** 等缓存系统。因为 Session 的读写非常频繁，对性能要求高，数据库的 I/O 开销难以承受。
