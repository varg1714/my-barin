---
source: "[[破解 gh-ost 变更导致 MySQL 表膨胀之谜｜得物技术]]"
create: 2025-09-19
---

## 1. 笔记：gh-ost 变更导致 MySQL 表膨胀问题深度解析

### 1.1. 一、核心问题概述 (TL; DR)

在使用 `gh-ost` 工具对 MySQL 表进行 DDL 变更后，可能会在特定条件下引发一系列连锁问题：表空间膨胀、统计信息严重失准、以及部分 SQL 变慢。

**根本原因**：`gh-ost` 的**并行工作机制**（全量复制与增量应用 binlog 同步进行） + **大行记录** + **InnoDB 页分裂的内在瑕疵**，这三者共同作用，导致页分裂后大量数据页（Page）上仅存储一条记录，造成空间严重浪费。

### 1.2. 二、问题现象：连锁反应

1.  **表空间膨胀**：变更后的表体积几乎翻倍。
2.  **统计信息严重偏差**：`SELECT COUNT(*)` 正常，但优化器依赖的表行数估算值（如 `SHOW TABLE STATUS`）严重偏低。
3.  **慢 SQL 查询**：带有 `ORDER BY ... LIMIT ...` 的 SQL 语句，优化器错误地选择了性能更差的索引。

### 1.3. 三、根本原因：一场“完美风暴”

> [!DANGER] 触发条件
> 这个问题的发生并非普遍现象，需要以下三个关键条件同时满足：
> 1.  **`gh-ost` 的并行机制**：这是问题的导火索。
> 2.  **大行记录 (Large Rows)**：这是问题的催化剂。
> 3.  **持续的写入压力**：保证了问题场景的持续复现。

#### 1.3.1. 导火索：`gh-ost` 的并行机制

-   `gh-ost` 为了实现在线变更，会同时进行两个操作：
    1.  **全量复制**：按主键顺序从原表拷贝数据到“影子表”。
    2.  **增量同步**：监听 binlog，将变更（`INSERT`, `UPDATE`, `DELETE`）实时应用到“影子表”。
-   **关键影响**：这导致了非顺序插入。新的、主键 ID 较大的记录（来自 binlog 的 `INSERT`）可能比旧的、主键 ID 较小的记录（来自全量复制）更早地被写入“影子表”。

#### 1.3.2. 催化剂：大行记录

-   原文中的业务表单行记录很大（约 5KB），一个 16KB 的 InnoDB 页本身就只能存放 2-3 条记录。
-   这使得页的存储对分裂算法非常敏感。任何不当的分裂都会立刻导致空间利用率减半（从 2 条/页 -> 1 条/页）。
-   如果行记录很小，页内有足够空间进行重组，不容易触发此问题。

#### 1.3.3. 结果：InnoDB 页分裂瑕疵被触发

-   当“大主键记录已存在，小主键记录尝试插入”的场景频繁发生时，InnoDB 的页分裂逻辑（特别是向右分裂的启发式算法 `btr_page_get_split_rec_to_right`）会做出不佳决策。
-   最终导致分裂后的旧页上，只留下一条孤零零的记录，造成了巨大的空间浪费，从而引发了表膨胀。

### 1.4. 四、问题传导：从表膨胀到慢 SQL

#### 1.4.1. 为何统计信息会失准？

> [!NOTE] 关键知识点：InnoDB 统计信息的 `-1` 修正
> InnoDB 估算索引基数（唯一值数量）时，采用的是**抽样统计**。为了避免因统计到**跨页的边界重复值**（如 Page1 的末尾是 `id=99`，Page2 的开头也是 `id=99`）而高估唯一值的数量，它采用了一个简单的修正策略：**将每个采样页统计出的唯一值数量减 1**。

-   **问题所在**：由于表膨胀，大量页上只有 **1** 条记录。
-   **计算过程**：当采样到这些页时，InnoDB 统计出唯一值为 `1`，然后应用修正 `1 - 1 = 0`。
-   **最终结果**：优化器认为这些页上没有任何有效数据，导致对全表总行数的估算严重偏低。

#### 1.4.2. 为何 SQL 会变慢？

-   **场景**：`... WHERE a=1 ORDER BY time LIMIT 10`
-   **优化器困境**：
    1.  **方案 A**：走 `idx_a` 索引，过滤快，但结果集需要文件排序（`filesort`），成本高。
    2.  **方案 B**：走 `idx_time` 索引，结果天然有序，无需排序，但需要扫描很多行才能满足 `WHERE a=1` 的条件。
-   **错误决策**：优化器在估算方案 B 的成本时，会使用一个依赖于**全表总行数**的公式。由于统计信息失准，它严重低估了扫描成本，错误地认为方案 B 更优。
-   **实际执行**：MySQL 走了 `idx_time` 索引，扫描了大量不必要的数据，导致慢查询。

### 1.5. 五、解决方案

#### 1.5.1. 临时方案

-   执行原生 DDL：`ALTER TABLE xxx ENGINE=InnoDB;`
-   **原理**：该命令会顺序地重建表（先全量拷贝，再应用增量），修复了页的存储。
-   **缺点**：无法限速，可能导致主从延迟。

#### 1.5.2. 长期解决方案

-   **优化 `gh-ost` 流程**：将并行模式改为**串行模式**。
    1.  **第一步**：完成全量数据复制。
    2.  **第二步**：完成之后，再开始应用增量 binlog。
-   **原理**：保证了数据是按主键大致顺序插入的，从根源上避免了触发异常页分裂的条件。
-   **社区支持**：这并非得物独创，`gh-ost` 社区早已意识到此问题，并通过 **PR #1378 ** 提供了此功能作为可选项。新版本的 `gh-ost` 已支持这种更安全的工作模式。
