---
source: "[[为什么我的 TLS 1_3 多了一个 RTT]]"
create: 2025-09-12
---

## 1. 核心问题

作者将服务升级到 TLS 1.3，期望利用其 1 RTT 握手的特性来降低延迟，但实际测试发现握手仍然花费了 2 RTT 的时间。

## 2. 排查过程

1.  **初步检查**：作者首先确认了软件版本和 TLS 1.3 的相关配置均无异常。
2.  **网络抓包分析**：使用 Wireshark 工具进行抓包分析，发现问题出在服务器端。服务器在收到了客户端的 ACK 确认包之后，才发送 `Certificate Verify` 和 `Finished` 这两个握手消息，从而多出了一个 RTT 的延迟。
3.  **定位根本原因**：
    *   作者推断问题可能与 TCP 层的机制有关，并排查了接收方窗口（RWND）、MSS、拥塞控制等多种可能因素，但都未找到原因。
    *   最终，通过检查服务配置，发现了一个关键设置：`tcp_nodelay off`。这个设置意味着服务开启了 **Nagle 算法**。

## 3. 问题根源：Nagle 算法

*   **作用**：Nagle 算法旨在通过将多个小数据包合并成一个大数据包来减少网络中的小包数量，从而提高网络效率。它本质上是**用延迟换取更高的有效载荷比**。
*   **机制**：当一个 TCP 连接上有未被确认的数据时，Nagle 算法会阻止发送新的小数据包，直到收到前一个数据包的 ACK，或者累积的数据足够多（达到一个 MSS）再一起发送。
*   **如何导致问题**：在 TLS 1.3 握手过程中，服务器发送的某些握手消息（如 `Server Hello` 后的数据）是未满载的小数据包。由于 Nagle 算法被启用，服务器在发送这些小包后，会等待客户端的 ACK，然后才发送后续的 `Certificate Verify` 和 `Finished` 包，这直接导致了额外的 1 RTT 延迟。

## 4. 解决方案与结果

*   **解决方案**：作者通过关闭 Nagle 算法（即设置 `tcp_nodelay on`）来解决此问题。
*   **验证结果**：关闭 Nagle 算法后，服务器不再等待客户端的 ACK，而是立即发送后续的握手数据包。TLS 握手时间成功减少到预期的 1 RTT。
*   **优化效果**：此项优化为国内用户减少了 10-40ms 的首次访问延迟，海外用户最高可减少上百毫秒。

## 5. 结论与启示

文章得出的核心结论是：**TLS 1.3 的 1 RTT 握手只是其协议逻辑上的优势，最终的端到端交互时间仍然受到底层协议（如 TCP）的影响**。像 Nagle 算法这样的 TCP 机制，虽然在某些场景下（如高带宽利用率）有其价值，但对于延迟敏感的应用（如 Web 访问），通常建议关闭，以避免不必要的延迟。这次排查过程也凸显了深入理解整个网络协议栈重要性。