---
source: "[[阅读中/文章列表/文章收藏/GeoHash 算法学习讲解、解析及原理分析|GeoHash 算法学习讲解、解析及原理分析]]"
---

## 1. 核心思想

GeoHash 是一种地理编码算法，它将二维的经纬度坐标转换成一个一维的、可以排序和比较的字符串。其核心价值在于，**空间上越接近的两个点，其 GeoHash 字符串的共同前缀会越长**。这个特性使得在数据库中进行高效的“附近地点”查询成为可能。

## 2. GeoHash 编码过程

文章通过“常营地铁站”的例子，详细拆解了编码的步骤：

1.  **二分法编码**：
    *   对经度（范围 -180 到 180）和纬度（范围 -90 到 90）分别进行类似二分查找的操作。
    *   每次将当前范围一分为二，如果坐标值落在右半边（较大的一边），则记为 1；落在左半边，则记为 0。
    *   重复这个过程，直到达到所需的精度，最终得到经度和纬度各自的二进制编码串。

2.  **经纬度编码交错合并**：
    *   将上一步得到的经度和纬度二进制串进行合并。规则是：**偶数位放经度，奇数位放纬度**。
    *   文章提到，这种交错方式参考了希尔伯特曲线，目的是让空间上相邻的点在编码后也尽可能相邻。

3.  **分组与 Base32 编码**：
    *   将合并后的二进制串**每 5 位为一组**进行分割。
    *   将每一组 5 位的二进制数转换成一个十进制数（范围 0-31）。
    *   使用一个特定的 Base32 字符集（包含数字 0-9 和 22 个字母，排除了 a, i, l, o）将每个十进制数映射成一个字符。
    *   最终拼接成的字符串就是该坐标的 GeoHash 值，例如 `wx4gjk32kfrx`。

## 3. GeoHash 的特性与优势

*   **前缀匹配**：这是 GeoHash 最核心的优势。可以通过数据库的字符串索引（如 `LIKE 'prefix%'`）快速查询某个区域内的所有点，因为同一区域内的点共享相同的前缀。
*   **精度可控**：GeoHash 字符串的长度决定了其表示的地理区域范围。字符串越长，精度越高，范围越小。例如，长度为 8 的字符串可以精确到 19 米。

## 4. GeoHash 的局限性与解决方案

文章指出了 GeoHash 的一个主要问题：

*   **边界问题**：两个地理位置上非常接近的点，可能因为恰好落在两个不同 GeoHash 区块的边界两侧，而导致它们的 GeoHash 字符串完全不同，失去了前缀匹配的特性。
*   **解决方案**：为了解决这个问题，通行的做法是**不仅查询当前点所在的 GeoHash 区块，同时查询其周围的 8 个相邻区块**。这样，一个 3x3 的九宫格查询就能覆盖所有边界情况，确保不会遗漏附近的目标。

## 5. 应用与思考

*   **实际应用**：该算法广泛应用于“附近的人”、“外卖商家”等 LBS（基于位置的服务）场景。
*   **数据库支持**：文章提到 Redis 从 3.2 版本开始原生支持 Geo 相关命令，底层就是利用了 GeoHash。
*   **作者的思考**：作者提出了一个很好的问题，即地图上显示的搜索范围通常是**圆形**的，而 GeoHash 计算的是**矩形**区块。这引出了一个实践中的常见做法：后端通过查询 9 个矩形区块（一个比实际需要稍大的范围）来粗略筛选数据，然后在应用层对返回的结果再进行精确的圆形距离计算和过滤。

总的来说，这篇文章深入浅出地介绍了 GeoHash 算法，从基本概念到详细的计算步骤，再到其优缺点和实际应用，内容非常完整且易于理解。文末对常营地铁站 GeoHash 值的详细演算过程也极大地帮助了读者理解。