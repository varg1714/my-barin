---
source: "[[美团面试：CMS 原理什么？漏标 + 多标 + 浮动垃圾 如何解决？90％ 的程序员都答错了！]]"
---
## 1. 文章核心内容分析

这篇文章是一篇针对 Java 虚拟机（JVM）中 CMS（Concurrent Mark Sweep）垃圾回收器的深度解析，主要面向准备互联网大厂（如美团）面试的开发者。文章从 CMS 的基本原理、工作流程、核心问题及其解决方案等多个维度进行了详细阐述。

## 2. CMS 垃圾回收器概述

*   **设计目标**：CMS 是一款以获取**最短回收停顿时间**为目标的老年代垃圾回收器，追求低延迟，非常适合对响应速度有高要求的应用（如 Web 服务）。
*   **核心算法**：它基于“**标记-清除**”（Mark-Sweep）算法。
*   **历史地位**：在 JDK 1.5 中引入，在 JDK 9 中被 G1 取代成为默认回收器，并最终在 JDK 14 中被移除。尽管已被淘汰，但其设计思想对后续的 GC（如 G1、ZGC）有深远影响，且在一些老旧系统中仍在使用，因此理解其原理在面试中依然重要。

## 3. CMS 工作流程

文章详细介绍了 CMS 的工作流程，并解释了为什么有的资料说是 4 个阶段，有的说是 7 个阶段。

*   **简化版（4 个阶段）**：
    1.  **初始标记 (Initial Mark)**：STW（Stop The World），标记 GC Roots 能直接关联到的对象，速度很快。
    2.  **并发标记 (Concurrent Mark)**：与用户线程并发执行，遍历整个对象引用链。耗时最长，但不停顿。
    3.  **重新标记 (Remark)**：STW，修正并发标记期间因用户程序变动而产生的标记错误。
    4.  **并发清除 (Concurrent Sweep)**：与用户线程并发执行，清除未标记的垃圾对象。

*   **详细版（7 个阶段）**：在并发标记和重新标记之间增加了两个预处理阶段，目的是为了减轻“重新标记”阶段的 STW 负担。
    *   (1) 初始标记
    *   (2) 并发标记
    *   (3) **预清理 (Preclean)**：并发阶段，处理并发标记期间产生的“脏卡”，减少 Remark 阶段的工作量。
    *   (4) **可终止的预清理 (Abortable Preclean)**：并发阶段，进一步处理引用变化，但有超时或满足特定条件后会终止，避免无限等待，保证 Remark 阶段能及时开始。
    *   (5) 重新标记
    *   (6) 并发清除
    *   (7) **重置 (Reset)**：并发阶段，重置内部数据结构，为下一次 GC 做准备。

## 4. 核心问题及解决方案（面试重点）

文章的核心部分解答了标题中提出的几个关键面试问题，这些问题都与 CMS 在并发标记时如何处理对象引用变化有关。

### 4.1. 漏标 (Missed Marking)

*   **问题描述**：在并发标记期间，一个原本存活的对象被错误地当成垃圾回收掉。这是一个**严重的功能性错误**。
*   **产生条件**：
    1.  一个黑色对象（已扫描完）引用了一个白色对象（未扫描）。
    2.  一个灰色对象（正在扫描）到这个白色对象的引用被切断。
*   **解决方案**：CMS 采用“**增量更新 (Incremental Update)**”策略配合“**写屏障 (Write Barrier)**”技术。当一个黑色对象引用了新的白色对象时，写屏障会捕获这个操作，并将这个黑色对象重新标记为灰色（或记录下来），使其在“重新标记”阶段被重新扫描，从而防止漏标。

### 4.2. 多标 (Over-Marking) / 浮动垃圾 (Floating Garbage)

*   **问题描述**：在并发标记期间，一个对象被标记为存活，但随后它变成了垃圾（例如，其引用被切断）。由于已经标记，本次 GC 不会回收它。这个问题不会导致程序出错，但会造成**内存浪费**。这些被多标的垃圾就是“浮动垃圾”。
*   **解决方案**：CMS **无法在本次 GC 中解决**浮动垃圾问题。这些垃圾只能等待**下一次 GC** 时才被回收。这是 CMS 设计上为了保证低延迟而做出的权衡。

### 4.3. Concurrent Mode Failure

*   **问题描述**：在 CMS 并发运行期间，用户线程仍在创建新对象。如果老年代预留的空间不足以容纳这些新对象（或从年轻代晋升上来的对象），就会发生“并发模式失败”。
*   **后果**：JVM 会暂停用户线程（STW），并临时启用 **Serial Old** 回收器来完成一次 Full GC。这会导致非常长的停顿时间，违背了 CMS 低延迟的初衷。
*   **解决方案**：
    *   调低 CMS 的触发阈值 `-XX:CMSInitiatingOccupancyFraction`（例如设置为 70%），让 GC 提早开始。
    *   增加堆内存空间。
    *   开启内存碎片整理参数 `-XX:+UseCMSCompactAtFullCollection`，减少因碎片导致的晋升失败。

## 5. 总结

这篇文章是一份非常详尽的 CMS 面试指南。它不仅解释了 CMS 的工作原理，更重要的是，它清晰地剖析了并发 GC 中最核心的难题——“漏标”和“多标”，并给出了 CMS 的解决方案和设计权衡。

**对于面试者而言，关键要点是：**
1.  理解 CMS 的目标是**低延迟**，其并发特性是实现这一目标的核心。
2.  熟记其**四个核心阶段**，并能解释哪两个阶段是 STW 以及为什么。
3.  能清晰区分“漏标”和“多标”的**本质区别**：漏标是**正确性问题**，必须解决；多标（浮动垃圾）是**性能问题**，可以容忍。
4.  掌握 CMS 解决漏标的机制（**增量更新 + 写屏障**）和处理浮动垃圾的方式（**下次 GC 回收**）。
5.  了解 `Concurrent Mode Failure` 的原因和调优方法。