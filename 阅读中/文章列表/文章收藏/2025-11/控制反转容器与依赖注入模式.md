---
source:
  - https://www.martinfowler.com/articles/injection.html
create: 2025-11-06
read: true
knowledge: true
knowledge-date: 2025-11-07
tags:
  - Spring
  - 框架原理
summary: "[[阅读中/阅读总结/文章收藏/2025-11/控制反转容器与依赖注入模式|控制反转容器与依赖注入模式]]"
---

## 1. 控制反转容器与依赖注入模式

企业级 Java 世界中一件有趣的事情是，在构建主流 J2EE 技术替代方案方面有大量的活动，其中很多都发生在开源社区。这在很大程度上是对主流 J2EE 世界重量级复杂性的一种反应，但其中很多也是在探索替代方案并提出创造性的想法。一个常见的问题是如何将不同的元素装配在一起：当这个 Web 控制器架构和那个数据库接口由不同团队开发，且彼此知之甚少时，你如何将它们组合在一起？许多框架已经尝试解决这个问题，其中一些正在扩展，以提供一种组装来自不同层次组件的通用能力。这些通常被称为轻量级容器，例子包括 [PicoContainer](http://picocontainer.com/) 和 [Spring](http://www.springsource.org/)。

这些容器的底层是一些有趣的设计原则，这些原则超越了这些特定的容器，甚至超越了 Java 平台。在这里，我想开始探讨其中的一些原则。我使用的例子是 Java 语言的，但像我的大多数文章一样，这些原则同样适用于其他面向对象的环境，特别是 .NET。

## 2. 组件与服务

将元素装配在一起这个话题几乎立刻就让我陷入了围绕“服务”和“组件”这两个术语的棘手术语问题中。你可以轻易找到关于这些事物定义的冗长且相互矛盾的文章。出于本文的目的，以下是我当前对这些重载术语的用法。

我用**组件**（component）来指代一块软件，它旨在被一个不受组件编写者控制的应用程序所使用，且无需更改。我所说的“无需更改”是指使用方应用程序不会更改组件的源代码，尽管他们可能会通过组件编写者允许的方式扩展组件来改变其行为。

**服务**（service）与组件类似，因为它也是被外部应用程序使用的。主要区别在于，我期望组件是本地使用的（想象一下 jar 文件、程序集、dll 或源码导入）。而服务将通过某种远程接口（同步或异步）被远程使用（例如 Web 服务、消息系统、RPC 或套接字）。

在本文中，我主要使用“服务”这个词，但很多相同的逻辑也适用于本地组件。实际上，通常你需要某种本地组件框架来方便地访问远程服务。但是，写“组件或服务”读写起来都很累，而且目前服务这个词更时髦。

## 3. 一个简单的例子

为了让这一切更具体，我将使用一个贯穿全文的例子来讨论。像我所有的例子一样，这是一个超级简单的例子；小到不真实，但希望足以让你在不陷入真实例子的泥潭的情况下，形象地理解正在发生的事情。

在这个例子中，我正在编写一个组件，它提供由特定导演执导的电影列表。这个极其有用的功能由一个方法实现。

```java
class MovieLister...

  public Movie[] moviesDirectedBy(String arg) {
      List allMovies = finder.findAll();
      for (Iterator it = allMovies.iterator(); it.hasNext();) {
          Movie movie = (Movie) it.next();
          if (!movie.getDirector().equals(arg)) it.remove();
      }
      return (Movie[]) allMovies.toArray(new Movie[allMovies.size()]);
  }
```

这个函数的实现极其简单，它要求一个 finder 对象（我们稍后会讲到）返回它知道的所有电影。然后它只是遍历这个列表，返回由特定导演执导的那些。这个特别简单的实现我不会去修复，因为它只是本文真正要点的脚手架。

本文的真正要点是这个 finder 对象，或者更具体地说，我们如何将 lister 对象与一个特定的 finder 对象连接起来。这之所以有趣，是因为我希望我出色的 `moviesDirectedBy` 方法完全独立于所有电影的存储方式。所以该方法所做的只是引用一个 finder，而 finder 所做的只是知道如何响应 `findAll` 方法。我可以通过为 finder 定义一个接口来体现这一点。

```java
public interface MovieFinder {
    List findAll();
}
```

现在这一切都解耦得很好，但在某个时候，我必须提供一个具体的类来实际获取电影。在这种情况下，我把这个代码放在我的 lister 类的构造函数中。

```java
class MovieLister...

  private MovieFinder finder;
  public MovieLister() {
    finder = new ColonDelimitedMovieFinder("movies1.txt");
  }
```

这个实现类的名字来源于我从一个冒号分隔的文本文件中获取我的列表。我将省略细节，毕竟重点只是在于存在某种实现。

现在，如果我只是自己使用这个类，这一切都很好。但是，当我的朋友们被这个奇妙功能的渴望所淹没，想要一份我的程序副本时，会发生什么呢？如果他们也把他们的电影列表存储在一个名为“movies1.txt”的冒号分隔文本文件中，那么一切都很美好。如果他们的电影文件有不同的名字，那么把文件名放在一个属性文件中也很容易。但如果他们存储电影列表的形式完全不同呢：一个 SQL 数据库、一个 XML 文件、一个 Web 服务，或者只是另一种格式的文本文件？在这种情况下，我们需要一个不同的类来获取那些数据。现在，因为我定义了一个 `MovieFinder` 接口，这不会改变我的 `moviesDirectedBy` 方法。但我仍然需要某种方法来将正确的 finder 实现的实例放到位。

![图 1：在 lister 类中通过简单创建方式的依赖关系](https://www.martinfowler.com/articles/injection/naive.gif)

图 1 展示了这种情况下的依赖关系。`MovieLister` 类依赖于 `MovieFinder` 接口和其实现。我们更希望它只依赖于接口，但那样我们如何创建一个实例来工作呢？

在我的书《企业应用架构模式》（[P of EAA](https://www.martinfowler.com/books/eaa.html)）中，我们将这种情况描述为**插件**（[Plugin](https://www.martinfowler.com/eaaCatalog/plugin.html)）。finder 的实现类在编译时没有被链接到程序中，因为我不知道我的朋友们会用什么。相反，我们希望我的 lister 能与任何实现一起工作，并且该实现可以在稍后的某个时间点被插入，不受我的控制。问题是，我如何建立这种联系，以便我的 lister 类不知道实现类，但仍然可以与一个实例对话来完成其工作。

将此扩展到一个真实系统中，我们可能有几十个这样的服务和组件。在每种情况下，我们都可以通过接口与这些组件交谈来抽象我们对它们的使用（如果组件没有设计接口，则使用适配器）。但是，如果我们希望以不同的方式部署这个系统，我们需要使用插件来处理与这些服务的交互，以便我们可以在不同的部署中使用不同的实现。

所以核心问题是，我们如何将这些插件组装成一个应用程序？这是新一代轻量级容器面临的主要问题之一，它们普遍都使用**控制反转**来解决。

## 4. 控制反转

当这些容器谈论它们如何因为实现了“控制反转”（Inversion of Control）而如此有用时，我感到非常困惑。**控制反转**是框架的一个共同特征，所以说这些轻量级容器因为使用控制反转而特别，就像说我的车因为有轮子而特别一样。

问题是：“它们反转的是哪方面的控制权？” 当我第一次遇到控制反转时，它是在用户界面的主控中。早期的用户界面是由应用程序控制的。你会有一系列命令，如“输入姓名”、“输入地址”；你的程序会驱动提示并获取每个提示的响应。对于图形化（甚至是基于屏幕的）UI，UI 框架会包含这个主循环，而你的程序则为屏幕上的各种字段提供事件处理器。程序的主控权被反转了，从你手中转移到了框架。

对于这种新一代的容器，反转是关于它们如何查找插件实现。在我的简单例子中，lister 通过直接实例化来查找 finder 实现。这使得 finder 无法成为一个插件。这些容器使用的方法是确保任何插件的使用者都遵循某种约定，允许一个单独的组装模块将实现注入到 lister 中。

因此，我认为我们需要一个更具体的名字来称呼这种模式。控制反转是一个过于通用的术语，因此人们觉得它令人困惑。因此，在与许多 IoC 倡导者的大量讨论后，我们确定了**依赖注入**（Dependency Injection）这个名字。

我将从讨论各种形式的依赖注入开始，但我现在要指出，这并不是从应用程序类中移除对插件实现依赖的唯一方法。你可以使用的另一种模式是**服务定位器**（Service Locator），我将在解释完依赖注入后讨论它。

## 5. 依赖注入的形式

依赖注入的基本思想是有一个单独的对象，一个**组装器**（assembler），它用一个合适的 finder 接口实现来填充 lister 类中的一个字段，从而产生如图 2 所示的依赖关系图。

![图 2：依赖注入器的依赖关系](https://www.martinfowler.com/articles/injection/injector.gif)

依赖注入有三种主要风格。我给它们起的名字是**构造函数注入**（Constructor Injection）、**Setter 注入**（Setter Injection）和**接口注入**（Interface Injection）。如果你在当前关于控制反转的讨论中读到这些东西，你会听到它们被称为类型 1 IoC（接口注入）、类型 2 IoC（setter 注入）和类型 3 IoC（构造函数注入）。我发现数字名称很难记住，这就是为什么我在这里使用我自己的命名。

### 5.1. 使用 PicoContainer 进行构造函数注入

我将从展示如何使用一个名为 [PicoContainer](http://picocontainer.com/) 的轻量级容器来完成这种注入开始。我从这里开始主要是因为我在 Thoughtworks 的几位同事在 PicoContainer 的开发中非常活跃（是的，这是一种公司裙带关系）。

PicoContainer 使用构造函数来决定如何将 finder 实现注入到 lister 类中。为此，movie lister 类需要声明一个包含所有需要注入的东西的构造函数。

```java
class MovieLister...

  public MovieLister(MovieFinder finder) {
      this.finder = finder;       
  }
```

finder 本身也将由 pico 容器管理，因此，文本文件的文件名将由容器注入到其中。

```java
class ColonMovieFinder...

  public ColonMovieFinder(String filename) {
      this.filename = filename;
  }
```

然后需要告诉 pico 容器将哪个实现类与每个接口关联，以及将哪个字符串注入到 finder 中。

```java
private MutablePicoContainer configureContainer() {
    MutablePicoContainer pico = new DefaultPicoContainer();
    Parameter[] finderParams =  {new ConstantParameter("movies1.txt")};
    pico.registerComponentImplementation(MovieFinder.class, ColonMovieFinder.class, finderParams);
    pico.registerComponentImplementation(MovieLister.class);
    return pico;
}
```

这段配置代码通常放在一个不同的类中。在我们的例子中，每个使用我的 lister 的朋友可能会在他们自己的某个设置类中编写适当的配置代码。当然，将这种配置信息保存在单独的配置文件中是很常见的。你可以编写一个类来读取配置文件并适当地设置容器。虽然 PicoContainer 本身不包含此功能，但有一个密切相关的项目叫做 NanoContainer，它提供了适当的包装器，允许你拥有 XML 配置文件。这样的 nano 容器将解析 XML，然后配置一个底层的 pico 容器。该项目的理念是将配置文件格式与底层机制分开。

要使用该容器，你可以编写类似这样的代码。

```java
public void testWithPico() {
    MutablePicoContainer pico = configureContainer();
    MovieLister lister = (MovieLister) pico.getComponentInstance(MovieLister.class);
    Movie[] movies = lister.moviesDirectedBy("Sergio Leone");
    assertEquals("Once Upon a Time in the West", movies[0].getTitle());
}
```

虽然在这个例子中我使用了构造函数注入，但 PicoContainer 也支持 setter 注入，尽管其开发者更喜欢构造函数注入。

### 5.2. 使用 Spring 进行 Setter 注入

[Spring 框架](http://www.springsource.org/)是一个用于企业级 Java 开发的广泛框架。它包括事务、持久化框架、Web 应用程序开发和 JDBC 的抽象层。像 PicoContainer 一样，它同时支持构造函数注入和 setter 注入，但其开发者倾向于更喜欢 setter 注入——这使其成为本例的合适选择。

为了让我的 movie lister 接受注入，我为该服务定义了一个 setting 方法。

```java
class MovieLister...

  private MovieFinder finder;
  public void setFinder(MovieFinder finder) {
    this.finder = finder;
  }
```

类似地，我为文件名定义一个 setter。

```java
class ColonMovieFinder...

  public void setFilename(String filename) {
      this.filename = filename;
  }
```

第三步是为文件设置配置。Spring 支持通过 XML 文件和代码进行配置，但 XML 是预期的方式。

```xml
<beans>
    <bean id="MovieLister" class="spring.MovieLister">
        <property name="finder">
            <ref local="MovieFinder"/>
        </property>
    </bean>
    <bean id="MovieFinder" class="spring.ColonMovieFinder">
        <property name="filename">
            <value>movies1.txt</value>
        </property>
    </bean>
</beans>
```

然后测试代码如下所示。

```java
public void testWithSpring() throws Exception {
    ApplicationContext ctx = new FileSystemXmlApplicationContext("spring.xml");
    MovieLister lister = (MovieLister) ctx.getBean("MovieLister");
    Movie[] movies = lister.moviesDirectedBy("Sergio Leone");
    assertEquals("Once Upon a Time in the West", movies[0].getTitle());
}
```

### 5.3. 接口注入

第三种注入技术是定义和使用接口来进行注入。[Avalon](http://avalon.apache.org/) 是一个在某些地方使用这种技术的框架的例子。我稍后会更多地讨论它，但在这种情况下，我将使用一些简单的示例代码来演示它。

使用这种技术，我首先定义一个我将用来执行注入的接口。这是将 movie finder 注入到一个对象中的接口。

```java
public interface InjectFinder {
    void injectFinder(MovieFinder finder);
}
```

这个接口将由提供 `MovieFinder` 接口的人定义。任何想要使用 finder 的类，比如 lister，都需要实现它。

```java
class MovieLister implements InjectFinder

  public void injectFinder(MovieFinder finder) {
      this.finder = finder;
  }
```

我使用类似的方法将文件名注入到 finder 实现中。

```java
public interface InjectFinderFilename {
    void injectFilename (String filename);
}
```

```java
class ColonMovieFinder implements MovieFinder, InjectFinderFilename...

  public void injectFilename(String filename) {
      this.filename = filename;
  }
```

然后，像往常一样，我需要一些配置代码来连接这些实现。为简单起见，我将在代码中完成。

```java
class Tester...

  private Container container;

   private void configureContainer() {
     container = new Container();
     registerComponents();
     registerInjectors();
     container.start();
  }
```

这个配置有两个阶段，通过查找键注册组件与其他例子非常相似。

```java
class Tester...

  private void registerComponents() {
    container.registerComponent("MovieLister", MovieLister.class);
    container.registerComponent("MovieFinder", ColonMovieFinder.class);
  }
```

一个新的步骤是注册将注入依赖组件的注入器。每个注入接口都需要一些代码来注入依赖对象。在这里，我通过向容器注册注入器对象来做到这一点。每个注入器对象都实现了注入器接口。

```java
class Tester...

  private void registerInjectors() {
    container.registerInjector(InjectFinder.class, container.lookup("MovieFinder"));
    container.registerInjector(InjectFinderFilename.class, new FinderFilenameInjector());
  }
```

```java
public interface Injector {
  public void inject(Object target);
}
```

当依赖项是为这个容器编写的类时，让组件自己实现注入器接口是有意义的，就像我在这里对 movie finder 所做的那样。对于通用类，比如字符串，我在配置代码中使用一个内部类。

```java
class ColonMovieFinder implements Injector...

  public void inject(Object target) {
    ((InjectFinder) target).injectFinder(this);        
  }
```

```java
class Tester...

  public static class FinderFilenameInjector implements Injector {
    public void inject(Object target) {
      ((InjectFinderFilename)target).injectFilename("movies1.txt");      
    }
  }
```

然后测试使用该容器。

```java
class Tester…

  public void testIface() {
    configureContainer();
    MovieLister lister = (MovieLister)container.lookup("MovieLister");
    Movie[] movies = lister.moviesDirectedBy("Sergio Leone");
    assertEquals("Once Upon a Time in the West", movies[0].getTitle());
  }
```

容器使用声明的注入接口来找出依赖关系，并使用注入器来注入正确的依赖项。（我在这里做的具体容器实现对技术本身不重要，我不会展示它，因为你只会笑话我。）

## 6. 使用服务定位器

依赖注入器的关键好处是它移除了 `MovieLister` 类对具体 `MovieFinder` 实现的依赖。这允许我将 lister 提供给朋友，让他们为自己的环境插入合适的实现。注入并不是打破这种依赖的唯一方法，另一种方法是使用**服务定位器**（[service locator](http://java.sun.com/blueprints/corej2eepatterns/Patterns/ServiceLocator.html)）。

服务定位器背后的基本思想是拥有一个对象，它知道如何获取应用程序可能需要的所有服务。所以这个应用程序的服务定位器会有一个方法，在需要时返回一个 movie finder。当然，这只是稍微转移了负担，我们仍然需要将定位器放入 lister 中，从而产生图 3 的依赖关系。

![图 3：服务定位器的依赖关系](https://www.martinfowler.com/articles/injection/locator.gif)

在这种情况下，我将使用 ServiceLocator 作为一个单例**注册表**（[Registry](https://www.martinfowler.com/eaaCatalog/registry.html)）。lister 可以在实例化时使用它来获取 finder。

```java
class MovieLister...

  MovieFinder finder = ServiceLocator.movieFinder();
```

```java
class ServiceLocator...

  public static MovieFinder movieFinder() {
      return soleInstance.movieFinder;
  }
  private static ServiceLocator soleInstance;
  private MovieFinder movieFinder;
```

与注入方法一样，我们必须配置服务定位器。在这里，我是在代码中进行的，但使用一种可以从配置文件中读取适当数据的机制并不难。

```java
class Tester...

  private void configure() {
      ServiceLocator.load(new ServiceLocator(new ColonMovieFinder("movies1.txt")));
  }
```

```java
class ServiceLocator...

  public static void load(ServiceLocator arg) {
      soleInstance = arg;
  }

  public ServiceLocator(MovieFinder movieFinder) {
      this.movieFinder = movieFinder;
  }
```

这是测试代码。

```java
class Tester...

  public void testSimple() {
      configure();
      MovieLister lister = new MovieLister();
      Movie[] movies = lister.moviesDirectedBy("Sergio Leone");
      assertEquals("Once Upon a Time in the West", movies[0].getTitle());
  }
```

我经常听到抱怨说，这类服务定位器是坏东西，因为它们不可测试，因为你无法替换它们的实现。当然，你可以设计得很糟糕以至于陷入这种麻烦，但你并非必须如此。在这种情况下，服务定位器实例只是一个简单的数据持有者。我可以轻松地用我的服务的测试实现来创建定位器。

对于更复杂的定位器，我可以子类化服务定位器，并将该子类传递到注册表的类变量中。我可以更改静态方法以调用实例上的方法，而不是直接访问实例变量。我可以通过使用线程特定存储来提供线程特定的定位器。所有这些都可以在不改变服务定位器客户端的情况下完成。

一种思考方式是，服务定位器是一个注册表，而不是一个单例。单例提供了一种实现注册表的简单方法，但该实现决策很容易更改。

### 6.1. 为定位器使用隔离接口

上述简单方法的一个问题是，MovieLister 依赖于完整的服务定位器类，即使它只使用一个服务。我们可以通过使用**角色接口**（[role interface](https://www.martinfowler.com/bliki/RoleInterface.html)）来减少这种依赖。这样，lister 可以声明它需要的接口部分，而不是使用完整的服务定位器接口。

在这种情况下，lister 的提供者也会提供一个它需要用来获取 finder 的定位器接口。

```java
public interface MovieFinderLocator {
    public MovieFinder movieFinder();
}
```

然后定位器需要实现这个接口来提供对 finder 的访问。

```java
MovieFinderLocator locator = ServiceLocator.locator();
MovieFinder finder = locator.movieFinder();
```

```java
public static ServiceLocator locator() {
     return soleInstance;
 }
 public MovieFinder movieFinder() {
     return movieFinder;
 }
 private static ServiceLocator soleInstance;
 private MovieFinder movieFinder;
```

你会注意到，由于我们想使用接口，我们不能再仅仅通过静态方法访问服务了。我们必须使用该类来获取一个定位器实例，然后用它来获取我们需要的东西。

### 6.2. 动态服务定位器

上面的例子是静态的，即服务定位器类为每个你需要的服务都有方法。这不是唯一的方法，你也可以制作一个动态服务定位器，允许你将任何需要的服务存入其中，并在运行时做出选择。

在这种情况下，服务定位器使用一个 map 而不是为每个服务使用字段，并提供通用方法来获取和加载服务。

```java
class ServiceLocator...

  private static ServiceLocator soleInstance;
  public static void load(ServiceLocator arg) {
      soleInstance = arg;
  }
  private Map services = new HashMap();
  public static Object getService(String key){
      return soleInstance.services.get(key);
  }
  public void loadService (String key, Object service) {
      services.put(key, service);
  }
```

配置涉及使用适当的键加载服务。

```java
class Tester...

  private void configure() {
      ServiceLocator locator = new ServiceLocator();
      locator.loadService("MovieFinder", new ColonMovieFinder("movies1.txt"));
      ServiceLocator.load(locator);
  }
```

我通过使用相同的键字符串来使用服务。

```java
class MovieLister...

  MovieFinder finder = (MovieFinder) ServiceLocator.getService("MovieFinder");
```

总的来说，我不喜欢这种方法。虽然它确实很灵活，但它不是很明确。我能找出如何访问服务的唯一方法是通过文本键。我更喜欢明确的方法，因为通过查看接口定义更容易找到它们的位置。

### 6.3. 在 Avalon 中同时使用定位器和注入

依赖注入和服务定位器不一定是相互排斥的概念。Avalon 框架是同时使用这两者的一个很好的例子。Avalon 使用服务定位器，但使用注入来告诉组件在哪里找到定位器。

Berin Loritsch 给我发了这个使用 Avalon 的我的运行示例的简单版本。

```java
public class MyMovieLister implements MovieLister, Serviceable {
    private MovieFinder finder;

    public void service( ServiceManager manager ) throws ServiceException {
        finder = (MovieFinder)manager.lookup(“finder”);
    } 
}
```

`service` 方法是接口注入的一个例子，允许容器将一个服务管理器注入到 `MyMovieLister` 中。服务管理器是服务定位器的一个例子。在这个例子中，lister 没有将管理器存储在一个字段中，而是立即用它来查找 finder，并将 finder 存储起来。

## 7. 决定使用哪个选项

到目前为止，我一直专注于解释我如何看待这些模式及其变体。现在我可以开始讨论它们的优缺点，以帮助弄清楚何时使用哪一个。

### 7.1. 服务定位器 vs 依赖注入

根本的选择是在服务定位器和依赖注入之间。第一点是，两种实现都提供了简单示例中缺失的基本解耦——在这两种情况下，应用程序代码都独立于服务接口的具体实现。这两种模式之间的重要区别在于该实现是如何提供给应用程序类的。使用服务定位器，应用程序类通过向定位器发送消息来明确请求它。使用注入，没有明确的请求，服务出现在应用程序类中——因此是控制反转。

控制反转是框架的一个共同特征，但它是有代价的。它往往难以理解，并且在调试时会导致问题。所以总的来说，我更喜欢避免它，除非我需要它。这并不是说它是一件坏事，只是我认为它需要证明自己优于更直接的替代方案。

关键区别在于，使用服务定位器，每个服务的使用者都对定位器有依赖。定位器可以隐藏对其他实现的依赖，但你确实需要看到定位器。因此，定位器和注入器之间的决定取决于该依赖是否是一个问题。

使用依赖注入可以帮助更容易地看到组件的依赖关系。使用依赖注入器，你只需查看注入机制，例如构造函数，就可以看到依赖关系。使用服务定位器，你必须在源代码中搜索对定位器的调用。现代 IDE 的“查找引用”功能使这更容易，但仍然不如查看构造函数或设置方法那么容易。

这在很大程度上取决于服务使用者的性质。如果你正在构建一个使用服务的各种类的应用程序，那么应用程序类对定位器的依赖并不是什么大问题。在我将 Movie Lister 提供给我的朋友的例子中，使用服务定位器效果很好。他们需要做的就是配置定位器以接入正确的服务实现，无论是通过一些配置代码还是通过配置文件。在这种情况下，我看不到注入器的反转提供了任何引人注目的东西。

区别在于，如果 lister 是我提供给其他人编写的应用程序的组件。在这种情况下，我不太了解我的客户将要使用的服务定位器的 API。每个客户可能有自己不兼容的服务定位器。我可以通过使用隔离接口来解决部分问题。每个客户可以编写一个适配器，将我的接口与他们的定位器匹配，但无论如何，我仍然需要看到第一个定位器来查找我的特定接口。一旦适配器出现，与定位器直接连接的简单性就开始减弱了。

由于使用注入器时，组件对注入器没有依赖关系，因此一旦配置完毕，组件就无法从注入器获取更多服务。

人们更喜欢依赖注入的一个常见原因是它使测试更容易。这里的要点是，为了进行测试，你需要能够轻松地用存根（stub）或模拟（mock）对象替换真实的服务实现。然而，在依赖注入和服务定位器之间实际上没有区别：两者都非常适合存根。我怀疑这种看法来自于那些没有努力确保其服务定位器可以轻松替换的项目。这就是持续测试的帮助所在，如果你不能轻松地为测试存根服务，那么这意味着你的设计存在严重问题。

当然，测试问题被那些非常具有侵入性的组件环境（如 Java 的 EJB 框架）加剧了。我的观点是，这类框架应该尽量减少对应用程序代码的影响，尤其不应该做那些减慢编辑-执行周期的事情。使用插件来替代重量级组件对这个过程有很大帮助，这对于像测试驱动开发（TDD）这样的实践至关重要。

因此，主要问题是对于那些编写期望在作者控制之外的应用程序中使用的代码的人。在这些情况下，即使是对服务定位器的最小假设也是一个问题。

### 7.2. 构造函数注入 vs Setter 注入

对于服务组合，你总是需要有一些约定才能将事物连接起来。注入的优势主要在于它需要非常简单的约定——至少对于构造函数和 setter 注入是这样。你不需要在你的组件中做任何奇怪的事情，而且对于注入器来说，配置好一切都相当直接。

接口注入更具侵入性，因为你必须编写大量接口才能把所有东西都整理好。对于容器所需的一小组接口，比如 Avalon 的方法，这还不太糟。但对于组装组件和依赖关系来说，这是大量的工作，这就是为什么当前这批轻量级容器选择 setter 和构造函数注入的原因。

setter 和构造函数注入之间的选择很有趣，因为它反映了面向对象编程中一个更普遍的问题——你应该在构造函数中填充字段还是用 setter。

我长期以来对对象的默认做法是，尽可能在构造时创建有效的对象。这个建议可以追溯到 Kent Beck 的《Smalltalk 最佳实践模式》（[Smalltalk Best Practice Patterns](https://www.amazon.com/gp/product/013476904X/ref=as_li_tl?ie=UTF8&camp=1789&creative=9325&creativeASIN=013476904X&linkCode=as2&tag=martinfowlerc-20)）：构造函数方法和构造函数参数方法。带参数的构造函数在一个明显的地方为你清晰地说明了创建一个有效对象意味着什么。如果有多种方法可以做到，就创建多个构造函数来展示不同的组合。

构造函数初始化的另一个优点是，它允许你通过不提供 setter 来清晰地隐藏任何不可变的字段。我认为这很重要——如果某个东西不应该改变，那么没有 setter 很好地传达了这一点。如果你使用 setter 进行初始化，这可能会变得很麻烦。（实际上，在这些情况下，我更喜欢避免通常的 setting 约定，我更喜欢像 `initFoo` 这样的方法，以强调这是你应该只在创建时做的事情。）

但在任何情况下都有例外。如果你有很多构造函数参数，事情可能会看起来很乱，特别是在没有关键字参数的语言中。诚然，一个长构造函数通常是一个过于繁忙的对象的标志，应该被拆分，但有些情况下这就是你所需要的。

如果你有多种方法来构造一个有效的对象，通过构造函数来展示这一点可能很困难，因为构造函数只能在参数的数量和类型上有所不同。这时工厂方法（Factory Methods）就派上用场了，它们可以使用私有构造函数和 setter 的组合来实现它们的工作。经典工厂方法用于组件组装的问题在于，它们通常被视为静态方法，而你不能在接口上有这些。你可以创建一个工厂类，但那只是变成了另一个服务实例。工厂服务通常是一个好的策略，但你仍然必须使用这里的技术之一来实例化工厂。

如果你有像字符串这样的简单参数，构造函数也会遇到问题。使用 setter 注入，你可以给每个 setter 一个名字来表明字符串应该做什么。使用构造函数，你只能依赖位置，这更难理解。

如果你有多个构造函数和继承，事情可能会变得特别尴尬。为了初始化所有东西，你必须提供构造函数来转发到每个超类构造函数，同时还要添加你自己的参数。这可能导致构造函数的更大爆炸。

尽管有这些缺点，我的偏好是**从构造函数注入开始，但一旦我上面概述的问题开始成为问题，就准备切换到 setter 注入**。

这个问题在提供依赖注入器作为其框架一部分的各个团队之间引发了很多争论。然而，似乎大多数构建这些框架的人已经意识到，支持这两种机制很重要，即使他们对其中一种有所偏好。

### 7.3. 代码或配置文件

一个独立但经常被混淆的问题是，是使用配置文件还是代码 API 来连接服务。对于大多数可能在许多地方部署的应用程序，一个单独的配置文件通常最有意义。几乎所有时候这都会是一个 XML 文件，这是有道理的。然而，在某些情况下，使用程序代码进行组装更容易。一种情况是，你有一个简单的应用程序，没有很多部署变化。在这种情况下，一点代码可能比一个单独的 XML 文件更清晰。

一个对比的情况是，组装相当复杂，涉及条件步骤。一旦你开始接近编程语言，XML 就开始崩溃了，最好使用一种真正的语言，它拥有所有语法来编写一个清晰的程序。然后你编写一个构建器类来做组装。如果你有不同的构建器场景，你可以提供几个构建器类，并使用一个简单的配置文件在它们之间进行选择。

我常常认为人们过于急于定义配置文件。通常，编程语言可以成为一个直接而强大的配置机制。现代语言可以轻松编译小型组装器，用于为更大的系统组装插件。如果编译很麻烦，那么也有脚本语言可以很好地工作。

人们常说配置文件不应该使用编程语言，因为它们需要由非程序员编辑。但这种情况有多频繁呢？人们真的期望非程序员去改变一个复杂的服务器端应用程序的事务隔离级别吗？非语言配置文件只有在它们简单的情况下才能很好地工作。如果它们变得复杂，那么就该考虑使用一种合适的编程语言了。

我们目前在 Java 世界看到的一件事是配置文件的杂音，每个组件都有自己的配置文件，与其他人的都不同。如果你使用十几个这样的组件，你很容易最终得到十几个需要保持同步的配置文件。

我在这里的建议是，**始终提供一种用编程接口轻松完成所有配置的方法**，然后将单独的配置文件视为一个可选功能。你可以轻松地构建配置文件处理来使用编程接口。如果你正在编写一个组件，那么就由你的用户决定是使用编程接口、你的配置文件格式，还是编写他们自己的自定义配置文件格式并将其与编程接口绑定。

### 7.4. 将配置与使用分离

所有这一切中重要的问题是确保服务的配置与其使用分离。实际上，这是一个与接口与实现分离相伴随的基本设计原则。当条件逻辑决定实例化哪个类，然后该条件的未来评估通过多态性而不是通过重复的条件代码完成时，我们在面向对象程序中看到了这一点。

如果这种分离在单个代码库中有用，那么当你使用像组件和服务这样的外部元素时，它就尤其重要。第一个问题是，你是否希望将实现类的选择推迟到特定的部署。如果是这样，你需要使用某种插件的实现。一旦你使用插件，那么插件的组装与应用程序的其余部分分开进行就至关重要，这样你就可以为不同的部署轻松替换不同的配置。你如何实现这一点是次要的。这个配置机制可以配置一个服务定位器，或者使用注入来直接配置对象。

## 8. 一些进一步的问题

在本文中，我专注于使用依赖注入和服务定位器进行服务配置的基本问题。还有一些与此相关的主题也值得关注，但我还没有时间深入研究。特别是生命周期行为的问题。一些组件有不同的生命周期事件：例如停止和启动。另一个问题是对在这些容器中使用面向切面思想的兴趣日益增长。虽然我目前在文章中没有考虑这些材料，但我确实希望通过扩展本文或写另一篇文章来更多地讨论这个问题。

你可以通过查看专门讨论轻量级容器的网站来了解更多关于这些想法的信息。从 [picocontainer](http://picocontainer.com/) 和 [spring](http://www.springsource.org/) 网站上浏览，将引导你进入更多关于这些问题的讨论，并开始了解一些更深层次的问题。

## 9. 结论

当前涌现的轻量级容器在服务组装方面都有一个共同的底层模式——依赖注入器模式。依赖注入是服务定位器的一个有用替代方案。在构建应用程序类时，两者大致相当，但我认为服务定位器因其更直接的行为而略有优势。然而，如果你正在构建用于多个应用程序的类，那么依赖注入是一个更好的选择。

如果你使用依赖注入，有多种风格可供选择。我建议你遵循构造函数注入，除非你遇到该方法的特定问题之一，在这种情况下切换到 setter 注入。如果你选择构建或获取一个容器，寻找一个同时支持构造函数和 setter 注入的容器。

**服务定位器和依赖注入之间的选择，不如将服务配置与应用程序中服务的使用分离开来的原则重要。**
