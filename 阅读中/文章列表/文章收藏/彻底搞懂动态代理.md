---
source: https://mp.weixin.qq.com/s/FGK3DD9bcDS3FwO39-uh6g
create: 2025-09-20 19:58
read: false
knowledge: false
---
微笑面对生活@Java知音 2018年12月20日 08:48

### 什么是代理模式?

如果用专业术语来解：为其他对象提供一种代理以控制对这个对象的访问。如果投影在生活中，它可以理解成中介 黄牛 经纪人等…

##### 解决的问题:

在直接访问对象时带来的问题，比如说：要访问的对象在远程的机器上。在面向对象系统中，有些对象由于某些原因（比如对象创建开销很大，或者某些操作需要安全控制，或者需要进程外的访问），直接访问会给使用者或者系统结构带来很多麻烦，我们可以在访问此对象时加上一个对此对象的访问层。说白了就是在你代码前面插一段后面插一段。

##### Java动态代理实现方式:

*   JDK 自带的动态代理
    
*   Cglib动态代理
    

### 1. JDK 自带的动态代理

我以黄牛为例，黄牛刚开始了解该人需求，该人将信息(JAY演唱会门票)给予黄牛，黄牛给票。黄牛就是该买票人的代理。

#### 1.1 People.java

注意这必须是一个接口，原因往下看。

```


1.  `public interface People {`
    
2.   `/**`
    
3.   `* 交谈`
    
4.   `*/`
    
5.   `void speak();`
    
6.  `}`
    


```

这个接口很简单，就是一个讲话的功能，但是它为什么必须是一个接口呢。因为在HuangNiu这个类中，Proxy.newProxyInstance 这个方法的实现需要接口,这一点我在HuangNiu类下解释的很清楚，往下看。

#### 1.2 HuangNiu.java

黄牛代理类，获取到People信息后调用Proxy来生成一个新的代理类,它必须实现InvocationHandler接口,这个接口使得它可以通过invoke方法实现对真实角色(People)的代理访问。

```


1.  `public class HuangNiu implements InvocationHandler {`
    
2.    
    
3.   `private People people;`
    
4.   `/**`
    
5.   `* 获取被代理对象信息`
    
6.   `*/`
    
7.   `public Object getInstance(People people){`
    
8.   `this.people = people;`
    
9.   `Class clazz = people.getClass();`
    
10.   `System.out.println("没生成代理之前的class对象:"+clazz );`
    
11.   `return Proxy.newProxyInstance(clazz.getClassLoader(), clazz.getInterfaces(), this);`
    
12.   `}`
    
13.    
    
14.   `@Override`
    
15.   `public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {`
    
16.   `System.out.println("代理中...");`
    
17.   `method.invoke(people);`
    
18.   `System.out.println("代理处理完毕,OK,请查收");`
    
19.   `return null;`
    
20.   `}`
    
21.  `}`
    


```

在实例化HuangNiu这个对象的时候，我们调用了Proxy的newProxyInstance方法:

```


1.  `return Proxy.newProxyInstance(clazz.getClassLoader(), clazz.getInterfaces(), this);`
    


```

其中clazz是People的class对象。再来看看newProxyInstance的源码实现:

```


1.  `public static Object newProxyInstance(ClassLoader loader,`
    
2.   `Class<?>[] interfaces,`
    
3.   `InvocationHandler h){`
    
4.    
    
5.   `final Class<?>[] intfs = interfaces.clone();`
    
6.    
    
7.   `//Look up or generate the designated proxy class.`
    
8.    
    
9.   `Class<?> cl = getProxyClass0(loader, intfs);`
    
10.    
    
11.   `//获取代理类的构造函数对象`
    
12.   `//参数constructorParames为常量值：private static final Class<?>[] constructorParams = { InvocationHandler.class };`
    
13.   `final Constructor<?> cons = cl.getConstructor(constructorParames);`
    
14.   `final InvocationHandler ih = h;`
    
15.   `//根据代理类的构造函数对象来创建代理类对象`
    
16.   `return newInstance(cons, ih);`
    
17.  `}`
    


```

getProxyClass0方法源码:

```


1.   `private static Class<?> getProxyClass0(ClassLoader loader,`
    
2.   `Class<?>... interfaces) {`
    
3.   `if (interfaces.length > 65535) {`
    
4.   `throw new IllegalArgumentException("interface limit exceeded");`
    
5.   `}`
    
6.    
    
7.   `// If the proxy class defined by the given loader implementing`
    
8.   `// the given interfaces exists, this will simply return the cached copy;`
    
9.   `// otherwise, it will create the proxy class via the ProxyClassFactory`
    
10.   `return proxyClassCache.get(loader, interfaces);`
    
11.   `}`
    


```

如果缓存中有该代理类，则取缓存，如果没有，则通过ProxyClassFactory来创建代理类。如果对如何生成代理类感兴趣则追踪下去即可。

我只取了核心代码和注释，可以看到JDK的动态代理实现是依据接口来重新生成一个新的代理类，

> 什么是新的代理类?
> 
> 通俗点说就是综合和前后代理逻辑并重新生成一份.class文件来实现动态代理的类，下面也会具体说。

#### 1.3 Me.java

被代理对象，实现了People接口,给代理提供需要的信息来实现被代理。

```


1.  `public class Me implements People {`
    
2.    
    
3.   `private String name;`
    
4.   `private String type;`
    
5.    
    
6.   `Me(String name, String type){`
    
7.   `this.name = name;`
    
8.   `this.type = type;`
    
9.   `}`
    
10.   `@Override`
    
11.   `public void speak() {`
    
12.   `System.out.println("我叫"+name+", 我要一张"+type);`
    
13.   `}`
    
14.  `}`
    


```

#### 1.4 Main.java

```


1.  `public class Main {`
    
2.   `public static void main(String[] args) {`
    
3.   `People instance = (People)new HuangNiu().getInstance(new Me("Fantj", "JAY演唱会门票"));`
    
4.   `instance.speak();`
    
5.   `System.out.println("生成代理对象后对象变成:"+instance.getClass());`
    
6.   `}`
    
7.  `}`
    


```

执行结果:

```


1.  `没生成代理之前的class对象:class com.fantj.proxy.jdk.Me`
    
2.  `代理中...`
    
3.  `我叫Fantj, 我要一张JAY演唱会门票`
    
4.  `代理处理完毕,OK,请查收`
    
5.  `生成代理对象后对象变成:class com.sun.proxy.$Proxy0`
    


```

为了证明事实上真的有代理类的产生，我在代理完成前和代理完成后分别打印出它的类信息，可以看出是不同的，可以猜想到代理中是有代理类产生的，这个代理类就是$Proxy0。

那既然知道了这个类的信息，我们就可以逆向生成这个.class文件来看看(在main方法后追加):

```


1.  `/**`
    
2.   `* 生成代码`
    
3.   `*/`
    
4.  `try {`
    
5.   `byte[] $Proxy0s = ProxyGenerator.generateProxyClass("$Proxy0", new Class[]{instance.getClass()});`
    
6.   `String path = Main.class.getResource("").toString();`
    
7.  `//            System.out.println("get the path"+path);`
    
8.   `FileOutputStream fileOutputStream = new FileOutputStream("$Proxy0.class");`
    
9.   `fileOutputStream.write($Proxy0s);`
    
10.   `fileOutputStream.close();`
    
11.  `} catch (IOException e) {`
    
12.   `e.printStackTrace();`
    
13.  `}`
    


```

它默认生成在项目根目录下: 我使用的IDEA工具会自动反编译.class文件为java代码，直接打开即刻看到源码，如果用别的工具的可以下载反编译工具来进行反编译。

$Proxy0.class

```


1.  `//`
    
2.  `// Source code recreated from a .class file by IntelliJ IDEA`
    
3.  `// (powered by Fernflower decompiler)`
    
4.  `//`
    
5.    
    
6.  `import com.sun.proxy..Proxy0;`
    
7.  `import java.lang.reflect.InvocationHandler;`
    
8.  `import java.lang.reflect.Method;`
    
9.  `import java.lang.reflect.Proxy;`
    
10.  `import java.lang.reflect.UndeclaredThrowableException;`
    
11.    
    
12.  `public final class $Proxy0 extends Proxy implements Proxy0 {`
    
13.   `private static Method m1;`
    
14.   `private static Method m5;`
    
15.   `private static Method m2;`
    
16.   `private static Method m4;`
    
17.   `private static Method m11;`
    
18.   `private static Method m13;`
    
19.   `private static Method m0;`
    
20.   `private static Method m10;`
    
21.   `private static Method m12;`
    
22.   `private static Method m6;`
    
23.   `private static Method m9;`
    
24.   `private static Method m3;`
    
25.   `private static Method m7;`
    
26.   `private static Method m8;`
    
27.    
    
28.   `public $Proxy0(InvocationHandler var1) throws {`
    
29.   `super(var1);`
    
30.   `}`
    
31.    
    
32.   `public final boolean equals(Object var1) throws {`
    
33.   `try {`
    
34.   `return (Boolean)super.h.invoke(this, m1, new Object[]{var1});`
    
35.   `} catch (RuntimeException | Error var3) {`
    
36.   `throw var3;`
    
37.   `} catch (Throwable var4) {`
    
38.   `throw new UndeclaredThrowableException(var4);`
    
39.   `}`
    
40.   `}`
    
41.    
    
42.   `public final InvocationHandler getInvocationHandler(Object var1) throws IllegalArgumentException {`
    
43.   `try {`
    
44.   `return (InvocationHandler)super.h.invoke(this, m5, new Object[]{var1});`
    
45.   `} catch (RuntimeException | Error var3) {`
    
46.   `throw var3;`
    
47.   `} catch (Throwable var4) {`
    
48.   `throw new UndeclaredThrowableException(var4);`
    
49.   `}`
    
50.   `}`
    
51.    
    
52.   `public final String toString() throws {`
    
53.   `try {`
    
54.   `return (String)super.h.invoke(this, m2, (Object[])null);`
    
55.   `} catch (RuntimeException | Error var2) {`
    
56.   `throw var2;`
    
57.   `} catch (Throwable var3) {`
    
58.   `throw new UndeclaredThrowableException(var3);`
    
59.   `}`
    
60.   `}`
    
61.    
    
62.   `public final Class getProxyClass(ClassLoader var1, Class[] var2) throws IllegalArgumentException {`
    
63.   `try {`
    
64.   `return (Class)super.h.invoke(this, m4, new Object[]{var1, var2});`
    
65.   `} catch (RuntimeException | Error var4) {`
    
66.   `throw var4;`
    
67.   `} catch (Throwable var5) {`
    
68.   `throw new UndeclaredThrowableException(var5);`
    
69.   `}`
    
70.   `}`
    
71.    
    
72.   `public final Class getClass() throws {`
    
73.   `try {`
    
74.   `return (Class)super.h.invoke(this, m11, (Object[])null);`
    
75.   `} catch (RuntimeException | Error var2) {`
    
76.   `throw var2;`
    
77.   `} catch (Throwable var3) {`
    
78.   `throw new UndeclaredThrowableException(var3);`
    
79.   `}`
    
80.   `}`
    
81.    
    
82.   `public final void notifyAll() throws {`
    
83.   `try {`
    
84.   `super.h.invoke(this, m13, (Object[])null);`
    
85.   `} catch (RuntimeException | Error var2) {`
    
86.   `throw var2;`
    
87.   `} catch (Throwable var3) {`
    
88.   `throw new UndeclaredThrowableException(var3);`
    
89.   `}`
    
90.   `}`
    
91.    
    
92.   `public final int hashCode() throws {`
    
93.   `try {`
    
94.   `return (Integer)super.h.invoke(this, m0, (Object[])null);`
    
95.   `} catch (RuntimeException | Error var2) {`
    
96.   `throw var2;`
    
97.   `} catch (Throwable var3) {`
    
98.   `throw new UndeclaredThrowableException(var3);`
    
99.   `}`
    
100.   `}`
    
101.    
    
102.   `public final void wait() throws InterruptedException {`
    
103.   `try {`
    
104.   `super.h.invoke(this, m10, (Object[])null);`
    
105.   `} catch (RuntimeException | InterruptedException | Error var2) {`
    
106.   `throw var2;`
    
107.   `} catch (Throwable var3) {`
    
108.   `throw new UndeclaredThrowableException(var3);`
    
109.   `}`
    
110.   `}`
    
111.    
    
112.   `public final void notify() throws {`
    
113.   `try {`
    
114.   `super.h.invoke(this, m12, (Object[])null);`
    
115.   `} catch (RuntimeException | Error var2) {`
    
116.   `throw var2;`
    
117.   `} catch (Throwable var3) {`
    
118.   `throw new UndeclaredThrowableException(var3);`
    
119.   `}`
    
120.   `}`
    
121.    
    
122.   `public final Object newProxyInstance(ClassLoader var1, Class[] var2, InvocationHandler var3) throws IllegalArgumentException {`
    
123.   `try {`
    
124.   `return (Object)super.h.invoke(this, m6, new Object[]{var1, var2, var3});`
    
125.   `} catch (RuntimeException | Error var5) {`
    
126.   `throw var5;`
    
127.   `} catch (Throwable var6) {`
    
128.   `throw new UndeclaredThrowableException(var6);`
    
129.   `}`
    
130.   `}`
    
131.    
    
132.   `public final void wait(long var1) throws InterruptedException {`
    
133.   `try {`
    
134.   `super.h.invoke(this, m9, new Object[]{var1});`
    
135.   `} catch (RuntimeException | InterruptedException | Error var4) {`
    
136.   `throw var4;`
    
137.   `} catch (Throwable var5) {`
    
138.   `throw new UndeclaredThrowableException(var5);`
    
139.   `}`
    
140.   `}`
    
141.    
    
142.   `public final void speak() throws {`
    
143.   `try {`
    
144.   `super.h.invoke(this, m3, (Object[])null);`
    
145.   `} catch (RuntimeException | Error var2) {`
    
146.   `throw var2;`
    
147.   `} catch (Throwable var3) {`
    
148.   `throw new UndeclaredThrowableException(var3);`
    
149.   `}`
    
150.   `}`
    
151.    
    
152.   `public final boolean isProxyClass(Class var1) throws {`
    
153.   `try {`
    
154.   `return (Boolean)super.h.invoke(this, m7, new Object[]{var1});`
    
155.   `} catch (RuntimeException | Error var3) {`
    
156.   `throw var3;`
    
157.   `} catch (Throwable var4) {`
    
158.   `throw new UndeclaredThrowableException(var4);`
    
159.   `}`
    
160.   `}`
    
161.    
    
162.   `public final void wait(long var1, int var3) throws InterruptedException {`
    
163.   `try {`
    
164.   `super.h.invoke(this, m8, new Object[]{var1, var3});`
    
165.   `} catch (RuntimeException | InterruptedException | Error var5) {`
    
166.   `throw var5;`
    
167.   `} catch (Throwable var6) {`
    
168.   `throw new UndeclaredThrowableException(var6);`
    
169.   `}`
    
170.   `}`
    
171.    
    
172.   `static {`
    
173.   `try {`
    
174.   `m1 = Class.forName("java.lang.Object").getMethod("equals", Class.forName("java.lang.Object"));`
    
175.   `m5 = Class.forName("com.sun.proxy.$Proxy0").getMethod("getInvocationHandler", Class.forName("java.lang.Object"));`
    
176.   `m2 = Class.forName("java.lang.Object").getMethod("toString");`
    
177.   `m4 = Class.forName("com.sun.proxy.$Proxy0").getMethod("getProxyClass", Class.forName("java.lang.ClassLoader"), Class.forName("[Ljava.lang.Class;"));`
    
178.   `m11 = Class.forName("com.sun.proxy.$Proxy0").getMethod("getClass");`
    
179.   `m13 = Class.forName("com.sun.proxy.$Proxy0").getMethod("notifyAll");`
    
180.   `m0 = Class.forName("java.lang.Object").getMethod("hashCode");`
    
181.   `m10 = Class.forName("com.sun.proxy.$Proxy0").getMethod("wait");`
    
182.   `m12 = Class.forName("com.sun.proxy.$Proxy0").getMethod("notify");`
    
183.   `m6 = Class.forName("com.sun.proxy.$Proxy0").getMethod("newProxyInstance", Class.forName("java.lang.ClassLoader"), Class.forName("[Ljava.lang.Class;"), Class.forName("java.lang.reflect.InvocationHandler"));`
    
184.   `m9 = Class.forName("com.sun.proxy.$Proxy0").getMethod("wait", Long.TYPE);`
    
185.   `m3 = Class.forName("com.sun.proxy.$Proxy0").getMethod("speak");`
    
186.   `m7 = Class.forName("com.sun.proxy.$Proxy0").getMethod("isProxyClass", Class.forName("java.lang.Class"));`
    
187.   `m8 = Class.forName("com.sun.proxy.$Proxy0").getMethod("wait", Long.TYPE, Integer.TYPE);`
    
188.   `} catch (NoSuchMethodException var2) {`
    
189.   `throw new NoSuchMethodError(var2.getMessage());`
    
190.   `} catch (ClassNotFoundException var3) {`
    
191.   `throw new NoClassDefFoundError(var3.getMessage());`
    
192.   `}`
    
193.   `}`
    
194.  `}`
    


```

里面大多是Object中的方法，还有我们定义的speak()方法，然后就是静态代码块(对变量进行初始化)。

当我们在Main中:

```


1.  `People instance = (People)new HuangNiu().getInstance(new Me("Fantj", "JAY演唱会门票"));`
    
2.  `instance.speak();`
    
3.    
    
4.  `调用instance.speak();时，事实上就调用了$Proxy0中的speak()方法，然后在该方法中再调用父类Proxy的invoke方法:`
    
5.    
    
6.  `public final void speak() throws {`
    
7.   `try {`
    
8.   `super.h.invoke(this, m3, (Object[])null);`
    
9.   `} catch (RuntimeException | Error var2) {`
    
10.   `throw var2;`
    
11.   `} catch (Throwable var3) {`
    
12.   `throw new UndeclaredThrowableException(var3);`
    
13.   `}`
    
14.  `}`
    


```

其中，super.h.invoke的调用的是父类Proxy中的InvocationHandler.invoke()方法.

#### 最后

你一定也很好奇它的名字为什么是$Proxy0,也一定很好奇第二个代理类的命名。

ProxyClassFactory类中的代码中有体现:

```


1.  `private static final class ProxyClassFactory`
    
2.   `implements BiFunction<ClassLoader, Class<?>[], Class<?>>`
    
3.  `{`
    
4.   `// prefix for all proxy class names`
    
5.   `// 所有代理类的前缀`
    
6.   `private static final String proxyClassNamePrefix = "$Proxy";`
    
7.    
    
8.   `// next number to use for generation of unique proxy class names`
    
9.   `// 用java8新增的原子性AtomicLong类来做线程安全计数`
    
10.   `private static final AtomicLong nextUniqueNumber = new AtomicLong();`
    
11.    
    
12.   `/*`
    
13.   `* Choose a name for the proxy class to generate.`
    
14.   `*/`
    
15.   `// 拼接代理类 类名`
    
16.   `long num = nextUniqueNumber.getAndIncrement();`
    
17.   `String proxyName = proxyPkg + proxyClassNamePrefix + num;`
    
18.   `...`
    
19.   `...`
    
20.  `}`
    


```

### 2. Cglib实现动态代理

Cglib动态代理的实现原理和jdk基本一样，但是也有不同点。

#### 不同点:

1.  jdk动态代理生成的代理类是继承自Proxy，实现你的被代理类所实现的接口，要求必须有接口。
    
2.  cglib动态代理生成的代理类是被代理者的子类，并且会重写父类的所有方法，要求该父类必须有空的构造方法,否则会报错:Superclass has no null constructors but no arguments were given,还有，private和final修饰的方法不会被子类重写。
    

#### 相同点:

都是生成了新的代理类(字节码重组)。

Me.java

```


1.  `public class Me {`
    
2.    
    
3.   `private String name = "FantJ";`
    
4.   `private String type = "JAY演唱会门票";`
    
5.    
    
6.   `Me() {`
    
7.    
    
8.   `}`
    
9.    
    
10.   `Me(String name, String type){`
    
11.   `this.name = name;`
    
12.   `this.type = type;`
    
13.   `}`
    
14.   `public void speak() {`
    
15.   `System.out.println("我叫"+name+", 我要一张"+type);`
    
16.   `}`
    
17.    
    
18.   `public String getName() {`
    
19.   `return name;`
    
20.   `}`
    
21.    
    
22.   `public void setName(String name) {`
    
23.   `this.name = name;`
    
24.   `}`
    
25.    
    
26.   `public String getType() {`
    
27.   `return type;`
    
28.   `}`
    
29.    
    
30.   `public void setType(String type) {`
    
31.   `this.type = type;`
    
32.   `}`
    
33.  `}`
    


```

HuangNiu.java

该类要实现cglib包下的MethodInterceptor接口，从而实现对intercept的调用。

```


1.  `public class HuangNiu implements MethodInterceptor {`
    
2.    
    
3.   `/**`
    
4.   `* 获取被代理对象信息`
    
5.   `*`
    
6.   `*/`
    
7.   `public Object getInstance(Object object){`
    
8.   `Enhancer enhancer = new Enhancer();`
    
9.   `enhancer.setSuperclass(object.getClass());`
    
10.   `System.out.println("生成代理对象前对象是:"+object.getClass());`
    
11.   `enhancer.setCallback(this);`
    
12.   `return enhancer.create();`
    
13.   `}`
    
14.    
    
15.   `@Override`
    
16.   `public Object intercept(Object o, Method method, Object[] objects, MethodProxy methodProxy) throws Throwable {`
    
17.   `System.out.println("代理中...");`
    
18.   `methodProxy.invokeSuper(o, objects);`
    
19.  `//        methodProxy.invoke(o, objects);`
    
20.   `System.out.println("代理处理完毕,OK,请查收");`
    
21.   `return null;`
    
22.   `}`
    
23.  `}`
    


```

Main.java

```


1.  `public class Main {`
    
2.   `public static void main(String[] args) {`
    
3.   `Me instance = (Me)new HuangNiu().getInstance(new Me("Fantj", "JAY演唱会门票"));`
    
4.  `//        Me instance = (Me)new HuangNiu().getInstance(new Me());`
    
5.   `instance.speak();`
    
6.   `System.out.println("生成代理对象后对象变成:"+instance.getClass());`
    
7.    
    
8.   `/**`
    
9.   `* 生成代码`
    
10.   `*/`
    
11.   `try {`
    
12.   `byte[] $Proxy0s = ProxyGenerator.generateProxyClass("Me$$EnhancerByCGLIB$$5d2d06a1", new Class[]{instance.getClass()});`
    
13.   `String path = com.fantj.proxy.jdk.Main.class.getResource("").toString();`
    
14.  `//            System.out.println("get the path"+path);`
    
15.   `FileOutputStream fileOutputStream = new FileOutputStream("Me$$EnhancerByCGLIB$$5d2d06a1.class");`
    
16.   `fileOutputStream.write($Proxy0s);`
    
17.   `fileOutputStream.close();`
    
18.   `} catch (IOException e) {`
    
19.   `e.printStackTrace();`
    
20.   `}`
    
21.   `}`
    
22.  `}`
    


```

控制台结果:

```


1.  `生成代理对象前对象是:class com.fantj.proxy.cglib.Me`
    
2.  `代理中...`
    
3.  `我叫FantJ, 我要一张JAY演唱会门票`
    
4.  `代理处理完毕,OK,请查收`
    
5.  `生成代理对象后对象变成:class com.fantj.proxy.cglib.Me$$EnhancerByCGLIB$$5d2d06a1`
    


```

同上，我们也把它生成的代理类反编译得到Me$$EnhancerByCGLIB$$5d2d06a1.java,原理和上面JDK代理类似，举一反三，这里不做介绍。

Me$$EnhancerByCGLIB$$5d2d06a1.java

```


1.  `//`
    
2.  `// Source code recreated from a .class file by IntelliJ IDEA`
    
3.  `// (powered by Fernflower decompiler)`
    
4.  `//`
    
5.    
    
6.  `import com.fantj.proxy.cglib.Me..EnhancerByCGLIB..5d2d06a1;`
    
7.  `import java.lang.reflect.InvocationHandler;`
    
8.  `import java.lang.reflect.Method;`
    
9.  `import java.lang.reflect.Proxy;`
    
10.  `import java.lang.reflect.UndeclaredThrowableException;`
    
11.  `import net.sf.cglib.core.Signature;`
    
12.  `import net.sf.cglib.proxy.Callback;`
    
13.  `import net.sf.cglib.proxy.MethodProxy;`
    
14.    
    
15.  `public final class Me$$EnhancerByCGLIB$$5d2d06a1 extends Proxy implements 5d2d06a1 {`
    
16.   `private static Method m1;`
    
17.   `private static Method m6;`
    
18.   `private static Method m7;`
    
19.   `private static Method m2;`
    
20.   `private static Method m15;`
    
21.   `private static Method m21;`
    
22.   `private static Method m23;`
    
23.   `private static Method m0;`
    
24.   `private static Method m20;`
    
25.   `private static Method m13;`
    
26.   `private static Method m12;`
    
27.   `private static Method m3;`
    
28.   `private static Method m10;`
    
29.   `private static Method m22;`
    
30.   `private static Method m8;`
    
31.   `private static Method m11;`
    
32.   `private static Method m14;`
    
33.   `private static Method m4;`
    
34.   `private static Method m19;`
    
35.   `private static Method m9;`
    
36.   `private static Method m18;`
    
37.   `private static Method m16;`
    
38.   `private static Method m17;`
    
39.   `private static Method m5;`
    
40.    
    
41.   `public Me$$EnhancerByCGLIB$$5d2d06a1(InvocationHandler var1) throws {`
    
42.   `super(var1);`
    
43.   `}`
    
44.    
    
45.   `public final boolean equals(Object var1) throws {`
    
46.   `try {`
    
47.   `return (Boolean)super.h.invoke(this, m1, new Object[]{var1});`
    
48.   `} catch (RuntimeException | Error var3) {`
    
49.   `throw var3;`
    
50.   `} catch (Throwable var4) {`
    
51.   `throw new UndeclaredThrowableException(var4);`
    
52.   `}`
    
53.   `}`
    
54.    
    
55.   `public final Object newInstance(Callback[] var1) throws {`
    
56.   `try {`
    
57.   `return (Object)super.h.invoke(this, m6, new Object[]{var1});`
    
58.   `} catch (RuntimeException | Error var3) {`
    
59.   `throw var3;`
    
60.   `} catch (Throwable var4) {`
    
61.   `throw new UndeclaredThrowableException(var4);`
    
62.   `}`
    
63.   `}`
    
64.    
    
65.   `public final void setName(String var1) throws {`
    
66.   `try {`
    
67.   `super.h.invoke(this, m7, new Object[]{var1});`
    
68.   `} catch (RuntimeException | Error var3) {`
    
69.   `throw var3;`
    
70.   `} catch (Throwable var4) {`
    
71.   `throw new UndeclaredThrowableException(var4);`
    
72.   `}`
    
73.   `}`
    
74.    
    
75.   `public final String toString() throws {`
    
76.   `try {`
    
77.   `return (String)super.h.invoke(this, m2, (Object[])null);`
    
78.   `} catch (RuntimeException | Error var2) {`
    
79.   `throw var2;`
    
80.   `} catch (Throwable var3) {`
    
81.   `throw new UndeclaredThrowableException(var3);`
    
82.   `}`
    
83.   `}`
    
84.    
    
85.   `public final Callback getCallback(int var1) throws {`
    
86.   `try {`
    
87.   `return (Callback)super.h.invoke(this, m15, new Object[]{var1});`
    
88.   `} catch (RuntimeException | Error var3) {`
    
89.   `throw var3;`
    
90.   `} catch (Throwable var4) {`
    
91.   `throw new UndeclaredThrowableException(var4);`
    
92.   `}`
    
93.   `}`
    
94.    
    
95.   `public final Class getClass() throws {`
    
96.   `try {`
    
97.   `return (Class)super.h.invoke(this, m21, (Object[])null);`
    
98.   `} catch (RuntimeException | Error var2) {`
    
99.   `throw var2;`
    
100.   `} catch (Throwable var3) {`
    
101.   `throw new UndeclaredThrowableException(var3);`
    
102.   `}`
    
103.   `}`
    
104.    
    
105.   `public final void notifyAll() throws {`
    
106.   `try {`
    
107.   `super.h.invoke(this, m23, (Object[])null);`
    
108.   `} catch (RuntimeException | Error var2) {`
    
109.   `throw var2;`
    
110.   `} catch (Throwable var3) {`
    
111.   `throw new UndeclaredThrowableException(var3);`
    
112.   `}`
    
113.   `}`
    
114.    
    
115.   `public final int hashCode() throws {`
    
116.   `try {`
    
117.   `return (Integer)super.h.invoke(this, m0, (Object[])null);`
    
118.   `} catch (RuntimeException | Error var2) {`
    
119.   `throw var2;`
    
120.   `} catch (Throwable var3) {`
    
121.   `throw new UndeclaredThrowableException(var3);`
    
122.   `}`
    
123.   `}`
    
124.    
    
125.   `public final void wait() throws InterruptedException {`
    
126.   `try {`
    
127.   `super.h.invoke(this, m20, (Object[])null);`
    
128.   `} catch (RuntimeException | InterruptedException | Error var2) {`
    
129.   `throw var2;`
    
130.   `} catch (Throwable var3) {`
    
131.   `throw new UndeclaredThrowableException(var3);`
    
132.   `}`
    
133.   `}`
    
134.    
    
135.   `public final void CGLIB$SET_STATIC_CALLBACKS(Callback[] var1) throws {`
    
136.   `try {`
    
137.   `super.h.invoke(this, m13, new Object[]{var1});`
    
138.   `} catch (RuntimeException | Error var3) {`
    
139.   `throw var3;`
    
140.   `} catch (Throwable var4) {`
    
141.   `throw new UndeclaredThrowableException(var4);`
    
142.   `}`
    
143.   `}`
    
144.    
    
145.   `public final void setCallbacks(Callback[] var1) throws {`
    
146.   `try {`
    
147.   `super.h.invoke(this, m12, new Object[]{var1});`
    
148.   `} catch (RuntimeException | Error var3) {`
    
149.   `throw var3;`
    
150.   `} catch (Throwable var4) {`
    
151.   `throw new UndeclaredThrowableException(var4);`
    
152.   `}`
    
153.   `}`
    
154.    
    
155.   `public final String getName() throws {`
    
156.   `try {`
    
157.   `return (String)super.h.invoke(this, m3, (Object[])null);`
    
158.   `} catch (RuntimeException | Error var2) {`
    
159.   `throw var2;`
    
160.   `} catch (Throwable var3) {`
    
161.   `throw new UndeclaredThrowableException(var3);`
    
162.   `}`
    
163.   `}`
    
164.    
    
165.   `public final void setCallback(int var1, Callback var2) throws {`
    
166.   `try {`
    
167.   `super.h.invoke(this, m10, new Object[]{var1, var2});`
    
168.   `} catch (RuntimeException | Error var4) {`
    
169.   `throw var4;`
    
170.   `} catch (Throwable var5) {`
    
171.   `throw new UndeclaredThrowableException(var5);`
    
172.   `}`
    
173.   `}`
    
174.    
    
175.   `public final void notify() throws {`
    
176.   `try {`
    
177.   `super.h.invoke(this, m22, (Object[])null);`
    
178.   `} catch (RuntimeException | Error var2) {`
    
179.   `throw var2;`
    
180.   `} catch (Throwable var3) {`
    
181.   `throw new UndeclaredThrowableException(var3);`
    
182.   `}`
    
183.   `}`
    
184.    
    
185.   `public final String getType() throws {`
    
186.   `try {`
    
187.   `return (String)super.h.invoke(this, m8, (Object[])null);`
    
188.   `} catch (RuntimeException | Error var2) {`
    
189.   `throw var2;`
    
190.   `} catch (Throwable var3) {`
    
191.   `throw new UndeclaredThrowableException(var3);`
    
192.   `}`
    
193.   `}`
    
194.    
    
195.   `public final void setType(String var1) throws {`
    
196.   `try {`
    
197.   `super.h.invoke(this, m11, new Object[]{var1});`
    
198.   `} catch (RuntimeException | Error var3) {`
    
199.   `throw var3;`
    
200.   `} catch (Throwable var4) {`
    
201.   `throw new UndeclaredThrowableException(var4);`
    
202.   `}`
    
203.   `}`
    
204.    
    
205.   `public final void CGLIB$SET_THREAD_CALLBACKS(Callback[] var1) throws {`
    
206.   `try {`
    
207.   `super.h.invoke(this, m14, new Object[]{var1});`
    
208.   `} catch (RuntimeException | Error var3) {`
    
209.   `throw var3;`
    
210.   `} catch (Throwable var4) {`
    
211.   `throw new UndeclaredThrowableException(var4);`
    
212.   `}`
    
213.   `}`
    
214.    
    
215.   `public final Object newInstance(Class[] var1, Object[] var2, Callback[] var3) throws {`
    
216.   `try {`
    
217.   `return (Object)super.h.invoke(this, m4, new Object[]{var1, var2, var3});`
    
218.   `} catch (RuntimeException | Error var5) {`
    
219.   `throw var5;`
    
220.   `} catch (Throwable var6) {`
    
221.   `throw new UndeclaredThrowableException(var6);`
    
222.   `}`
    
223.   `}`
    
224.    
    
225.   `public final void wait(long var1) throws InterruptedException {`
    
226.   `try {`
    
227.   `super.h.invoke(this, m19, new Object[]{var1});`
    
228.   `} catch (RuntimeException | InterruptedException | Error var4) {`
    
229.   `throw var4;`
    
230.   `} catch (Throwable var5) {`
    
231.   `throw new UndeclaredThrowableException(var5);`
    
232.   `}`
    
233.   `}`
    
234.    
    
235.   `public final void speak() throws {`
    
236.   `try {`
    
237.   `super.h.invoke(this, m9, (Object[])null);`
    
238.   `} catch (RuntimeException | Error var2) {`
    
239.   `throw var2;`
    
240.   `} catch (Throwable var3) {`
    
241.   `throw new UndeclaredThrowableException(var3);`
    
242.   `}`
    
243.   `}`
    
244.    
    
245.   `public final void wait(long var1, int var3) throws InterruptedException {`
    
246.   `try {`
    
247.   `super.h.invoke(this, m18, new Object[]{var1, var3});`
    
248.   `} catch (RuntimeException | InterruptedException | Error var5) {`
    
249.   `throw var5;`
    
250.   `} catch (Throwable var6) {`
    
251.   `throw new UndeclaredThrowableException(var6);`
    
252.   `}`
    
253.   `}`
    
254.    
    
255.   `public final Callback[] getCallbacks() throws {`
    
256.   `try {`
    
257.   `return (Callback[])super.h.invoke(this, m16, (Object[])null);`
    
258.   `} catch (RuntimeException | Error var2) {`
    
259.   `throw var2;`
    
260.   `} catch (Throwable var3) {`
    
261.   `throw new UndeclaredThrowableException(var3);`
    
262.   `}`
    
263.   `}`
    
264.    
    
265.   `public final MethodProxy CGLIB$findMethodProxy(Signature var1) throws {`
    
266.   `try {`
    
267.   `return (MethodProxy)super.h.invoke(this, m17, new Object[]{var1});`
    
268.   `} catch (RuntimeException | Error var3) {`
    
269.   `throw var3;`
    
270.   `} catch (Throwable var4) {`
    
271.   `throw new UndeclaredThrowableException(var4);`
    
272.   `}`
    
273.   `}`
    
274.    
    
275.   `public final Object newInstance(Callback var1) throws {`
    
276.   `try {`
    
277.   `return (Object)super.h.invoke(this, m5, new Object[]{var1});`
    
278.   `} catch (RuntimeException | Error var3) {`
    
279.   `throw var3;`
    
280.   `} catch (Throwable var4) {`
    
281.   `throw new UndeclaredThrowableException(var4);`
    
282.   `}`
    
283.   `}`
    
284.    
    
285.   `static {`
    
286.   `try {`
    
287.   `m1 = Class.forName("java.lang.Object").getMethod("equals", Class.forName("java.lang.Object"));`
    
288.   `m6 = Class.forName("com.fantj.proxy.cglib.Me$$EnhancerByCGLIB$$5d2d06a1").getMethod("newInstance", Class.forName("[Lnet.sf.cglib.proxy.Callback;"));`
    
289.   `m7 = Class.forName("com.fantj.proxy.cglib.Me$$EnhancerByCGLIB$$5d2d06a1").getMethod("setName", Class.forName("java.lang.String"));`
    
290.   `m2 = Class.forName("java.lang.Object").getMethod("toString");`
    
291.   `m15 = Class.forName("com.fantj.proxy.cglib.Me$$EnhancerByCGLIB$$5d2d06a1").getMethod("getCallback", Integer.TYPE);`
    
292.   `m21 = Class.forName("com.fantj.proxy.cglib.Me$$EnhancerByCGLIB$$5d2d06a1").getMethod("getClass");`
    
293.   `m23 = Class.forName("com.fantj.proxy.cglib.Me$$EnhancerByCGLIB$$5d2d06a1").getMethod("notifyAll");`
    
294.   `m0 = Class.forName("java.lang.Object").getMethod("hashCode");`
    
295.   `m20 = Class.forName("com.fantj.proxy.cglib.Me$$EnhancerByCGLIB$$5d2d06a1").getMethod("wait");`
    
296.   `m13 = Class.forName("com.fantj.proxy.cglib.Me$$EnhancerByCGLIB$$5d2d06a1").getMethod("CGLIB$SET_STATIC_CALLBACKS", Class.forName("[Lnet.sf.cglib.proxy.Callback;"));`
    
297.   `m12 = Class.forName("com.fantj.proxy.cglib.Me$$EnhancerByCGLIB$$5d2d06a1").getMethod("setCallbacks", Class.forName("[Lnet.sf.cglib.proxy.Callback;"));`
    
298.   `m3 = Class.forName("com.fantj.proxy.cglib.Me$$EnhancerByCGLIB$$5d2d06a1").getMethod("getName");`
    
299.   `m10 = Class.forName("com.fantj.proxy.cglib.Me$$EnhancerByCGLIB$$5d2d06a1").getMethod("setCallback", Integer.TYPE, Class.forName("net.sf.cglib.proxy.Callback"));`
    
300.   `m22 = Class.forName("com.fantj.proxy.cglib.Me$$EnhancerByCGLIB$$5d2d06a1").getMethod("notify");`
    
301.   `m8 = Class.forName("com.fantj.proxy.cglib.Me$$EnhancerByCGLIB$$5d2d06a1").getMethod("getType");`
    
302.   `m11 = Class.forName("com.fantj.proxy.cglib.Me$$EnhancerByCGLIB$$5d2d06a1").getMethod("setType", Class.forName("java.lang.String"));`
    
303.   `m14 = Class.forName("com.fantj.proxy.cglib.Me$$EnhancerByCGLIB$$5d2d06a1").getMethod("CGLIB$SET_THREAD_CALLBACKS", Class.forName("[Lnet.sf.cglib.proxy.Callback;"));`
    
304.   `m4 = Class.forName("com.fantj.proxy.cglib.Me$$EnhancerByCGLIB$$5d2d06a1").getMethod("newInstance", Class.forName("[Ljava.lang.Class;"), Class.forName("[Ljava.lang.Object;"), Class.forName("[Lnet.sf.cglib.proxy.Callback;"));`
    
305.   `m19 = Class.forName("com.fantj.proxy.cglib.Me$$EnhancerByCGLIB$$5d2d06a1").getMethod("wait", Long.TYPE);`
    
306.   `m9 = Class.forName("com.fantj.proxy.cglib.Me$$EnhancerByCGLIB$$5d2d06a1").getMethod("speak");`
    
307.   `m18 = Class.forName("com.fantj.proxy.cglib.Me$$EnhancerByCGLIB$$5d2d06a1").getMethod("wait", Long.TYPE, Integer.TYPE);`
    
308.   `m16 = Class.forName("com.fantj.proxy.cglib.Me$$EnhancerByCGLIB$$5d2d06a1").getMethod("getCallbacks");`
    
309.   `m17 = Class.forName("com.fantj.proxy.cglib.Me$$EnhancerByCGLIB$$5d2d06a1").getMethod("CGLIB$findMethodProxy", Class.forName("net.sf.cglib.core.Signature"));`
    
310.   `m5 = Class.forName("com.fantj.proxy.cglib.Me$$EnhancerByCGLIB$$5d2d06a1").getMethod("newInstance", Class.forName("net.sf.cglib.proxy.Callback"));`
    
311.   `} catch (NoSuchMethodException var2) {`
    
312.   `throw new NoSuchMethodError(var2.getMessage());`
    
313.   `} catch (ClassNotFoundException var3) {`
    
314.   `throw new NoClassDefFoundError(var3.getMessage());`
    
315.   `}`
    
316.   `}`
    
317.  `}`
    


```

  

**点击图片加入Spring交流群**

**↓↓↓**

[![](https://mmbiz.qpic.cn/mmbiz_png/eQPyBffYbueUqfGygawEuambL0BDJu0PFvzIqYF1mxg8966o08VfJG8gDoDrHZJfDNjUHFuj2ViawzIQg4T1enA/640?#imgIndex=0)](http://mp.weixin.qq.com/s?__biz=MzI4Njc5NjM1NQ==&mid=2247487085&idx=2&sn=32803c807f224e7f10f8beadb4d1c929&chksm=ebd63141dca1b85784df30eb718b103108c74a2bb3affdb08d1d7baeaba12a5fb6b5e04c3ec0&scene=21#wechat_redirect)

  

**看完本文有收获？请转发分享给更多人**

![](https://mmbiz.qpic.cn/mmbiz_jpg/eQPyBffYbuecicY10rhWQUiaXX8cMkcofUe4LHnCtaY1RLicpBNm1ssrMUB0alFwE9XhsibXiaVzHuvx1ia2x37iaFMZw/640?#imgIndex=1)