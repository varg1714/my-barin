---
source: https://mp.weixin.qq.com/s?__biz=MjM5ODYxMDA5OQ==&mid=2651976519&idx=1&sn=593fb4f618c47d632039006b74efc820&scene=21&poc_token=HNl__2ijrON1oKVunxAIlV0ZayxOMXSz1O6yOS8D
create: 2025-10-27 22:21
read: true
knowledge: true
knowledge-date: 2025-10-29
tags:
  - 系统架构
summary: "[[聊天系统群消息确认机制]]"
---
《架构师之路：架构设计中的 100 个知识点》

56. 消息可靠投递

前几天聊了 1v1 在线消息，离线消息的可达性：

《[微信：我们绝不丢消息！（第 49 讲）](https://mp.weixin.qq.com/s?__biz=MjM5ODYxMDA5OQ==&mid=2651976369&idx=1&sn=6fb5520b5b0bb34fb56ebbc6ce03e597&scene=21#wechat_redirect)》

《[微信：我绝不丢离线消息！（第 54 讲）](https://mp.weixin.qq.com/s?__biz=MjM5ODYxMDA5OQ==&mid=2651976456&idx=1&sn=05043e5a3132ac5a42d7a5c641b57d34&scene=21#wechat_redirect)》

有水友问我说，微信的群消息，是怎么做到不丢的？  

做过几十年 IM 架构，今天和大家聊聊**消息的可靠投递**。

群聊的核心需求，群友在群内发消息，期望：

1. **在线的群友**能第一时间收到消息；

2. **离线的群友**能在登录后收到消息；

群消息的实时性、可达性、离线消息的复杂度，要远高于 1v1 消息。

  

群业务的核心数据结构如何？

  

**群成员表**：记录群里的群成员。

t_group_users(group_id, user_id)

  

**群离线消息表**：记录群里的离线消息。

t_offine_msgs(user_id, group_id, sender_id, time, msg_id, msg_detail)

  

常见的群消息流程如何？

1. 假设一个群中有 x,A,B,C,D 共 5 个成员，x 发了一个群消息；

2. A 与 B 在线，期望实时收到消息；

3. C 与 D 离线，期望未来拉取到离线消息；  

  

首先，是群在线消息。

![](https://mmbiz.qpic.cn/mmbiz_png/YrezxckhYOwV8b9As9zQBLCt3cgyYr0ICnjfIMbASYN6cBdicO5t85RtywT9coxic93ia3wqJib0JZ3ukzWjI27nTQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1#imgIndex=0)

  
典型群消息投递流程，如 1-5 所述：

1. x 向 server 发出群消息；

2. server 去 db 中查询群用户 (x,A,B,C,D)；

3. server 去 cache 中查询群用户在线状态；

4. 在线的用户 A 与 B，进行实时推送；

5. 离线的用户 C 与 D，进行离线存储；

  

然后，是群离线消息。

![](https://mmbiz.qpic.cn/mmbiz_png/YrezxckhYOwV8b9As9zQBLCt3cgyYr0I1b5aBaJ8DZKywNJ8OD9fgBD9vTVJLZw0BhibAAhF2OjYMLXriaAVBMNQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1#imgIndex=3)

  
典型的群离线消息拉取流程，如 1-3 所述：

1. C 重新登陆的时候，向 server 拉取群离线消息；

2. server 从 db 中拉取离线消息并返回群用户 C；

3. server 从 db 中删除群用户 C 的群离线消息；

  

那么，问题来了！对于同一份群消息的内容，多个离线用户似乎要存储很多份。假设群中有 200 个用户离线，离线消息则冗余了 200 份，这极大地增加了数据库的存储压力。

  

**如何优化，减少消息冗余量？**

为了减少离线消息的冗余度，增加一个群消息表，用来存储所有群消息的内容，离线消息表只存储用户的群离线消息 msg_id，就能大大的降低数据库的冗余存储量。

  

**群消息表**：存储群中所有的消息。

t_group_msgs(group_id, sender_id, time, msg_id, msg_detail)

  

**群离线消息表**，需要进行优化，只存储 msg_id：

t_offine_msgs(user_id, group_id, msg_id)

![](https://mmbiz.qpic.cn/mmbiz_png/YrezxckhYOwV8b9As9zQBLCt3cgyYr0I2Es6dNFM7FJFYPoicW96qvDmib5xfuTw9UqokMmwE4EJsoGzSSGLlPoA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1#imgIndex=6)

  
这样优化后，群在线消息发送需要做对应的调整：

3. 每次发送在线群消息之前，要先存储群消息的内容；

6. 每次存储离线消息时，只存储 msg_id，而不用为每个用户存储 msg_detail；

  

![](https://mmbiz.qpic.cn/mmbiz_png/YrezxckhYOwV8b9As9zQBLCt3cgyYr0IGZZNjyaeZTp2GZG20ZM5Hiajlj7Erc0ZuczC3rC7n4YVHbicqca8zfxA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1#imgIndex=9)

  
拉取离线消息，也需要做对应的修改：

1. 先拉取所有的离线消息 msg_id；

3. 再根据 msg_id 拉取 msg_detail；

5. 删除离线 msg_id；

  

**优化后的流程，能保证消息的可达性么？**  

1. 在线消息的投递可能出现消息丢失，例如服务器重启，路由器丢包，客户端 crash；

2. 离线消息的拉取也可能出现消息丢失，原因同上；

  

很容易想到，必须和 1v1 消息投递一样，需要加入应用层的 ACK。

  

**群消息，如何通过应用层 ACK，保证消息的可靠投递？**

![](https://mmbiz.qpic.cn/mmbiz_png/YrezxckhYOwV8b9As9zQBLCt3cgyYr0I7Df0OB7FXld2UPCAbicHFH3swJ8uyWM3LicSWFibBWpibrQTEZibpicgjgLA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1#imgIndex=12)

  
应用层 ACK 优化后，群在线消息发送又做了调整：

3. 在消息 msg_detail 存储到群消息表后，不管用户是否在线，都先将 msg_id 存储到离线消息表里；

6. 在线的用户 A 和 B 收到群消息后，需要增加一个应用层 ACK，来标识消息到达；

7. 在线的用户 A 和 B 在应用层 ACK 后，将他们的离线消息 msg_id 删除掉；

  

![](https://mmbiz.qpic.cn/mmbiz_png/YrezxckhYOwV8b9As9zQBLCt3cgyYr0Ig8SnIcKqvj6yW8yfM8m3sRlPe1ib4kSBojM7vbFUZbXOjjZIOyicc4xw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1#imgIndex=15)

  
对应到群离线消息的拉取也一样：

1. 先拉取 msg_id；

2. 再拉取 msg_detail；

5. 最后应用层 ACK；

6. server 收到应用层 ACK 才能删除离线消息表里的 msg_id；

  

**如果拉取了消息，却没来得及应用层 ACK，会收到重复的消息么？**

会，但可以在客户端去重，对于重复的 msg_id，对用户不展现，从而不影响用户体验。

  

对于离线的每一条消息，虽然只存储了 msg_id，但是每个用户的每一条离线消息都将在数据库中保存一条记录，**有没有办法减少离线消息的记录数呢？**

  

对于一个群用户，在 ta 登出后的离线期间内，肯定是所有的群消息都没有收到的，不用对所有的每一条离线消息存储一个离线 msg_id，而只需要存储最近一条拉取到的离线消息的 time（或者 msg_id），下次登录时拉取在那之后的所有群消息即可，而没有必要存储每个人未拉取到的所有离线消息 msg_id。

  

**群成员表**，增加一个属性，记录每个群成员最近一条 ACK 的群消息 msg_id（或者 time）。

t_group_users(group_id, user_id, last_ack_msg_id)

**群消息表**，不变，依然存储群中所有的消息：

t_group_msgs(group_id, sender_id, time, msg_id, msg_detail)

  

**群离线消息表**：不再需要。

  

![](https://mmbiz.qpic.cn/mmbiz_png/YrezxckhYOwV8b9As9zQBLCt3cgyYr0IUgbvVLXwb2p5MaTFO8StFcNlqA5IRiao3EJ5gs5Y8KwCL497mTjj3jQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1#imgIndex=18)

  
离线消息表优化后，群在线消息的投递流程：

3. 在消息 msg_detail 存储到群消息表后，不再需要操作离线消息表（优化前需要将 msg_id 插入离线消息表）；

7. 在线的用户 A 和 B 在应用层 ACK 后，将 last_ack_msg_id 更新即可（优化前需要将 msg_id 从离线消息表删除）；

  

![](https://mmbiz.qpic.cn/mmbiz_png/YrezxckhYOwV8b9As9zQBLCt3cgyYr0IsU7jol6rdjX1jYwhzCytF3pqibW1Zz0tGUIkcq8bbngJa4nib6NmGvOQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1#imgIndex=21)

  
群离线消息的拉取流程也类似：

1. 拉取离线消息；

3. ACK 离线消息；

4. 更新 last_ack_msg_id；

  

加入 ACK 机制，假设 1 个群有 500 个用户，“每条” 群消息都会变为 500 个应用层 ACK，似乎会对服务器造成巨大的冲击。**有没有办法减少 ACK 请求量呢？**

批量 ACK，是一种常见的，降低请求量的方式。

  

批量 ACK，批量 ACK 的方式又有两种方式：

1. 每收到 N 条群消息 ACK 一次，这样请求量就降低为原来的 1/N 了；

2. 每隔时间间隔 T 进行一次群消息 ACK，也能达到类似的效果；

  

批量 ACK 有可能导致新的问题：如果还没有来得及 ACK 群消息，用户就退出了，这样下次登录似乎**会拉取到重复的离线消息，怎么办？**  

仍然在客户端去重，对于重复的 msg_id，对用户不展现，不影响用户体验。

  

**群离线消息过多，拉取过慢，怎么办？**

分页拉取（按需拉取），都是常见的优化方案。

  

**总结**

群消息还是非常有意思的，做个简单总结：

1. 不管是群在线消息，还是群离线消息，应用层的 ACK 是可达性的保障；

2. 群消息可以只存一份，不用为每个用户存储离线群 msg_id，只需存储一个最近 ack 的群消息 id/time；

3. 为了减少消息风暴，可以批量 ACK；

4. 如果收到重复消息，需要 msg_id 去重，让用户无感知；

5. 离线消息过多，可以分页拉取（按需拉取）优化；

  

知其然，知其所以然。

**思路比结论更重要。**

== 全文完 ==

  

近期文章：

《[1 亿数据量，uid 分库，tid 上的查询该怎么办？（第 55 讲）](https://mp.weixin.qq.com/s?__biz=MjM5ODYxMDA5OQ==&mid=2651976468&idx=2&sn=bb2d6ecb160424ea3306a7f4b473da14&scene=21#wechat_redirect)》

  

创业了，欢迎围观：

《[40 岁，我创业了，一个人...](https://mp.weixin.qq.com/s?__biz=MjM5ODYxMDA5OQ==&mid=2651976431&idx=1&sn=7f3da0e03fbd2ac6d11bbbce0ecd87f3&scene=21#wechat_redirect)》

未来 10 年，准备全职做职场发展社群，专注于技术人职场发展，欢迎大家加入。