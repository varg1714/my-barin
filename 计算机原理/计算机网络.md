#知识大纲 #计算机原理 #网络

# 1. TCP 与 UDP 的区别

- TCP 面向连接的，而 UDP 是无连接的

- TCP 提供可靠的传输服务

	- 无差错
	
	- 不丢失
	
	- 不重复
	
	- 按序到达
	
	- TCP 通过校验和，重传机制，序号标识，滑动窗口，确认应答实现可靠传输。
	
- UDP 尽最大努力交付

	- UDP 不保证可靠交付，也不保证有序性和准确性
	
	- UDP 面向报文，对应用层交下来的报文不合并，不拆分，保留报文边界
	
	- UDP 没有拥塞机制，即使网络阻塞也不会降低发送速率
	
	- UDP 实时性更好，可以一对一，一对多，多对一和多对多
	
	- TCP 对资源消耗多，UDP 资源消耗少
	
	- DNS、DHCP、TFTP、SNMP 等都基于 UDP 协议

# 2. HTTP 与 HTTPS 区别

- HTTP 使用 80 端口，HTTPS 使用 443 端口

- HTTPS 采用 SSL 认证，通信需要证书

# 3. HTTP、TCP、Socket 的区别

HTTP 是应用层协议，底层采用 TCP 协议实现。使用 TCP 时通过 SOCKET 进行连接建立与通信，SOCKET 是一个门面模式，将 TCP 的协议实现内容隐藏在内部。

# 4. HTTP 版本

- HTTP1.0

	短连接使用一次就关闭连接，重新请求又会重新建立连接
	
- HTTP1.1

	- 长连接复用连接，数据传输后连接保持。使用 Keep-Alive 控制，有一个保存时间。
	
	- 请求管道化：请求可以批量发送，但是必须要按顺序返回。
	
	- 增加 Host 字段，支持断点续传。
	
- HTTP2.0

	- 二进制分帧
	
		- 将数据拆分为一个个帧，每个帧归属于一个流，复用 TCP 连接。多个所属的帧在多个流中并发，达到了真正并行的意义。
		
		- 可以设置特定的优先级，保证优先级高的请求帧优先传输。**有优先级就会有饿死问题。**
		
		- 由于在同一个 TCP 连接中，因此丢包时 TCP 会阻塞等待丢失的包重发，因此丢包率高的情况下性能还不如 HTTP1.1。
		
	- 连接共享：可以复用连接。
	
	- 头部压缩：将原有的文本格式的 http 请求头进行了压缩。
	
	- 服务器推送：服务器可主动推送数据。

# 5. TCP 三次握手四次挥手协议

![](https://varg-my-images.oss-cn-beijing.aliyuncs.com/img/20220507111819.png)

## 5.1. 三次握手原因

**确保服务端与客户端都有收发数据的能力**

1. 第一次握手，服务端收到客户端的请求。服务端确认：客户端有发送数据的能力，自己有接收数据的能力。客户端确认：自己有发送数据的能力。

2. 第二次握手，客户端收到服务端的响应。

	- 服务端确认：客户端有发送数据的能力，自己有发送和接收数据的能力。
	
	- 客户端确认：自己有发送接收和数据的能力。服务端有发送和接收数据的能力。
	
	此时服务端会将此连接的请求放到半连接队列中，第三次握手失败会重试。重试超过一定次数丢弃连接。
	
3. 第三次握手，服务端收到客户端的响应。

	- 这一步确认了客户端有接收数据的能力。至此服务端与客户端双方的收发数据能力都确认完毕，可以开始数据传输。
	
	- 此时该连接进入全连接队列，客户端与服务端开始通信。第三次握手时客户端是可以携带数据，前两次不可以。

## 5.2. 四次挥手原因

**将服务端与客户端的关闭连接时间分开**

1. 前两次挥手

	客户端发起关闭连接给服务端，服务端确认连接关闭
	
2. 后两次挥手

	服务端关闭连接，客户端确认连接关闭
	
客户端第四次挥手等待时间为何是 2MSL?

- 确保服务端收到了自己的确认通知，而不至于导致在服务端没收到通知的情况下连接被关闭。两倍时延为客户端响应一次的时延与服务端重发一次断开请求的时延。

- 只在 TIME_WAIT 阶段进行 2MSL 等待，第二次挥手的时候不会等待的原因是第二次挥手时连接没有真正断开，包数据丢失仍可以重新发送。可第四次挥手不等待的话连接被关闭就没有重新发送的机会了！

- 2MSL 的时间同样可以保证之前的所有数据都在网络中消失，这样下一个连接就不会有旧的数据包了。

# 6. TCP 粘包与拆包

在 socket 通讯过程中，如果通讯的一端一次性连续发送多条数据包，tcp 协议会将多个数据包打包成一个 tcp 报文发送出去，这就是所谓的粘包。而如果通讯的一端发送的数据包超过一次 tcp 报文所能传输的最大值时，就会将一个数据包拆成多个最大 tcp 长度的 tcp 报文分开传输，这就叫做拆包。

- 出现的原因

	- 发送的数据包太小，都放在缓冲区，TCP 将缓冲区数据一起发出产生粘包。
	
	- 发送数据过快，或者接收端接收过慢，导致缓冲区数据堆积产生粘包。
	
	- 数据包过大超过缓冲区空间或者最大报文长度发生拆包。
	
- 解决措施

	由上可以看出，其实粘包与拆包和数据大小有关，这个问题本质和应用层有关，而只是在缓冲区体现出来这个现象而已。
	
	所以一些解决都措施都需要在应用层进行，如发送端增加数据长度属性，接收端根据此判断；固定数据包长度进行接收处理；发送端给数据包增加分隔符使用分隔符处理等，这些都是在应用层做的操作。

# 7. OSI 与 TCP/IP 模型层次

OSI (Open-System-Interconnect) 模型：

- 应用层 ：HTTP/HTTPS/FTP 等协议

- 表示层：进行数据加解密，压缩转换等工作。如 LPP 轻量级表示协议。

- 会话层：负责连接管理，如 SSL 套接字协议，TLS 安全传输协议，RPC 调用协议。

- 传输层：进行数据传输。如 TCP/UDP 协议。

- 网络层：网络寻址转发，逻辑编址与子网划分等。如 IP 协议

- 数据链路层：物理寻址，物理信号与逻辑信号转好控制。如 XTP 协议，PPTP 协议。

- 物理层：实际物理线路相关规范。

TCP/IP 协议：

- 应用层：负责应用数据处理，数据加解密转换，格式转换等。如 HTTP、IAMP、FTP、DHCP、SSH 等。

- 传输层：进行数据传输。如 TCP/UDP 协议。

- 网络层：网络寻址转发，逻辑编址与子网划分等。如 IP 协议

- 物理层：实际物理线路相关规范。

- 数据链路层：物理寻址，物理信号与逻辑信号转好控制。如 XTP 协议，PPTP 协议。

区别：可以看到，OSI 与 TCP/IP 相比最大的区别就是将应用传，表示层，会话层进行了合并。
![](https://varg-my-images.oss-cn-beijing.aliyuncs.com/img/20220507224631.png)

# 8. TCP 的可靠传输原理

TCP 保证传输的有序性、不丢失、无差错，主要通过以下几点实现：

- 确认机制

	当收到 seq 为 x 的数据后，会返回 ack=x+1，期待下一个收到的数据是 x+1。发送方此时发送了 x+1, x+2, x+3 三个数据，若 x+1 数据丢失了，接收方仍会返回 ack=x+1，x+2, x+3 会暂存在缓冲区。等到 x+1 超时重传了，此时接收方累计确认，ack=x+4。

- 流量控制

	1. 接收方会维护一个接收窗口大小，用于告诉发送方可接收的最大数据量。计算规则为：$窗口大小=总缓存大小-已接收未读数据大小+已接收可删除数据大小$。
	
	2. 当发送方发送数据时，接收方会返回此窗口大小。发送方根据窗口大小动态调整发送数据，称之为滑动窗口。
	
	3. 当发送方记录的滑动窗口为 0，接收方有空间了尝试更新窗口值，会给发送方通知。为了避免该通知丢失，接收方维持了一个定时器。该定时器自动探测接收方窗口是否变化。
	
- 拥塞避免

	为了避免网络原因导致的大批数据发送而压垮接收方，因此引入了拥塞避免机制。拥塞避免机制根据接收方网络情况动态调整发送的数据量大小。
	
	拥塞控制有以下几个核心参数：cwnd (congestion window)：当前窗口大小；ssthresh：慢开始门限值，初始值 16。
	
	1. 慢开始
	
		1. 首先发送方从 cwnd=1 开始发送数据，收到 ack 后 $cwnd = cwnd \times 2$，直到到达 ssthresh 门限值。
		
		2. 到达门限制后转为拥塞避免算法。
		
	2. 拥塞避免
	
		Reno 算法：从 ssthresh 值开始，cwnd 窗口改为加法递增，每次+1；当发生网络阻塞丢包时，ssthresh 变为 cwnd 的一半。
		
		实际上 Reno 算法并不是 TCP 协议中的真正实现，因为骤降一半虽然可以避免大量数据涌入网络，但非平滑的过渡仍非常影响性能。特别是在包偶尔丢失的情况下。
		
		许多算法对此进行了[改进](https://www.jiqizhixin.com/articles/2020-06-01-12)，这些算法寻求一个平稳的过渡，有兴趣的可以看下。
		
	3. 快重传
	
		快重传要求接收方一旦收到一个失序报文后就立马发出确认，使发送方知道数据发生丢失。
		
		接收方存在数据缓存的情况，有可能不会立马发出 ack 通知，而是将通知等到接收方给发送方发通知的时候捎带过去。快重传避免这种情况。
		
	4. 快恢复
	
		在连续收到三个 ack 后，发送方知道数据丢失，因此重新发送数据。数据丢失可能是网络拥堵，因此发送方会将 ssthresh 降低为原始一半，然后开始加法递增。
		
- 超时时间的确定

	- $RTTs_n (平滑往返时间) = (1 - \alpha) \times RTTs_{n-1} + \alpha × 新的 RTT 样本$，(RFC6298 标准推荐 $\alpha$ 值为 0.125)
	
	- $RTO (超时重传时间) = RTTs_n + 4 \times RTTd_n$
	
	- $新的 RTTd_n = (1 - \beta) \times RTTd_{n-1} + \beta × (RTTs_n - 新的 RTT 样本)$，(RFC6298 标准推荐 $\beta$ 值为 0.25)，第一个报文段的 $RTTd_{1}$ 值：$RTTd_{1} = RTT_1 \div 2$ 

![](https://varg-my-images.oss-cn-beijing.aliyuncs.com/img/20220507194831.png)
![](https://varg-my-images.oss-cn-beijing.aliyuncs.com/img/20220507194925.png)

# 9. ARQ (Automatic Repeat-Request) 协议与滑动窗口协议

## 9.1. 停止等待协议 ARQ 协议

每发送完一个分组就停止发送，直到确认后发送下一个。失败则重传。需要处理以下几类问题：

- 无差错情况

- 出现差错情况：超时重传

- 确认丢失：超时重传

- 确认延迟：延迟后已经重传数据，对于延迟到达的确认接收不处理
	
## 9.2. 连续 ARQ 协议

连续发送多个分组，采用累计确认的形式。此过程可用滑动窗口记录。当出现数据需要重传的情况，需要回退到上一个确认的分组号进行重发。

滑动窗口协议：在发送方和接收方各自维护一个滑动窗口。

- 发送方窗口

	- 已发送并收到确认的数据（不在发送窗口和发送缓冲区之内）
	
	- 已发送但未收到确认的数据（位于发送窗口之内）
	
	- 允许发送但尚未发送的数据（位于发送窗口之内）
	
	- 发送窗口之外的缓冲区内暂时不允许发送的数据
	
- 接收方窗口

	- 已发送确认并交付主机的数据（不在接收窗口和接收缓冲区之内）
	
	- 未按序收到的数据（位于接收窗口之内）
	
	- 允许的数据（位于接收窗口之内）
	
	- 不允许接收的数据（位于发送窗口之内）

规则：
	
- 凡是已经发送过的数据，在未收到确认之前，都必须暂时保留，以便在超时重传时使用。

- 只有当发送方 A 收到了接收方的确认报文段时，发送方窗口才可以向前滑动几个序号。

- 当发送方 A 发送的数据经过一段时间没有收到确认（由超时计时器控制），就要使用回退 N 步协议，回到最后接收到确认号的地方，重新发送这部分数据。

