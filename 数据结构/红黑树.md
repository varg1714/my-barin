
# 1. 二叉查找树

由于红黑树本质上就是一棵二叉查找树（Binary Search Tree），也称有序二叉树（ordered binary tree）, 排序二叉树（sorted binary tree），是指一棵空树或者具有下列性质的二叉树：

* 若任意节点的左子树不空，则左子树上所有节点的值均小于它的根节点的值。
* 若任意节点的右子树不空，则右子树上所有节点的值均大于它的根节点的值。
* 任意节点的左、右子树也分别为二叉查找树。
* 没有键值相等的节点（no duplicate nodes）。

因为，一棵由 n 个节点，随机构造的二叉查找树的高度为 lgn，所以顺理成章，一般操作的执行时间为 O（lgn）。

但二叉树若退化成了一棵具有 n 个节点的线性链后，则此些操作最坏情况运行时间为 O（n）。二叉查找树-红黑树，它通过一些性质使得树相对平衡，使得最终查找、插入、删除的时间复杂度最坏情况下依然为 O（lgn）。

# 2. 红黑树

### 2.1. 红黑树性质

红黑树本质上来说就是一棵二叉查找树，但它在二叉查找树的基础上增加了着色和相关的性质使得红黑树相对平衡，从而保证了红黑树的查找、插入、删除的时间复杂度最坏为 O (log n)。

但它是如何保证一棵 n 个节点的红黑树的高度始终保持在 h = logn 的呢？这就引出了红黑树的 5 条性质：

1. 每个节点要么是红的，要么是黑的。  
2. 根节点是黑的。  
3. 每个叶节点（叶节点即指树尾端 NIL 指针或 NULL 节点）是黑的。  
4. 如果一个节点是红的，那么它的俩个儿子都是黑的。  
5. 对于任一节点而言，其到叶节点树尾端 NIL 指针的每一条路径都包含相同数目的黑节点。  

正是红黑树的这 5 条性质，使得一棵 n 个节点是红黑树始终保持了 logn 的高度，从而也就解释了上面我们所说的“红黑树的查找、插入、删除的时间复杂度最坏为 O (log n)”这一结论的原因。

如下图所示，即是一颗红黑树：

![image.png](https://r2.129870.xyz/img/202309091731905.png)

上文中我们所说的 "叶节点" 或"NULL 节点"，它不包含数据而只充当树在此结束的指示，这些节点以及它们的父节点，在绘图中都会经常被省略。

## 2.1. 树的旋转知识

当我们在对红黑树进行插入和删除等操作时，对树做了修改，那么可能会违背红黑树的性质。

为了继续保持红黑树的性质，我们可以通过对节点进行重新着色，以及对树进行相关的旋转操作，即修改树中某些节点的颜色及指针结构，来达到对红黑树进行插入或删除节点等操作后，继续保持它的性质或平衡。

树的旋转，分为左旋和右旋，以下借助图来做形象的解释和介绍：

1. 左旋
    
    ![image.png](https://r2.129870.xyz/img/202309112334839.png)
    
    当在某个节点 pivot 上，做左旋操作时，我们假设它的右孩子 y 不是 NIL\[T\]，pivot 可以为任何不是 NIL\[T\]的左孩子节点。
    
    左旋以 pivot 到 y 之间的链为“支轴”进行，它使 y 成为该孩子树新的根，而 y 的左孩子 b 则成为 pivot 的右孩子。

2. 右旋
    右旋与左旋操作类似。
    
    ![image.png](https://r2.129870.xyz/img/202309091732498.png)

对于树的旋转，能保持不变的只有原树的搜索性质，而原树的红黑性质则不能保持，在红黑树的数据插入和删除后可利用旋转和颜色重涂来恢复树的红黑性质。

## 2.2. 红黑树的插入

要真正理解红黑树的插入和删除，还得先理解二叉查找树的插入和删除。

### 2.2.1. 二叉查找树的插入

如果要在二叉查找树中插入一个节点，首先要查找到节点插入的位置，然后进行插入，假设插入的节点为 z 的话，插入的伪代码如下：

在二叉查找树中查找 z 待插入的位置，如果插入节点 z 小于当前遍历到的节点，则到当前节点的左子树中继续查找，如果 z 大于当前节点，则到当前节点的右子树中继续查找，找到待插入的位置时，如果 z 依然比此刻遍历到的新的当前节点小，则 z 作为当前节点的左孩子，否则作为当前节点的右孩子。

### 2.2.2. 红黑树的插入和插入修复

现在我们了解了二叉查找树的插入，接下来咱们便来具体了解红黑树的插入操作。红黑树的插入相当于在二叉查找树插入的基础上，为了重新恢复平衡，继续做了插入修复操作。**对于新插入的节点，该节点被标记为红色**。

假设插入的节点为 z：
* 如果插入的是根节点，因为原树是空树，此情况只会违反性质 2，所以直接把此节点涂为黑色。
* 如果插入的节点的父节点是黑色，由于此不会违反性质 2 和性质 4，红黑树没有被破坏，所以此时也是什么也不做。

但当遇到下述 3 种情况时，需要对红黑树做一定操作才可继续满足性质：
* 插入修复情况 1：当前节点的父节点是红色，叔叔节点是黑色，当前节点是其父节点的左子。
    解法：父节点变为黑色，祖父节点变为红色，在祖父节点为支点右旋，最后，把根节点涂为黑色，整棵红黑树便重新恢复了平衡。
    
    > [!note] 要求是左节点且右旋的原因
    > </br>
    > **本质是由于左子树多了一个节点，所以以右旋的方式平衡节点。**
    > 
    > 另外由于当前节点是红色，父节点也是红色，所以对父节点染黑，祖父节点染红并右旋从而使染色规则符合红黑树定义。右旋时祖父节点是红色的，所以就要求叔叔节点（旋转后的右子树）是黑色的。
    
    示例：当前节点为 2 节点：
    
    ![[Excalidraw/数据结构/红黑树.md#^group=CNXhqmOszCpf5N5tYtZQe]]
    
* 插入修复情况 2：当前节点的父节点是红色，叔叔节点是黑色，当前节点是其父节点的右子。
    对策：当前节点的父节点做为新的当前节点，以新当前节点为支点左旋。左旋后就转换成了情况 1 中的局面，然后继续进行修复操作。

    示例：当前节点为 7 节点：
    
    ![[Excalidraw/数据结构/红黑树.md#^group=vylqmmv792g2atso5dbKe]]
    
* 插入修复情况 3：如果当前节点的父节点是红色且叔叔节点是红色。
    此时祖父节点一定存在，否则插入前就已不是红黑树。与此同时，又分为父节点是祖父节点的左子还是右子，对于对称性，我们只要解开一个方向就可以了。在此，我们只考虑父节点为祖父左子的情况。同时，还可以分为当前节点是其父节点的左子还是右子，但是处理方式是一样的。我们将此归为同一类。

    **对策：将当前节点的父节点和叔叔节点涂黑，祖父节点涂红，把当前节点指向祖父节点，从新的当前节点重新开始算法**。这么操作的原因是为了将其转换为情况 1 或者情况 2 中的局面，其实最后都会转换为情况 1 来处理。
    
    当前节点为 4 节点：
    
    ![[Excalidraw/数据结构/红黑树.md#^group=x7utoQXN3sOH41K4GTIP3]]
    

## 2.3. 红黑树的删除

我们删除的节点的方法与常规二叉搜索树中删除节点的方法是一样的：
- 如果被删除的节点有唯一的叶子节点，则直接删除这个节点，用它的唯一子节点顶替它的位置，如果它的子节点都是空节点，那就用空节点顶替它的位置。
- 如果它的双子全为非空，我们就把它的后继节点内容复制到它的位置，之后操作就变成删除它的后继节点，它的后继节点不可能是双子非空，因此此传递过程最多只进行一次。

### 2.3.1. 二叉查找树的删除

继续讲解之前，补充说明下二叉树节点删除的几种情况，待删除的节点按照儿子的个数可以分为三种：

1.  没有儿子，即为叶节点。直接把父节点的对应儿子指针设为 NULL，删除儿子节点就 OK 了。
2.  只有一个儿子。那么把父节点的相应儿子指针指向儿子的独生子，删除儿子节点也 OK 了。
3.  有两个儿子。
    这是最麻烦的情况，因为删除节点之后，还要保证满足搜索二叉树的结构。
    
    我们可以选择左儿子中的最大元素或者右儿子中的最小元素放到待删除节点的位置，就可以保证结构的不变。当然，要记得调整子树，毕竟又出现了节点删除。
    
    习惯上大家选择左儿子中的最大元素，其实选择右儿子的最小元素也一样，没有任何差别。这里也选择左儿子的最大元素，将它放到待删节点的位置。左儿子的最大元素其实很好找，只要顺着左儿子不断的去搜索右子树就可以了，直到找到一个没有右子树的节点。那就是最大的了。
    
    找到左儿子最大的节点后，将其值复制到删除节点的位置。从而删除操作变成了删除左儿子最大的节点。

### 2.3.2. 红黑树的删除和删除修复

红黑树在删除节点后，原红黑树的性质可能被改变：
- 如果删除的是红色节点，那么原红黑树的性质依旧保持，此时不用做修正操作。
- 如果删除的节点是黑色节点，原红黑树的性质可能会被改变，我们要对其做修正操作。
    那么哪些[[数据结构/红黑树#2.1. 红黑树性质|树的性质]]会发生变化呢：
    - 路径上黑色节点数发生变化
        如果删除节点不是树唯一节点，那么删除节点的那一个支的到各叶节点的黑色节点数会发生变化，此时性质 5 被破坏。
    - 红色节点的子节点颜色发生变化
        - 如果被删节点的唯一非空子节点是红色，而被删节点的父节点也是红色，那么性质 4 被破坏。
        - 如果被删节点是根节点，而它的唯一非空子节点是红色，则删除后新根节点将变成红色，违背性质 2。

上面的修复情况看起来有些复杂，下面我们用一个分析技巧：我们**从被删节点后来顶替它的那个节点开始调整，并认为它有额外的一重黑色**。

这里额外一重黑色是什么意思呢，我们不是把红黑树的节点加上除红与黑的另一种颜色，这里只是一种假设，我们认为我们当前指向它，因此空有额外一种黑色，可以认为**它的黑色是从它的父节点被删除后继承给它的，它现在可以容纳两种颜色**，如果它原来是红色，那么现在是红+黑，如果原来是黑色，那么它现在的颜色是黑+黑。

有了这重额外的黑色，原红黑树性质 5 就能保持不变。现在只要恢复其它性质就可以了，做法还是尽量向根移动和穷举所有可能性。

如果是以下情况，恢复比较简单：
* 当前节点是红+黑色
    解法，直接把当前节点染成黑色，结束此时红黑树性质全部恢复。
* 当前节点是黑+黑且是根节点
    解法：什么都不做，结束。

但如果是以下情况呢？
* 删除修复情况 1：当前节点颜色是黑-黑色，它的兄弟节点是黑色，但是兄弟节点的右子是红色，兄弟节点左子的颜色任意
    解法：把兄弟节点染成当前节点父节点的颜色，兄弟节点右子染成黑色，把当前节点父节点染成黑色，之后以当前节点的父节点为支点进行左旋，此时算法结束，红黑树所有性质调整正确。

    **本质是由于左子树少了一个节点，所以以左旋的方式平衡节点。**
    
    ![[Excalidraw/数据结构/红黑树.md#^group=pAqb0Bpr9hrumiR0QP4Sa]]
* 删除修复情况 2：当前节点颜色是黑+黑，兄弟节点是黑色，兄弟的左子是红色，右子是黑色
    解法：把兄弟节点染红，兄弟左子节点染黑，之后再在兄弟节点为支点解右旋，之后重新进入算法。
    
    此操作是把当前的情况转化为情况 1，而性质 5 得以保持。
    
    ![[Excalidraw/数据结构/红黑树.md#^group=kWfB5iI1mr-71_S7JqbnO]]
* 删除修复情况 3：当前节点是黑加黑且兄弟是黑色且兄弟节点的两个子节点全为黑色
    解法：把当前节点和兄弟节点中抽取一重黑色追加到父节点上，把父节点当成新的当前节点，重新进入算法。
    
    此操作是为了将当前情况转变为情况 1 或情况 2 而进行的。
    
    ![[Excalidraw/数据结构/红黑树.md#^group=5ier4tMJNt7hfV51xcEa5]]
* 删除修复情况 4：当前节点是黑+黑且兄弟节点为红色 (此时父节点和兄弟节点的子节点分为黑)
    解法：把兄弟节点染成黑色，把父节点染成红色，并对父节点进行左旋，之后重新进入算法（我们只讨论当前节点是其父节点左孩子时的情况）。

    此变换后原红黑树性质 5 不变，而把问题转化为兄弟节点为黑色的情况 (注：变化前，原本就未违反性质 5，只是为了**把问题转化为兄弟节点为黑色的情况**)。
    
    ![[Excalidraw/数据结构/红黑树.md#^group=UqqyYB_KGSevXL_IRAxir]]




