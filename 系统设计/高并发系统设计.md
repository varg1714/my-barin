
# 1. 系统设计原则

## 1.1. 系统通用设计方法

在应对高并发大流量时会采用类似水库抵御洪水的方案，归纳起来共有三种方法：
- Scale-up（纵向扩展）与 Scale-out（横向扩展）
    纵向扩展旨在增加机器配置达到应对请求流量的目的，然而随着硬件发展，摩尔定律已经失效，所以纵向扩展前期能收获一定成果，但有一定上限。

    横向扩展，分而治之是一种常见的高并发系统设计方法，采用分布式部署的方式把流量分流开，让每个服务器都承担一部分并发和流量。
    
    Scale-out 虽然能够突破单机的限制，但也会引入一些复杂问题。比如，如果某个节点出现故障如何保证整体可用性？当多个节点有状态需要同步时如何保证状态信息在不同节点的一致性？如何做到使用方无感知的增加和删除节点？其中每一个问题都涉及很多方面，因此需要仔细考虑。
- 缓存
    使用缓存来提高系统的性能，就好比用“蓄水池”的方式抵抗高并发大流量的冲击。
- 异步
    在某些场景下，未处理完成之前我们可以让请求先返回，在数据准备好之后再通知请求方，这样可以在单位时间内处理更多的请求。

这些技术不一定要全部用上，系统的演进过程应当遵循以下思路：
- 最简单的系统设计满足业务需求和流量现状，选择最熟悉的技术体系。
- 随着流量的增加和业务的变化，修正架构中存在的问题
    如单点问题，横向扩展问题，性能无法满足需求的组件。在这个过程中，选择社区成熟的、团队熟悉的组件帮助我们解决问题，在社区没有合适解决方案的前提下才会自己造轮子。
- 对架构的小修小补无法满足需求时，考虑重构、重写等大的调整方式以解决现有的问题。

## 1.2. 系统的分层架构

分层的好处：
- 分层的设计可以简化系统设计，让不同的人专注做某一层次的事情。
- 分层之后可以做到很高的复用。
- 分层架构可以让我们更容易做横向扩展。

任何的方案架构都是有优势有缺陷的，它最主要的一个缺陷就是增加了代码的复杂度，也可能会有性能的损耗，但是相比于它能带给我们的好处来说，这些都是可以接受的，或者可以通过其它的方案解决的。我们在做决策的时候切不可以偏概全，因噎废食。

## 1.3. 高并发系统设计思路

1. 高性能
    - 性能的度量指标：平均值、最大值、最小值、分位值等。
    - 性能的优化方式
        - 提升处理核心数
            例如提升进程数量，但需要注意测试进程数量与性能的关系，找到拐点。
        - 提升单次任务响应时间
2. 高可用
    高可用要求提升系统的可用性，也就是我们常说的几个 9。
    系统设计方面：可以从故障恢复、超时控制、降级、限流几方面进行。
    系统运维方面：可以从灰度发布，故障演练两方面进行。
3. 高扩展
    - 存储层的扩展：数据库拆分。
    - 业务层的扩展：按业务维度、重要维度、请求来源等进行拆分。

# 2. 系统设计方法

## 2.1. 数据库篇

### 2.1.1. 池化技术

我们所管理的某些对象，无论是连接还是线程，它们的创建过程都比较耗时，也比较消耗系统资源。所以，我们把它们放在一个池子里统一管理起来，以达到提升性能和资源复用的目的。

这是一种常见的软件设计思想，叫做**池化技术，它的核心思想是空间换时间，期望使用预先创建好的对象来减少频繁创建对象的性能开销**，同时还可以对对象进行统一的管理，降低了对象的使用的成本，总之是好处多多。

不过，池化技术也存在一些缺陷，比方说存储池子中的对象肯定需要消耗多余的内存，如果对象没有被频繁使用，就会造成内存上的浪费。再比方说，池子中的对象需要在系统启动的时候就预先创建完成，这在一定程度上增加了系统启动时间。可这些缺陷相比池化技术的优势来说就比较微不足道了，只要我们确认要使用的对象在创建时确实比较耗时或者消耗资源，并且这些对象也确实会被频繁地创建和销毁，我们就可以使用池化技术来优化。

使用池化技术时，需要注意以下几点：
- 池子的最大值和最小值的设置很重要，初期可以依据经验来设置，后面还是需要根据实际运行情况做调整。
- 池子中的对象需要在使用之前预先初始化完成，这叫做池子的预热，比方说使用线程池时就需要预先初始化所有的核心线程。如果池子未经过预热可能会导致系统重启后产生比较多的慢请求。
- 池化技术核心是一种空间换时间优化方法的实践，所以要关注空间占用情况，避免出现空间过度使用出现内存泄露或者频繁垃圾回收等问题。

### 2.1.2. 数据复制与分区

对数据进行[[数据密集型系统设计2：复制与分区|复制与分区]]，保证数据的可用性及性能，对于数据库可以采用主从部署来实现数据复制，使用分库分表来实现分区的效果。

#### 2.1.2.1. 复制之主从分离

对于大部分系统的访问模型其实都是读多写少，所以一种自然的处理就是将读请求与写请求分发到不同的服务上，即主从读写分离。

对于主从分离，主要有三个问题需要思考：
1. 主从间数据如何同步？
    这其实是一个[[数据密集型系统设计2：复制与分区#1. 数据复制|数据复制]]问题，常见的有同步复制，异步复制，链式复制。采取不同的复制方式会对主服务器的性能以及主从之间的延迟产生影响。从服务器越多，主服务器的压力自然越大，而异步复制的形式往往又带来延迟问题。因此需要根据实际情况来作出决定。
2. 主从间的延迟如何解决？
    如果采取的不是同步复制的形式，那么主从之间会存在延迟问题，这也就意味着从服务器读到的并不一定是最新的数据。如果对于数据一致性非常敏感的系统，那么同步复制的方式是应该优先考虑的。
    
    对于异步复制的系统，虽然无法完全避免延迟问题，但是仍然有一些方式来减少这种影响：
    - 数据冗余
        对于使用从服务器的系统，如果有其它信息渠道可以得到完整的数据，那么就可以避免这种影响。例如消息队列发送消息时带上完整的数据内容，而不仅仅只是数据 ID。
    - 缓存
        与数据冗余类似，如果可以从缓存中获取到数据的话，那么也可以避免从从库查询。但是缓存的数据如果也有延迟的话，这就避免不了了。
    - 主库查询
        无奈之举就只能从主服务器查询。
3. 客户端如何处理主从服务？
    当进行主从分离以后，客户端如何处理主从服务器呢？常见的有两种方式：
    1. 客户端代理
        客户端基于一些组件，实现主服务器与从服务器的请求转发。
    2. 代理层中转
        基于专门的主从代理服务器来实现请求转发，例如 Mycat 服务。

#### 2.1.2.2. 分区之分库分表

随着应用的数据量越来越大，应用的性能开始受到影响：数据量太多磁盘空间不足；索引深度变深查询变慢；所有数据在同一个库上，牵一发而动全身。这些问题可以归纳为数据库的写入请求量大造成的性能和可用性方面的问题，而常见的一种处理方式就是分库分表。

分库分表有两种方式：
1. 垂直拆分
    垂直拆分即将将数据库的表拆分到多个不同的数据库中，拆分的原则一般是按照业务类型来拆分。
2. 水平拆分
    垂直拆分可以在一定程度上减少数据量，但是无法避免单表数据量过大的问题，因此最后需要对数据进行水平拆分，即将将单一数据表按照某一种规则拆分到多个数据库和多个数据表中，关注点在数据的特点。
    
    拆分可以按关键字分区或者按关键字的哈希值分区。

数据库在分库分表之后，数据的访问方式也有了极大的改变，原先只需要根据查询条件到从库中查询数据即可，现在则需要先确认数据在哪一个库表中，再到那个库表中查询数据。

分库分表带来的另一个问题就是原本的一次数据查询可能需要改造，比如多表的 join 在单库时是可以通过一个 SQL 语句完成的，但是拆分到多个数据库之后就无法跨库执行 SQL 了。
