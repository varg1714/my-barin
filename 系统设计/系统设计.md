## 1. 互联网场景设计

### 1.1. 分页查询

#### 1.1.1. 查询方式

1. from+size 的形式
    适用于小数据量或者分页数量不多的情况（ES 中该上限默认为 1 万，超过此条数的分页查询无法使用 from+size 的方式实现）。实现原理为跳过前 from 条数据然后取之后的 size 条数据，例如 mysql 中的 limit 语句。
    
    此方式在大数据量情况下性能不佳的原因是必须跳过前 from 条数据，并且随着页码越大需要跳过的数据则越多，性能损失越大。
2. 滚动翻页
    滚动翻页实现效果为逐页浏览，无法跳页，实现方式为游标。
    
    整体实现思路如下：
    
    1. 首先根据一定的过滤条件进行查询（同时可能会携带排序条件）获取第一页数据
    2. 将第一页数据最后一条数据的偏移量作为第二页数据的起始偏移量
        这个偏移量是一个**唯一 ID**。如果查询条件中本身已经携带了唯一 ID 的排序条件，那么可以直接使用该 ID，否则需要显式或者隐式的生成一个唯一 ID。例如基于主键的 ID 或者基于数据节点的 ID。
        
        唯一 ID 的作用在于避免数据相同（例如名称相同）的情况下无法精准定位的问题。
    3. 为了能有效利用该偏移量，数据必须是有序的，排序过程可能也是显式或者隐式的

#### 1.1.2. 数据混乱问题

不管是哪种查询方式，都可能出现数据混乱的问题。由于查询期间的数据插入，编辑和删除的操作，这些变更的数据会影响原查询数据的顺序。

- 数据插入
    例如原查询列表按照 ID 倒序，此时新插入的数据 ID 会出现在原列表的第一页，导致第二页数据重复。
- 数据删除
    删除原第一页中的部分数据，第二页数据查询时错误的跳过一定条数的数据。
- 数据修改
    由于参与排序的字段值被修改，导致原查询条件中排序结果不再适用。

解决方案：

- 携带上次查询的 ID 
    - 方案
        将上一次查询数据中的最后一条数据 ID 作为参数传递给下一次的请求，后续页的数据查询条件中，其数据 ID 需要大于或小于该值。
        
        ```sql
        SELECT *
        FROM TABLE
        WHERE id > 'id' LIMIT m,n;
        ```
        
    - 前提
        数据数据包含有序的 ID。
- 请求时间&创建时间
    - 方案
        类似于 ID 的方式，在查询结果中返回首次查询的时间，之后将该时间作为参数用于控制后续查询，被查询的数据创建时间必须在该时间之前。
        
        ```sql
        SELECT *
        FROM TABLE
        WHERE create_time < 'time' LIMIT m,n;
        ```
        
    - 前提
        数据数据包含创建时间。
- 分页位置标记
    - 方案
        查询不再基于 from+size 的方式，而是基于上一次查询的最后位置然后偏移 size 的方式。第一次查询后返回最后一条数据的位置（唯一 ID 或者时间戳），之后的数据根据此位置向后再偏移 size 条数的数据。
        
        ```sql
        SELECT *
        FROM TABLE
        WHERE tid > 'tid' LIMIT n;
        ```
        
    - 前提
        数据列表中需要返回这样的偏移量。
- 快照
    - 方案
        首次查询后，将数据集进行快照化存储，之后每次的查询都基于这个快照进行。
    - 前提
        需要具备数据快照化的能力。
- 全量返回，客户端分页
    - 方案
        服务端直接返回全部的数据，由客户端进行分页效果展示。
    - 前提
        数据条数足够少，否则返回全量数据性能不好。

解决程度：

| 方案         | 新增数据问题 | 删除数据问题 | 修改数据问题 |
| ---------- | ------ | ------ | ------ |
| 携带上次查询的 ID | 是      | 否      | 否      |
| 请求时间&创建时间  | 是      | 否      | 否      |
| 分页位置标记     | 是      | 是      | 否      |
| 快照         | 是      | 是      | 是      |
| 全量返回，客户端分页 | 是      | 是      | 是      |

性能与资源消耗对比：

| 方案         | CPU消耗 | 内存消耗 | 存储消耗 | 实现复杂度 | 适用规模  |
| ---------- | ----- | ---- | ---- | ----- | ----- |
| 携带上次查询的ID  | 低     | 低    | 无    | 低     | 大规模系统 |
| 请求时间&创建时间  | 低     | 低    | 无    | 低     | 大规模系统 |
| 分页位置标记     | 低     | 低    | 低    | 中     | 大规模系统 |
| 快照         | 高     | 高    | 高    | 中     | 小规模系统 |
| 全量返回，客户端分页 | 高     | 高    | 无    | 低     | 仅小数据量 |

#### 1.1.3. ES 的深度分页示例

ES 支持深度分页查询，基于 search_after 方式实现。

1. 第一页查询
    ```js
    POST my-index-000001/_search
    {
        "size": 10,
        "query": {
            "match" : {
                "title" : "es"
            }
        },
        "sort": [
            {"date": "asc"},
            // 确保唯一性
            {"_id": "desc"}
        ]
    }
    ```
2. ES 返回数据
    ```js
    {
          "took" : 29,
          "timed_out" : false,
          "_shards" : {
            "total" : 1,
            "successful" : 1,
            "skipped" : 0,
            "failed" : 0
          },
          "hits" : {
            "total" : {
              "value" : 5,
              "relation" : "eq"
            },
            "max_score" : null,
            "hits" : [
              {
                ...
                },
                "sort" : [
                  ...
                ]
              },
              {
                ...
                },
                "sort" : [
                  124648691,
                  "624812"
                ]
              }
            ]
          }
        }
    ```
3. 传入分页位置标记：将返回的最后一条记录的 sort 值作为条件传入
    ```js
    GET my-index-000001/_search
    {
        "size": 10,
        "query": {
            "match" : {
                "title" : "es"
            }
        },
        // 上一次返回的结果
        "search_after": [124648691, "624812"],
        "sort": [
            {"date": "asc"},
            {"_id": "desc"}
        ]
    }
    ```

为了避免新写入的数据影响原查询，可以采用 [PIT](https://www.elastic.co/guide/en/elasticsearch/reference/8.4/point-in-time-api.html) 快照的方式进行：
1. 创建快照
    keep_alive 指定了该快照的存活时间。
    ```js
    POST /my-index-000001/_pit?keep_alive=1m
     
    // 返回一个PIT ID：
    {
      "id": "46ToAwMDaWR5BXV1aWQyKwZub2RlXzMAAAAAAAAAACoBYwADaWR4BXV1aWQxAgZub2RlXzEAAAAAAAAAAAEBYQADaWR5BXV1aWQyKgZub2RlXzIAAAAAAAAAAAwBYgACBXV1aWQyAAAFdXVpZDEAAQltYXRjaF9hbGw_gAAAAA=="
    }
    ```
2. 查询该快照
    利用上一步返回的快照 ID 进行查询，查询后会自动将该快照续期。
    ```js
    GET /_search
    {
      "size": 10000,
      "query": {
        "match" : {
          "user.id" : "elkbee"
        }
      },
      "pit": {
         "id":  "46ToAwMDaWR5BXV1aWQyKwZub2RlXzMAAAAAAAAAACoBYwADaWR4BXV1aWQxAgZub2RlXzEAAAAAAAAAAAEBYQADaWR5BXV1aWQyKgZub2RlXzIAAAAAAAAAAAwBYgACBXV1aWQyAAAFdXVpZDEAAQltYXRjaF9hbGw_gAAAAA==", 
         "keep_alive": "1m"
      },
      "sort": [ 
        {"@timestamp": {"order": "asc", "format": "strict_date_optional_time_nanos", "numeric_type" : "date_nanos" }}
      ]
    }
    ```
3. 销毁快照
    虽然快照有有效期会自动清理，但为了性能考虑尽可能的在使用完后手动将其释放。
    ```js
    DELETE /_pit
    {
        "id" : "46ToAwMDaWR5BXV1aWQyKwZub2RlXzMAAAAAAAAAACoBYwADaWR4BXV1aWQxAgZub2RlXzEAAAAAAAAAAAEBYQADaWR5BXV1aWQyKgZub2RlXzIAAAAAAAAAAAwBYgACBXV1aWQyAAAFdXVpZDEAAQltYXRjaF9hbGw_gAAAAA=="
    }
    ```