#设计模式

# 1. 创建型模式

## 1.1. 简单工厂模式

现实生活中，原始社会自给自足（没有工厂），农耕社会小作坊（简单工厂，民间酒坊），工业革命流水线（工厂方法，自产自销），现代产业链代工厂（抽象工厂，富士康）。我们的项目代码同样是由简到繁一步一步迭代而来的，但对于调用者来说，却越来越简单。

在日常开发中，凡是需要生成复杂对象的地方，都可以尝试考虑使用工厂模式来代替。

> [!warning] 复杂对象
> 
> 注意：上述复杂对象指的是类的构造函数参数过多等对类的构造有影响的情况，因为类的构造过于复杂，如果直接在其他业务类内使用，则两者的耦合过重，后续业务更改，就需要在任何引用该类的源代码内进行更改，光是查找所有依赖就很消耗时间了，更别说要一个一个修改了。

### 1.1.1. 工厂模式的定义

定义一个创建产品对象的工厂接口，将产品对象的实际创建工作推迟到具体子工厂类当中。这满足创建型模式中所要求的 “创建与使用相分离” 的特点。

按实际业务场景划分，工厂模式有 3 种不同的实现方式，分别是简单工厂模式、工厂方法模式和抽象工厂模式。

我们把被创建的对象称为 “产品”，把创建产品的对象称为 “工厂”。如果要创建的产品不多，只要一个工厂类就可以完成，这种模式叫 “简单工厂模式”。

在简单工厂模式中创建实例的方法通常为静态（static）方法，因此简单工厂模式（Simple Factory Pattern）又叫作静态工厂方法模式（Static Factory Method Pattern）。

简单来说，简单工厂模式有一个具体的工厂类，可以生成多个不同的产品，属于创建型设计模式。简单工厂模式不在 GoF 23 种设计模式之列。

简单工厂模式每增加一个产品就要增加一个具体产品类和一个对应的具体工厂类，这增加了系统的复杂度，违背了 “开闭原则”。

 “工厂方法模式” 是对简单工厂模式的进一步抽象化，其好处是可以使系统在不修改原来代码的情况下引进新的产品，即满足开闭原则。

### 1.1.2. 优点和缺点

#### 1.1.2.1. 优点

1. 工厂类包含必要的逻辑判断，可以决定在什么时候创建哪一个产品的实例。客户端可以免除直接创建产品对象的职责，很方便的创建出相应的产品。工厂和产品的职责区分明确。
2. 客户端无需知道所创建具体产品的类名，只需知道参数即可。
3. 也可以引入配置文件，在不修改客户端代码的情况下更换和添加新的具体产品类。

#### 1.1.2.2. 缺点

1. 简单工厂模式的工厂类单一，负责所有产品的创建，职责过重，一旦异常，整个系统将受影响。且工厂类代码会非常臃肿，违背高聚合原则。
2. 使用简单工厂模式会增加系统中类的个数（引入新的工厂类），增加系统的复杂度和理解难度
3. 系统扩展困难，一旦增加新产品不得不修改工厂逻辑，在产品类型较多时，可能造成逻辑过于复杂
4. 简单工厂模式使用了 static 工厂方法，造成工厂角色无法形成基于继承的等级结构。

### 1.1.3. 应用场景

对于产品种类相对较少的情况，考虑使用简单工厂模式。使用简单工厂模式的客户端只需要传入工厂类的参数，不需要关心如何创建对象的逻辑，可以很方便地创建所需产品。

### 1.1.4. 模式的结构与实现

简单工厂模式的主要角色如下：
* 简单工厂（SimpleFactory）：是简单工厂模式的核心，负责实现创建所有实例的内部逻辑。工厂类的创建产品类的方法可以被外界直接调用，创建所需的产品对象。
* 抽象产品（Product）：是简单工厂创建的所有对象的父类，负责描述所有实例共有的公共接口。
* 具体产品（ConcreteProduct）：是简单工厂模式的创建目标。

其结构图如下图所示。
![](https://r2.129870.xyz/img/20220406220957.png)  


## 1.2. 工厂方法模式

在[[设计模式#1 简单工厂模式|简单工厂模式]]一节我们介绍了简单工厂模式，提到了简单工厂模式违背了开闭原则，而 “工厂方法模式” 是对简单工厂模式的进一步抽象化，其好处是可以使系统在不修改原来代码的情况下引进新的产品，即满足开闭原则。  

### 1.2.1. 优点和缺点

#### 1.2.1.1. 优点

* 用户只需要知道具体工厂的名称就可得到所要的产品，无须知道产品的具体创建过程。
* 灵活性增强，对于新产品的创建，只需多写一个相应的工厂类。
* 典型的解耦框架。高层模块只需要知道产品的抽象类，无须关心其他实现类，满足迪米特法则、依赖倒置原则和里氏替换原则。

#### 1.2.1.2. 缺点

* 类的个数容易过多，增加复杂度
* 增加了系统的抽象性和理解难度
* 抽象产品只能生产一种产品，此弊端可使用[[设计模式#3 抽象工厂模式|抽象工厂模式]]解决。

### 1.2.2. 应用场景：

*  客户只知道创建产品的工厂名，而不知道具体的产品名。如 TCL 电视工厂、海信电视工厂等。
*  创建对象的任务由多个具体子工厂中的某一个完成，而抽象工厂只提供创建产品的接口。
*  客户不关心创建产品的细节，只关心产品的品牌

### 1.2.3. 模式的结构与实现

工厂方法模式由抽象工厂、具体工厂、抽象产品和具体产品等 4 个要素构成。本节来分析其基本结构和实现方法。  

1. 抽象工厂（Abstract Factory）：提供了创建产品的接口，调用者通过它访问具体工厂的工厂方法 newProduct () 来创建产品。
2. 具体工厂（ConcreteFactory）：主要是实现抽象工厂中的抽象方法，完成具体产品的创建。
3. 抽象产品（Product）：定义了产品的规范，描述了产品的主要特性和功能。
4. 具体产品（ConcreteProduct）：实现了抽象产品角色所定义的接口，由具体工厂来创建，它同具体工厂之间一一对应。

![](https://r2.129870.xyz/img/20220406221236.png)

注意：当需要生成的产品不多且不会增加，一个具体工厂类就可以完成任务时，可删除抽象工厂类。这时工厂方法模式将退化到简单工厂模式。

## 1.3. 抽象工厂模式

前面介绍的工厂方法模式中考虑的是一类产品的生产，如畜牧场只养动物、电视机厂只生产电视机、计算机软件学院只培养计算机软件专业的学生等。同种类称为同等级，也就是说：

前面介绍的[[设计模式#2 工厂方法模式|工厂方法模式]]中考虑的是一类产品的生产，如畜牧场只养动物、电视机厂只生产电视机、计算机软件学院只培养计算机软件专业的学生等。

同种类称为同等级，也就是说：工厂方法模式只考虑生产同等级的产品，但是在现实生活中许多工厂是综合型的工厂，能生产多等级（种类） 的产品，如农场里既养动物又种植物，电器厂既生产电视机又生产洗衣机或空调，大学既有软件专业又有生物专业等。

本节要介绍的抽象工厂模式将考虑多等级产品的生产，将同一个具体工厂所生产的位于不同等级的一组产品称为一个产品族，图所示的是海尔工厂和 TCL 工厂所生产的电视机与空调对应的关系图。

![](https://r2.129870.xyz/img/20220406221044.png)

### 1.3.1. 模式的定义与特点

抽象工厂（AbstractFactory）模式的定义：是一种为访问类提供一个创建一组相关或相互依赖对象的接口，且访问类无须指定所要产品的具体类就能得到同族的不同等级的产品的模式结构。

抽象工厂模式是工厂方法模式的升级版本，工厂方法模式只生产一个等级的产品，而抽象工厂模式可生产多个等级的产品。

使用抽象工厂模式一般要满足以下条件：
*  系统中有多个产品族，每个具体工厂创建同一族但属于不同等级结构的产品。
*  系统一次只可能消费其中某一族产品，即同族的产品一起使用。

#### 1.3.1.1. 优点

抽象工厂模式除了具有工厂方法模式的优点外，其他主要优点如下：
* 可以在类的内部对产品族中相关联的多等级产品共同管理，而不必专门引入多个新的类来进行管理。
* 当需要产品族时，抽象工厂可以保证客户端始终只使用同一个产品的产品组。
* 抽象工厂增强了程序的可扩展性，当增加一个新的产品族时，不需要修改原代码，满足开闭原则。

#### 1.3.1.2. 缺点

其缺点是：当产品族中需要增加一个新的产品时，所有的工厂类都需要进行修改。增加了系统的抽象性和理解难度。

### 1.3.2. 模式的结构与实现

抽象工厂模式同工厂方法模式一样，也是由抽象工厂、具体工厂、抽象产品和具体产品等 4 个要素构成，但抽象工厂中方法个数不同，抽象产品的个数也不同。现在我们来分析其基本结构和实现方法。

抽象工厂模式的主要角色如下：
1. 抽象工厂（Abstract Factory）：提供了创建产品的接口，它包含多个创建产品的方法 newProduct ()，可以创建多个不同等级的产品。
2. 具体工厂（Concrete Factory）：主要是实现抽象工厂中的多个抽象方法，完成具体产品的创建。
3. 抽象产品（Product）：定义了产品的规范，描述了产品的主要特性和功能，抽象工厂模式有多个抽象产品。
4. 具体产品（ConcreteProduct）：实现了抽象产品角色所定义的接口，由具体工厂来创建，它同具体工厂之间是多对一的关系。

抽象工厂模式的结构图如图 2 所示。

![](https://r2.129870.xyz/img/20220406221104.png)  



### 1.3.3. 模式的应用场景

抽象工厂模式最早的应用是用于创建属于不同操作系统的视窗构件。如 JAVA 的 AWT 中的 Button 和 Text 等构件在 Windows 和 UNIX 中的本地实现是不同的。

抽象工厂模式通常适用于以下场景：
1. 当需要创建的对象是一系列相互关联或相互依赖的产品族时，如电器工厂中的电视机、洗衣机、空调等。
2. 系统中有多个产品族，但每次只使用其中的某一族产品。如有人只喜欢穿某一个品牌的衣服和鞋。
3. 系统中提供了产品的类库，且所有产品的接口相同，客户端不依赖产品实例的创建细节和内部结构。

### 1.3.4. 模式的扩展

抽象工厂模式的扩展有一定的 “开闭原则” 倾斜性：
1. 当增加一个新的产品族时只需增加一个新的具体工厂，不需要修改原代码，满足开闭原则。
2. 当产品族中需要增加一个新种类的产品时，则所有的工厂类都需要进行修改，不满足开闭原则。

另一方面，当系统中只存在一个等级结构的产品时，抽象工厂模式将退化到工厂方法模式。

### 1.3.5. 进阶阅读

* [《抽象工厂在 Java 源码中的应用》](http://c.biancheng.net/view/vip_8392.html)
* [《抽象工厂模式在 Spring 源码中的应用》](http://c.biancheng.net/view/vip_8393.html)

## 1.4. 构建者模式

在软件开发过程中有时需要创建一个复杂的对象，这个复杂对象通常由多个子部件按一定的步骤组合而成。例如，计算机是由 CPU、主板、内存、硬盘、显卡、机箱、显示器、键盘、鼠标等部件组装而成的，采购员不可能自己去组装计算机，而是将计算机的配置要求告诉计算机销售公司，计算机销售公司安排技术人员去组装计算机，然后再交给要买计算机的采购员。

生活中这样的例子很多，如游戏中的不同角色，其性别、个性、能力、脸型、体型、服装、发型等特性都有所差异；还有汽车中的方向盘、发动机、车架、轮胎等部件也多种多样；每封电子邮件的发件人、收件人、主题、内容、附件等内容也各不相同。

以上所有这些产品都是由多个部件构成的，各个部件可以灵活选择，但其创建步骤都大同小异。这类产品的创建无法用前面介绍的工厂模式描述，只有建造者模式可以很好地描述该类产品的创建。

### 1.4.1. 模式的定义与特点

建造者（Builder）模式的定义：指将一个复杂对象的构造与它的表示分离，使同样的构建过程可以创建不同的表示，这样的设计模式被称为建造者模式。它是将一个复杂的对象分解为多个简单的对象，然后一步一步构建而成。它将变与不变相分离，即产品的组成部分是不变的，但每一部分是可以灵活选择的。

#### 1.4.1.1. 优点

1. 封装性好，构建和表示分离。
2. 扩展性好，各个具体的建造者相互独立，有利于系统的解耦。
3. 客户端不必知道产品内部组成的细节，建造者可以对创建过程逐步细化，而不对其它模块产生任何影响，便于控制细节风险。

#### 1.4.1.2. 缺点

1. 产品的组成部分必须相同，这限制了其使用范围。
2. 如果产品的内部变化复杂，如果产品内部发生变化，则建造者也要同步修改，后期维护成本较大。

建造者（Builder）模式和工厂模式的关注点不同：建造者模式注重零部件的组装过程，而[[设计模式#2 工厂方法模式|工厂方法模式]]更注重零部件的创建过程，但两者可以结合使用。

### 1.4.2. 模式的结构与实现

建造者（Builder）模式由产品、抽象建造者、具体建造者、指挥者等 4 个要素构成，现在我们来分析其基本结构和实现方法。

建造者（Builder）模式的主要角色如下：
1. 产品角色（Product）：它是包含多个组成部件的复杂对象，由具体建造者来创建其各个零部件。
2. 抽象建造者（Builder）：它是一个包含创建产品各个子部件的抽象方法的接口，通常还包含一个返回复杂产品的方法 getResult ()。
3. 具体建造者 (Concrete Builder）：实现 Builder 接口，完成复杂产品的各个部件的具体创建方法。
4. 指挥者（Director）：它调用建造者对象中的部件构造与装配方法完成复杂对象的创建，在指挥者中不涉及具体产品的信息。

其结构图如图所示：

![](https://r2.129870.xyz/img/20220408114009.gif)  

### 1.4.3. 模式的应用场景

建造者模式唯一区别于工厂模式的是针对复杂对象的创建。也就是说，如果创建简单对象，通常都是使用工厂模式进行创建，而如果创建复杂对象，就可以考虑使用建造者模式。

当需要创建的产品具备复杂创建过程时，可以抽取出共性创建过程，然后交由具体实现类自定义创建流程，使得同样的创建行为可以生产出不同的产品，分离了创建与表示，使创建产品的灵活性大大增加。

建造者模式主要适用于以下应用场景：
* 相同的方法，不同的执行顺序，产生不同的结果。
* 多个部件或零件，都可以装配到一个对象中，但是产生的结果又不相同。
* 产品类非常复杂，或者产品类中不同的调用顺序产生不同的作用。
* 初始化一个对象特别复杂，参数多，而且很多参数都具有默认值。

### 1.4.4. 建造者模式和工厂模式的区别

通过前面的学习，我们已经了解了建造者模式，那么它和工厂模式有什么区别呢？
* 建造者模式更加注重方法的调用顺序，工厂模式注重创建对象。
* 创建对象的力度不同，建造者模式创建复杂的对象，由各种复杂的部件组成，工厂模式创建出来的对象都一样
* 关注重点不一样，工厂模式只需要把对象创建出来就可以了，而建造者模式不仅要创建出对象，还要知道对象由哪些部件组成。
* 建造者模式根据建造过程中的顺序不一样，最终对象部件组成也不一样。

### 1.4.5. 模式的扩展

建造者（Builder）模式在应用过程中可以根据需要改变，如果创建的产品种类只有一种，只需要一个具体建造者，这时可以省略掉抽象建造者，甚至可以省略掉指挥者角色。

### 1.4.6. 与其他模式的关系

- 在许多设计工作的初期都会使用[[设计模式#2 工厂方法模式|工厂方法模式]] （较为简单，而且可以更方便地通过子类进行定制），随后演化为使用[[设计模式#3 抽象工厂模式|抽象工厂模式]]、原型模式或生成器模式 （更灵活但更加复杂）。
- 生成器重点关注如何分步生成复杂对象。抽象工厂专门用于生产一系列相关对象。抽象工厂会马上返回产品，生成器则允许你在获取产品前执行一些额外构造步骤。
- 你可以在创建复杂组合模式树时使用生成器，因为这可使其构造步骤以递归的方式运行。
- 你可以结合使用生成器和桥接模式： 主管类负责抽象工作，各种不同的生成器负责实现工作。
- 抽象工厂、生成器和原型都可以用单例模式来实现。

### 1.4.7. 进阶阅读

如果您想了解建造者模式在实际项目中的应用，可猛击阅读以下文章。
* [《建造者模式实现链式赋值》](http://c.biancheng.net/view/vip_8404.html)
* [《使用静态内部类实现建造者模式》](http://c.biancheng.net/view/vip_8409.html) 
* [《使用建造者模式构建动态 SQL 语句》](http://c.biancheng.net/view/vip_8415.html)
* [《建造者模式在框架源码中的应用》](http://c.biancheng.net/view/vip_8420.html)

## 1.5. 原型模式

在有些系统中，存在大量相同或相似对象的创建问题，如果用传统的构造函数来创建对象，会比较复杂且耗时耗资源，用原型模式生成对象就很高效，就像孙悟空拔下猴毛轻轻一吹就变出很多孙悟空一样简单。

### 1.5.1. 原型模式的定义与特点

原型（Prototype）模式的定义如下：用一个已经创建的实例作为原型，通过复制该原型对象来创建一个和原型相同或相似的新对象。在这里，原型实例指定了要创建的对象的种类。用这种方式创建对象非常高效，根本无须知道对象创建的细节。例如，Windows 操作系统的安装通常较耗时，如果复制就快了很多。在生活中复制的例子非常多，这里不一一列举了。

#### 1.5.1.1. 优点

* Java 自带的原型模式基于内存二进制流的复制，在性能上比直接 new 一个对象更加优良。
* 可以使用深克隆方式保存对象的状态，使用原型模式将对象复制一份，并将其状态保存起来，简化了创建对象的过程，以便在需要的时候使用（例如恢复到历史某一状态），可辅助实现撤销操作。

#### 1.5.1.2. 缺点

* 需要为每一个类都配置一个 clone 方法
* clone 方法位于类的内部，当对已有类进行改造的时候，需要修改代码，违背了开闭原则。
* 当实现深克隆时，需要编写较为复杂的代码，而且当对象之间存在多重嵌套引用时，为了实现深克隆，每一层对象对应的类都必须支持深克隆，实现起来会比较麻烦。因此，深克隆、浅克隆需要运用得当。

### 1.5.2. 原型模式的结构与实现

原型模式包含以下主要角色。
1. 抽象原型类：规定了具体原型对象必须实现的接口。
2. 具体原型类：实现抽象原型类的 clone () 方法，它是可被复制的对象。
3.  访问类：使用具体原型类中的 clone () 方法来复制新的对象。

其结构图如图所示：

![](https://r2.129870.xyz/img/20220408132207.gif)  

### 1.5.3. 原型模式的应用场景

原型模式通常适用于以下场景：
* 对象之间相同或相似，即只是个别的几个属性不同的时候。
* 创建对象成本较大，例如初始化时间长，占用 CPU 太多，或者占用网络资源太多等，需要优化资源。
* 创建一个对象需要繁琐的数据准备或访问权限等，需要提高性能或者提高安全性。
* 系统中大量使用该类对象，且各个调用者都需要给它的属性重新赋值。

在 Spring 中，原型模式应用的非常广泛，例如 scope='prototype'、JSON. ParseObject () 等都是原型模式的具体应用。

### 1.5.4. 原型模式的扩展

原型模式可扩展为带原型管理器的原型模式，它在原型模式的基础上增加了一个原型管理器 PrototypeManager 类。该类用 HashMap 保存多个复制的原型，Client 类可以通过管理器的 get (String id) 方法从中获取复制的原型。其结构图如图 5 所示。

![](https://r2.129870.xyz/img/20220408132212.gif)  

### 1.5.5. 与其他模式的关系

- 在许多设计工作的初期都会使用工厂方法模式 （较为简单，而且可以更方便地通过子类进行定制），随后演化为使用抽象工厂模式、原型模式或生成器模式 （更灵活但更加复杂）。
- 抽象工厂模式通常基于一组工厂方法，但你也可以使用原型模式来生成这些类的方法。
- 原型可用于保存命令模式的历史记录。
- 大量使用组合模式和装饰模式的设计通常可从对于原型的使用中获益。你可以通过该模式来复制复杂结构，而非从零开始重新构造。
- 原型并不基于继承，因此没有继承的缺点。另一方面，原型需要对被复制对象进行复杂的初始化。工厂方法基于继承，但是它不需要初始化步骤。
- 有时候原型可以作为备忘录模式的一个简化版本，其条件是你需要在历史记录中存储的对象的状态比较简单，不需要链接其他外部资源，或者链接可以方便地重建。
- 抽象工厂、生成器和原型都可以用单例模式来实现。

### 1.5.6. 进阶阅读

原型模式也称为克隆模式，如果您想深入了解原型（克隆）模式，可以猛击阅读下面的文章：
* [《浅克隆和深克隆》](http://c.biancheng.net/view/vip_8379.html)
* [《克隆会破坏单例对象吗》](http://c.biancheng.net/view/vip_8382.html)
* [《原型模式在 JDK 源码中的应用》](http://c.biancheng.net/view/vip_8383.html)

## 1.6. 单例模式

在有些系统中，为了节省内存资源、保证数据内容的一致性，对某些类要求只能创建一个实例，这就是所谓的单例模式。

### 1.6.1. 单例模式的定义与特点

单例（Singleton）模式的定义：指一个类只有一个实例，且该类能自行创建这个实例的一种模式。例如，Windows 中只能打开一个任务管理器，这样可以避免因打开多个任务管理器窗口而造成内存资源的浪费，或出现各个窗口显示内容的不一致等错误。

在计算机系统中，还有 Windows 的回收站、操作系统中的文件系统、多线程中的线程池、显卡的驱动程序对象、打印机的后台处理服务、应用程序的日志对象、数据库的连接池、网站的计数器、Web 应用的配置对象、应用程序中的对话框、系统中的缓存等常常被设计成单例。

单例模式在现实生活中的应用也非常广泛，例如公司 CEO、部门经理等都属于单例模型。J2EE 标准中的 [Servlet](http://c.biancheng.net/servlet/) Context 和 ServletContextConfig、[Spring](http://c.biancheng.net/spring/) 框架应用中的 ApplicationContext、数据库中的连接池等也都是单例模式。

单例模式有 3 个特点：
1. 单例类只有一个实例对象。
2. 该单例对象必须由单例类自行创建。
3. 单例类对外提供一个访问该单例的全局访问点。

### 1.6.2. 优点

单例模式的优点：
* 单例模式可以保证内存里只有一个实例，减少了内存的开销。
* 可以避免对资源的多重占用。
* 单例模式设置全局访问点，可以优化和共享资源的访问。

缺点：
* 单例模式一般没有接口，扩展困难。如果要扩展，则除了修改原来的代码，没有第二种途径，违背开闭原则。
* 在并发测试中，单例模式不利于代码调试。在调试过程中，如果单例中的代码没有执行完，也不能模拟生成一个新的对象。
* 单例模式的功能代码通常写在一个类中，如果功能设计不合理，则很容易违背单一职责原则。

### 1.6.3. 单例模式的应用场景

对于 [Java](http://c.biancheng.net/java/) 来说，单例模式可以保证在一个 JVM 中只存在单一实例。单例模式的应用场景主要有以下几个方面：
* 需要频繁创建的一些类，使用单例可以降低系统的内存压力，减少 GC。
* 某类只要求生成一个对象的时候，如一个班中的班长、每个人的身份证号等。
* 某些类创建实例时占用资源较多，或实例化耗时较长，且经常使用。
* 某类需要频繁实例化，而创建的对象又频繁被销毁的时候，如多线程的线程池、网络连接池等。
* 频繁访问数据库或文件的对象。
* 对于一些控制硬件级别的操作，或者从系统上来讲应当是单一控制逻辑的操作，如果有多个实例，则系统会完全乱套。
* 当对象需要被共享的场合。由于单例模式只允许创建一个对象，共享该对象可以节省内存，并加快对象访问速度。如 Web 中的配置对象、数据库的连接池等。

### 1.6.4. 单例模式的结构与实现

单例模式是[设计模式](http://c.biancheng.net/design_pattern/)中最简单的模式之一。通常，普通类的构造函数是公有的，外部类可以通过 “new 构造函数 ()” 来生成多个实例。但是，如果将类的构造函数设为私有的，外部类就无法调用该构造函数，也就无法生成多个实例。这时该类自身必须定义一个静态私有实例，并向外提供一个静态的公有函数用于创建或获取该静态私有实例。

单例模式的主要角色如下：
* 单例类：包含一个实例且能自行创建这个实例的类。
* 访问类：使用单例的类。
![](https://r2.129870.xyz/img/20220413132413.png)

### 1.6.5. 单例模式的实现

Singleton 模式通常有两种实现形式。

#### 1.6.5.1. 第 1 种：懒汉式单例

该模式的特点是类加载时没有生成单例，只有当第一次调用 getlnstance 方法时才去创建这个单例。代码如下：

```java
public class LazySingleton {
    private static volatile LazySingleton instance = null;    //保证 instance 在所有线程中同步

    private LazySingleton() {
    }    //private 避免类在外部被实例化

    public static synchronized LazySingleton getInstance () {
        //getInstance 方法前加同步
        if (instance == null) {
            instance = new LazySingleton ();
        }
        return instance;
    }
}
```

注意：如果编写的是多线程程序，则不要删除上例代码中的关键字 volatile 和 synchronized，否则将存在线程非安全的问题。如果不删除这两个关键字就能保证线程安全，但是每次访问时都要同步，会影响性能，且消耗更多的资源，这是懒汉式单例的缺点。

#### 1.6.5.2. 第 2 种：饿汉式单例

该模式的特点是类一旦加载就创建一个单例，保证在调用 getInstance 方法之前单例已经存在了。

```java
public class HungrySingleton {
    private static final HungrySingleton instance = new HungrySingleton();

    private HungrySingleton () {
    }

    public static HungrySingleton getInstance () {
        return instance;
    }
}
```

饿汉式单例在类创建的同时就已经创建好一个静态的对象供系统使用，以后不再改变，所以是线程安全的，可以直接用于多线程而不会出现问题。

### 1.6.6. 单例模式的扩展

单例模式可扩展为有限的多例（Multitcm）模式，这种模式可生成有限个实例并保存在 ArrayList 中，客户需要时可随机获取。

![](https://r2.129870.xyz/img/20220413132455.png)

### 1.6.7. 进阶阅读

如果您想了解单例模式在框架源码中的应用，可猛击阅读 [《单例模式在 JDK 和 Spring 源码中的应用》](http://c.biancheng.net/view/vip_8378.html) 文章。

 ### 与其他模式的关系

- 外观模式类通常可以转换为单例模式类，因为在大部分情况下一个外观对象就足够了。
- 如果你能将对象的所有共享状态简化为一个享元对象，那么享元模式就和单例类似了。但这两个模式有两个根本性的不同。
	- 只会有一个单例实体，但是享元类可以有多个实体，各实体的内在状态也可以不同。
	- 单例对象可以是可变的。享元对象是不可变的。
- 抽象工厂模式、生成器模式和原型模式都可以用单例来实现。

# 2. 结构型模式

## 2.1. 代理模式

在有些情况下，一个客户不能或者不想直接访问另一个对象，这时需要找一个中介帮忙完成某项任务，这个中介就是代理对象。例如，购买火车票不一定要去火车站买，可以通过 12306 网站或者去火车票代售点买。又如找女朋友、找保姆、找工作等都可以通过找中介完成。

在软件设计中，使用代理模式的例子也很多，例如，要访问的远程对象比较大（如视频或大图像等），其下载要花很多时间。还有因为安全原因需要屏蔽客户端直接访问真实对象，如某单位的内部数据库等。

### 2.1.1. 代理模式的定义与特点

代理模式的定义：由于某些原因需要给某对象提供一个代理以控制对该对象的访问。这时，访问对象不适合或者不能直接引用目标对象，代理对象作为访问对象和目标对象之间的中介。

#### 2.1.1.1. 优点有

* 代理模式在客户端与目标对象之间起到一个中介作用和保护目标对象的作用；
* 代理对象可以扩展目标对象的功能；
* 代理模式能将客户端与目标对象分离，在一定程度上降低了系统的耦合度，增加了程序的可扩展性

#### 2.1.1.2. 缺点

* 代理模式会造成系统设计中类的数量增加
* 在客户端和目标对象之间增加一个代理对象，会造成请求处理速度变慢；
* 增加了系统的复杂度；

> [!question]- 那么如何解决以上提到的缺点呢？
> 可以使用动态代理方式。

### 2.1.2. 代理模式的结构

代理模式的结构比较简单，主要是通过定义一个继承抽象主题的代理来包含真实主题，从而实现对真实主题的访问，下面来分析其基本结构和实现方法。

代理模式的主要角色如下：
1. 抽象主题（Subject）类：通过接口或抽象类声明真实主题和代理对象实现的业务方法。
2. 真实主题（Real Subject）类：实现了抽象主题中的具体业务，是代理对象所代表的真实对象，是最终要引用的对象。
3. 代理（Proxy）类：提供了与真实主题相同的接口，其内部含有对真实主题的引用，它可以访问、控制或扩展真实主题的功能。

其结构图如图所示：

![](https://r2.129870.xyz/img/20220407130819.gif)  

在代码中，一般代理会被理解为代码增强，实际上就是在原代码逻辑前后增加一些代码逻辑，而使调用者无感知。

根据代理的创建时期，代理模式分为静态代理和动态代理：
* 静态：由程序员创建代理类或特定工具自动生成源代码再对其编译，在程序运行前代理类的 . Class 文件就已经存在了。
* 动态：在程序运行时，运用反射机制动态创建而成

### 2.1.3. 代理模式的应用场景

当无法或不想直接引用某个对象或访问某个对象存在困难时，可以通过代理对象来间接访问。使用代理模式主要有两个目的：一是保护目标对象，二是增强目标对象。

前面分析了代理模式的结构与特点，现在来分析以下的应用场景：
* 远程代理，这种方式通常是为了隐藏目标对象存在于不同地址空间的事实，方便客户端访问。例如，用户申请某些网盘空间时，会在用户的文件系统中建立一个虚拟的硬盘，用户访问虚拟硬盘时实际访问的是网盘空间。
* 虚拟代理，这种方式通常用于要创建的目标对象开销很大时。例如，下载一幅很大的图像需要很长时间，因某种计算比较复杂而短时间无法完成，这时可以先用小比例的虚拟代理替换真实的对象，消除用户对服务器慢的感觉。
* 安全代理，这种方式通常用于控制不同种类客户对真实对象的访问权限。
* 智能指引，主要用于调用目标对象时，代理附加一些额外的处理功能。例如，增加计算真实对象的引用次数的功能，这样当该对象没有被引用时，就可以自动释放它。
* 延迟加载，指为了提高系统的性能，延迟对目标的加载。例如，[Hibernate](http://c.biancheng.net/hibernate/) 中就存在属性的延迟加载和关联表的延时加载。

### 2.1.4. 代理模式的扩展

在前面介绍的代理模式中，代理类中包含了对真实主题的引用，这种方式存在两个缺点。
1.  真实主题与代理主题一一对应，增加真实主题也要增加代理。
2.  设计代理以前真实主题必须事先存在，不太灵活。采用动态代理模式可以解决以上问题，如 [Spring](http://c.biancheng.net/spring/) AOP，其结构图如图 4 所示。

![](https://r2.129870.xyz/img/20220407130814.gif)  


### 2.1.5. 与其他模式的关系

- [适配器模式](https://refactoringguru.cn/design-patterns/adapter)能为被封装对象提供不同的接口， [代理模式](https://refactoringguru.cn/design-patterns/proxy)能为对象提供相同的接口， [装饰模式](https://refactoringguru.cn/design-patterns/decorator)则能为对象提供加强的接口。
- [外观模式](https://refactoringguru.cn/design-patterns/facade)与[代理](https://refactoringguru.cn/design-patterns/proxy)的相似之处在于它们都缓存了一个复杂实体并自行对其进行初始化。代理与其服务对象遵循同一接口，使得自己和服务对象可以互换，在这一点上它与外观不同。
- [[设计模式#2 装饰器模式|装饰器模式]]和代理有着相似的结构，但是其意图却非常不同。这两个模式的构建都基于组合原则，也就是说一个对象应该将部分工作委派给另一个对象。**两者之间的不同之处在于代理通常自行管理其服务对象的生命周期，而装饰的生成则总是由客户端进行控制。**

### 2.1.6. 进阶阅读

如果您想深入了解代理模式，可猛击阅读以下文章。
*   [《静态代理和动态代理》](http://c.biancheng.net/view/8424.html)
*   [《使用代理模式切换数据源》](http://c.biancheng.net/view/vip_8427.html)
*   [《彻底搞懂 JDK 动态代理核心原理》](http://c.biancheng.net/view/vip_8429.html)
*   [《代理模式在 Spring 源码中的应用》](http://c.biancheng.net/view/vip_8433.html)
*   [《代理模式在 MyBatis 源码中的应用》](http://c.biancheng.net/view/vip_8435.html)

## 2.2. 装饰器模式

上班族大多都有睡懒觉的习惯，每天早上上班时间都很紧张，于是很多人为了多睡一会，就会用方便的方式解决早餐问题。有些人早餐可能会吃煎饼，煎饼中可以加鸡蛋，也可以加香肠，但是不管怎么 “加码”，都还是一个煎饼。在现实生活中，常常需要对现有产品增加新的功能或美化其外观，如房子装修、相片加相框等，都是装饰器模式。  
在软件开发过程中，有时想用一些现存的组件。这些组件可能只是完成了一些核心功能。但在不改变其结构的情况下，可以动态地扩展其功能。所有这些都可以釆用装饰器模式来实现。  

### 2.2.1. 装饰器模式的定义与特点

装饰器（Decorator）模式的定义：指在不改变现有对象结构的情况下，动态地给该对象增加一些职责（即增加其额外功能）的模式，它属于对象结构型模式。  

#### 2.2.1.1. 优点

装饰器模式的主要优点有：

* 装饰器是继承的有力补充，比继承灵活，在不改变原有对象的情况下，动态的给一个对象扩展功能，即插即用
* 通过使用不用装饰类及这些装饰类的排列组合，可以实现不同效果
* 装饰器模式完全遵守开闭原则

#### 2.2.1.2. 缺点

其主要缺点是：装饰器模式会增加许多子类，过度使用会增加程序得复杂性。  

### 2.2.2. 装饰器模式的结构与实现

通常情况下，扩展一个类的功能会使用继承方式来实现。但继承具有静态特征，耦合度高，并且随着扩展功能的增多，子类会很膨胀。如果使用组合关系来创建一个包装对象（即装饰对象）来包裹真实对象，并在保持真实对象的类结构不变的前提下，为其提供额外的功能，这就是装饰器模式的目标。下面来分析其基本结构和实现方法。

装饰器模式主要包含以下角色：
1. 抽象构件（Component）角色：定义一个抽象接口以规范准备接收附加责任的对象。
2. 具体构件（ConcreteComponent）角色：实现抽象构件，通过装饰角色为其添加一些职责。
3. 抽象装饰（Decorator）角色：继承抽象构件，并包含具体构件的实例，可以通过其子类扩展具体构件的功能。
4. 具体装饰（ConcreteDecorator）角色：实现抽象装饰的相关方法，并给具体构件对象添加附加的责任。

装饰器模式的结构图如图所示：
![](https://r2.129870.xyz/img/20220407130808.gif)  

### 2.2.3. 装饰器模式的应用场景

前面讲解了关于装饰器模式的结构与特点，下面介绍其适用的应用场景，装饰器模式通常在以下几种情况使用。

* 当需要给一个现有类添加附加职责，而又不能采用生成子类的方法进行扩充时。例如，该类被隐藏或者该类是最终类或者采用继承方式会产生大量的子类。
* 当需要通过对现有的一组基本功能进行排列组合而产生非常多的功能时，采用继承关系很难实现，而采用装饰器模式却很好实现。
* 当对象的功能要求可以动态地添加，也可以再动态地撤销时。

装饰器模式在 Java 语言中的最著名的应用莫过于 Java I/O 标准库的设计了。例如，InputStream 的子类 FilterInputStream，OutputStream 的子类 FilterOutputStream，Reader 的子类 BufferedReader 以及 FilterReader，还有 Writer 的子类 BufferedWriter、FilterWriter 以及 PrintWriter 等，它们都是抽象装饰类。  
下面代码是为 FileReader 增加缓冲区而采用的装饰类 BufferedReader 的例子：

```java
BufferedReader in = new BufferedReader (new FileReader ("filename. Txt"));
String s = in. ReadLine ();
```


### 2.2.4. 装饰器模式的扩展

装饰器模式所包含的 4 个角色不是任何时候都要存在的，在有些应用环境下模式是可以简化的，如以下两种情况：
- 如果只有一个具体构件而没有抽象构件时，可以让抽象装饰继承具体构件，其结构图如图所示:
![](https://r2.129870.xyz/img/20220407130803.gif)  

- 如果只有一个具体装饰时，可以将抽象装饰和具体装饰合并，其结构图如图所示：
![](https://r2.129870.xyz/img/20220407130757.gif)  

### 2.2.5. 与其他模式的关系

- [适配器模式](https://refactoringguru.cn/design-patterns/adapter)可以对已有对象的接口进行修改，装饰模式则能在不改变对象接口的前提下强化对象功能。此外，装饰器还支持递归组合，适配器则无法实现。
- [适配器](https://refactoringguru.cn/design-patterns/adapter)能为被封装对象提供不同的接口， [[设计模式#1 代理模式|代理模式]]能为对象提供相同的接口，装饰则能为对象提供加强的接口。
- [责任链模式](https://refactoringguru.cn/design-patterns/chain-of-responsibility)和装饰模式的类结构非常相似。两者都依赖递归组合将需要执行的操作传递给一系列对象。但是，两者有几点重要的不同之处。
    [责任链](https://refactoringguru.cn/design-patterns/chain-of-responsibility)的管理者可以相互独立地执行一切操作，还可以随时停止传递请求。另一方面，各种装饰可以在遵循基本接口的情况下扩展对象的行为。此外，装饰无法中断请求的传递。
- [组合模式](https://refactoringguru.cn/design-patterns/composite)和装饰的结构图很相似，因为两者都依赖递归组合来组织无限数量的对象。
    装饰类似于组合，但其只有一个子组件。此外还有一个明显不同： 装饰为被封装对象添加了额外的职责，组合仅对其子节点的结果进行了 “求和”。
    但是，模式也可以相互合作： 你可以使用装饰来扩展组合树中特定对象的行为。
- 大量使用[组合](https://refactoringguru.cn/design-patterns/composite)和装饰的设计通常可从对于[原型模式](https://refactoringguru.cn/design-patterns/prototype)的使用中获益。你可以通过该模式来复制复杂结构，而非从零开始重新构造。
- 装饰可让你更改对象的外表， [策略模式](https://refactoringguru.cn/design-patterns/strategy)则让你能够改变其本质。
- 装饰和 [[设计模式#1 代理模式|代理模式]]有着相似的结构，但是其意图却非常不同。这两个模式的构建都基于组合原则，也就是说一个对象应该将部分工作委派给另一个对象。 **两者之间的不同之处在于代理通常自行管理其服务对象的生命周期，而装饰的生成则总是由客户端进行控制。**

### 2.2.6. 进阶阅读

如果您想深入了解装饰器模式，可猛击阅读以下文章。
* [《使用装饰器模式解决煎饼 “加码” 问题》](/view/vip_8461.html)
* [《装饰器模式在 JDK 源码中的应用》](/view/vip_8463.html)
* [《装饰器模式在 Spring 源码中的应用》](/view/vip_8464.html)
* [《装饰器模式和代理模式的区别》](/view/vip_8466.html)

## 2.3. 适配器模式

在现实生活中，经常出现两个对象因接口不兼容而不能在一起工作的实例，这时需要第三者进行适配。例如，讲中文的人同讲英文的人对话时需要一个翻译，用直流电的笔记本电脑接交流电源时需要一个电源适配器，用计算机访问照相机的 SD 内存卡时需要一个读卡器等。

在软件设计中也可能出现：需要开发的具有某种业务功能的组件在现有的组件库中已经存在，但它们与当前系统的接口规范不兼容，如果重新开发这些组件成本又很高，这时用适配器模式能很好地解决这些问题。

### 2.3.1. 模式的定义与特点

适配器模式（Adapter）的定义如下：将一个类的接口转换成客户希望的另外一个接口，使得原本由于接口不兼容而不能一起工作的那些类能一起工作。

适配器模式分为类结构型模式和对象结构型模式两种，前者类之间的耦合度比后者高，且要求程序员了解现有组件库中的相关组件的内部结构，所以应用相对较少些。

#### 2.3.1.1. 优点

* 客户端通过适配器可以透明地调用目标接口。
* 复用了现存的类，程序员不需要修改原有代码而重用现有的适配者类。
* 将目标类和适配者类解耦，解决了目标类和适配者类接口不一致的问题。
* 在很多业务场景中符合开闭原则。

#### 2.3.1.2. 缺点

* 适配器编写过程需要结合业务场景全面考虑，可能会增加系统的复杂性。
* 增加代码阅读难度，降低代码可读性，过多使用适配器会使系统代码变得凌乱。

### 2.3.2. 模式的结构与实现

类适配器模式可采用多重继承方式实现，如 C++可定义一个适配器类来同时继承当前系统的业务接口和现有组件库中已经存在的组件接口；

Java 不支持多继承，但可以定义一个适配器类来实现当前系统的业务接口，同时又继承现有组件库中已经存在的组件。

对象适配器模式可釆用将现有组件库中已经实现的组件引入适配器类中，该类同时实现当前系统的业务接口。现在来介绍它们的基本结构。

适配器模式（Adapter）包含以下主要角色：
1. 目标（Target）接口：当前系统业务所期待的接口，它可以是抽象类或接口。
2. 适配者（Adaptee）类：它是被访问和适配的现存组件库中的组件接口。
3. 适配器（Adapter）类：它是一个转换器，通过继承或引用适配者的对象，把适配者接口转换成目标接口，让客户按目标接口的格式访问适配者。

类适配器模式的结构图如图 1 所示。

![](https://r2.129870.xyz/img/20220408113949.gif)  

对象适配器模式的结构图如图 2 所示。

![](https://r2.129870.xyz/img/20220408113946.gif)  

说明：对象适配器模式中的 “目标接口” 和“适配者类”的代码同类适配器模式一样，只要修改适配器类和客户端的代码即可。

### 2.3.3. 模式的应用场景

适配器模式（Adapter）通常适用于以下场景：
* 以前开发的系统存在满足新系统功能需求的类，但其接口同新系统的接口不一致。
* 使用第三方提供的组件，但组件接口定义和自己要求的接口定义不同。

### 2.3.4. 模式的扩展

适配器模式（Adapter）可扩展为双向适配器模式，双向适配器类既可以把适配者接口转换成目标接口，也可以把目标接口转换成适配者接口，其结构图如图 4 所示。

![](https://r2.129870.xyz/img/20220408113941.gif)  

 ### 与其他模式的关系

- 桥接模式通常会于开发前期进行设计，使你能够将程序的各个部分独立开来以便开发。另一方面，适配器模式通常在已有程序中使用，让相互不兼容的类能很好地合作。
- 适配器可以对已有对象的接口进行修改，装饰模式则能在不改变对象接口的前提下强化对象功能。此外，装饰还支持递归组合，适配器则无法实现。
- 适配器能为被封装对象提供不同的接口，代理模式能为对象提供相同的接口，装饰则能为对象提供加强的接口。
- 外观模式为现有对象定义了一个新接口，适配器则会试图运用已有的接口。适配器通常只封装一个对象，外观通常会作用于整个对象子系统上。
- 桥接、状态模式和策略模式 （在某种程度上包括适配器） 模式的接口非常相似。实际上，它们都基于组合模式——即将工作委派给其他对象，不过也各自解决了不同的问题。模式并不只是以特定方式组织代码的配方，你还可以使用它们来和其他开发者讨论模式所解决的问题。

### 2.3.5. 进阶阅读

如果您想了解适配器模式在实际中的应用，可猛击阅读以下文章。
* [《使用类适配器重构第三方登录自由适配》](/view/vip_8439.html)
* [《适配器模式在 Spring 源码中的应用》](/view/vip_8447.html)

# 3. 行为型模式

## 3.1. 责任链模式

在现实生活中，一个事件需要经过多个对象处理是很常见的场景。例如，采购审批流程、请假流程等。公司员工请假，可批假的领导有部门负责人、副总经理、总经理等，但每个领导能批准的天数不同，员工必须根据需要请假的天数去找不同的领导签名，也就是说员工必须记住每个领导的姓名、电话和地址等信息，这无疑增加了难度。  
在计算机软硬件中也有相关例子，如总线网中数据报传送，每台计算机根据目标地址是否同自己的地址相同来决定是否接收；还有异常处理中，处理程序根据异常的类型决定自己是否处理该异常；还有 [Struts2](/struts2/) 的拦截器、[JSP](/jsp/) 和 [Servlet](/servlet/) 的 Filter 等，所有这些，都可以考虑使用责任链模式来实现。  

### 3.1.1. 模式的定义与特点

责任链（Chain of Responsibility）模式的定义：为了避免请求发送者与多个请求处理者耦合在一起，于是将所有请求的处理者通过前一对象记住其下一个对象的引用而连成一条链；当有请求发生时，可将请求沿着这条链传递，直到有对象处理它为止。  
注意：责任链模式也叫职责链模式。  
在责任链模式中，客户只需要将请求发送到责任链上即可，无须关心请求的处理细节和请求的传递过程，请求会自动进行传递。所以责任链将请求的发送者和请求的处理者解耦了。  
责任链模式是一种对象行为型模式，其主要优点如下：
1. 降低了对象之间的耦合度。该模式使得一个对象无须知道到底是哪一个对象处理其请求以及链的结构，发送者和接收者也无须拥有对方的明确信息。
2. 增强了系统的可扩展性。可以根据需要增加新的请求处理类，满足开闭原则。
3. 增强了给对象指派职责的灵活性。当工作流程发生变化，可以动态地改变链内的成员或者调动它们的次序，也可动态地新增或者删除责任。
4. 责任链简化了对象之间的连接。每个对象只需保持一个指向其后继者的引用，不需保持其他所有处理者的引用，这避免了使用众多的 if 或者 if···else 语句。
5. 责任分担。每个类只需要处理自己该处理的工作，不该处理的传递给下一个对象完成，明确各类的责任范围，符合类的单一职责原则。

其主要缺点如下：

1. 不能保证每个请求一定被处理。由于一个请求没有明确的接收者，所以不能保证它一定会被处理，该请求可能一直传到链的末端都得不到处理。
2. 对比较长的职责链，请求的处理可能涉及多个处理对象，系统性能将受到一定影响。
3. 职责链建立的合理性要靠客户端来保证，增加了客户端的复杂性，可能会由于职责链的错误设置而导致系统出错，如可能会造成循环调用。

### 3.1.2. 模式的结构

通常情况下，可以通过数据链表来实现职责链模式的[数据结构](/data_structure/)。  

职责链模式主要包含以下角色：

1. 抽象处理者（Handler）角色：定义一个处理请求的接口，包含抽象处理方法和一个后继连接。
2. 具体处理者（Concrete Handler）角色：实现抽象处理者的处理方法，判断能否处理本次请求，如果可以处理请求则处理，否则将该请求转给它的后继者。
3. 客户类（Client）角色：创建处理链，并向链头的具体处理者对象提交请求，它不关心处理细节和请求的传递过程。

责任链模式的本质是解耦请求与处理，让请求在处理链中能进行传递与被处理；理解责任链模式应当理解其模式，而不是其具体实现。责任链模式的独到之处是将其节点处理者组合成了链式结构，并允许节点自身决定是否进行请求处理或转发，相当于让请求流动起来。  
其结构图如图 1 所示。客户端可按图 2 所示设置责任链。  

![](https://r2.129870.xyz/img/20220415132524.png)
图 1 责任链模式的结构图 ![](http://c.biancheng.net/uploads/allimg/181116/3-1Q11613592TF.gif)  
图 2 责任链

### 3.1.3. 模式的应用场景

前边已经讲述了关于责任链模式的结构与特点，下面介绍其应用场景，责任链模式通常在以下几种情况使用：

1. 多个对象可以处理一个请求，但具体由哪个对象处理该请求在运行时自动确定。
2. 可动态指定一组对象处理请求，或添加新的处理者。
3. 需要在不明确指定请求处理者的情况下，向多个处理者中的一个提交请求。

### 3.1.4. 模式的扩展

职责链模式存在以下两种情况：
1. 纯的职责链模式：一个请求必须被某一个处理者对象所接收，且一个具体处理者对某个请求的处理只能采用以下两种行为之一：自己处理（承担责任）；把责任推给下家处理。
2. 不纯的职责链模式：允许出现某一个具体处理者对象在承担了请求的一部分责任后又将剩余的责任传给下家的情况，且一个请求可以最终不被任何接收端对象所接收。

### 3.1.5. 与其他模式的关系

- 责任链模式、命令模式、中介者模式和观察者模式用于处理请求发送者和接收者之间的不同连接方式：
	- 责任链按照顺序将请求动态传递给一系列的潜在接收者，直至其中一名接收者对请求进行处理。
	- 命令在发送者和请求者之间建立单向连接。
	- 中介者清除了发送者和请求者之间的直接连接，强制它们通过一个中介对象进行间接沟通。
	- 观察者允许接收者动态地订阅或取消接收请求。
- 责任链通常和组合模式结合使用。在这种情况下，叶组件接收到请求后，可以将请求沿包含全体父组件的链一直传递至对象树的底部。
- 责任链的管理者可使用命令模式实现。在这种情况下，你可以对由请求代表的同一个上下文对象执行许多不同的操作。
	还有另外一种实现方式，那就是请求自身就是一个命令对象。在这种情况下，你可以对由一系列不同上下文连接而成的链执行相同的操作。
- 责任链和装饰模式的类结构非常相似。两者都依赖递归组合将需要执行的操作传递给一系列对象。但是，两者有几点重要的不同之处。

责任链的管理者可以相互独立地执行一切操作，还可以随时停止传递请求。另一方面，各种装饰可以在遵循基本接口的情况下扩展对象的行为。此外，装饰无法中断请求的传递。

### 3.1.6. 进阶阅读

如果您想深入了解责任链模式，可猛击阅读以下文章。
* [《使用责任链模式实现热插拔权限控制》](/view/vip_8487.html)
* [《责任链模式和建造者模式结合使用》](/view/vip_8488.html)
* [《责任链模式在 JDK 源码中的应用》](/view/8489.html)

## 3.2. 迭代器模式

在现实生活以及程序设计中，经常要访问一个聚合对象中的各个元素，如 “ [数据结构](http://c.biancheng.net/data_structure/) ” 中的链表遍历，通常的做法是将链表的创建和遍历都放在同一个类中，但这种方式不利于程序的扩展，如果要更换遍历方法就必须修改程序源代码，这违背了 “开闭原则”。

既然将遍历方法封装在聚合类中不可取，那么聚合类中不提供遍历方法，将遍历方法由用户自己实现是否可行呢？答案是同样不可取，因为这种方式会存在两个缺点：
1. 暴露了聚合类的内部表示，使其数据不安全。
2. 增加了客户的负担。

“迭代器模式”能较好地克服以上缺点，它在客户访问类与聚合类之间插入一个迭代器，这分离了聚合对象与其遍历行为，对客户也隐藏了其内部细节，且满足 “单一职责原则” 和“开闭原则”，如 [Java](http://c.biancheng.net/java/) 中的 Collection、List、Set、Map 等都包含了迭代器。

迭代器模式在生活中应用的比较广泛，比如：物流系统中的传送带，不管传送的是什么物品，都会被打包成一个个箱子，并且有一个统一的二维码。这样我们不需要关心箱子里是什么，在分发时只需要一个个检查发送的目的地即可。再比如，我们平时乘坐交通工具，都是统一刷卡或者刷脸进站，而不需要关心是男性还是女性、是残疾人还是正常人等信息。

### 3.2.1. 模式的定义与特点

迭代器（Iterator）模式的定义：提供一个对象来顺序访问聚合对象中的一系列数据，而不暴露聚合对象的内部表示。迭代器模式是一种对象行为型模式。

#### 3.2.1.1. 优点

1. 访问一个聚合对象的内容而无须暴露它的内部表示。
2. 遍历任务交由迭代器完成，这简化了聚合类。
3. 它支持以不同方式遍历一个聚合，甚至可以自定义迭代器的子类以支持新的遍历。
4. 增加新的聚合类和迭代器类都很方便，无须修改原有代码。
5. 封装性良好，为遍历不同的聚合结构提供一个统一的接口。

#### 3.2.1.2. 缺点

- 增加了类的个数，这在一定程度上增加了系统的复杂性。
- 在日常开发中，我们几乎不会自己写迭代器。除非需要定制一个自己实现的数据结构对应的迭代器，否则，开源框架提供的 API 完全够用。

### 3.2.2. 模式的结构与实现

迭代器模式是通过将聚合对象的遍历行为分离出来，抽象成迭代器类来实现的，其目的是在不暴露聚合对象的内部结构的情况下，让外部代码透明地访问聚合的内部数据。现在我们来分析其基本结构与实现方法。

迭代器模式主要包含以下角色：
1. 抽象聚合（Aggregate）角色：定义存储、添加、删除聚合对象以及创建迭代器对象的接口。
2. 具体聚合（ConcreteAggregate）角色：实现抽象聚合类，返回一个具体迭代器的实例。
3. 抽象迭代器（Iterator）角色：定义访问和遍历聚合元素的接口，通常包含 hasNext ()、first ()、next () 等方法。
4. 具体迭代器（Concretelterator）角色：实现抽象迭代器接口中所定义的方法，完成对聚合对象的遍历，记录遍历的当前位置。

![](https://r2.129870.xyz/img/20220424132818.gif)  
图 1 迭代器模式的结构图

### 3.2.3. 模式的应用场景

前面介绍了关于迭代器模式的结构与特点，下面介绍其应用场景，迭代器模式通常在以下几种情况使用：
1. 当需要为聚合对象提供多种遍历方式时。
2. 当需要为遍历不同的聚合结构提供一个统一的接口时。
3. 当访问一个聚合对象的内容而无须暴露其内部细节的表示时。

由于聚合与迭代器的关系非常密切，所以大多数语言在实现聚合类时都提供了迭代器类，因此大数情况下使用语言中已有的聚合类的迭代器就已经够了。

### 3.2.4. 模式的扩展

迭代器模式常常与[组合模式](http://c.biancheng.net/view/1373.html)结合起来使用，在对组合模式中的容器构件进行访问时，经常将迭代器潜藏在组合模式的容器构成类中。当然，也可以构造一个外部迭代器来对容器构件进行访问，其结构图如图所示。

![](https://r2.129870.xyz/img/20220424132822.gif)  

 ### 与其他模式的关系

- 你可以使用迭代器模式来遍历组合模式树。
- 你可以同时使用工厂方法模式和迭代器来让子类集合返回不同类型的迭代器，并使得迭代器与集合相匹配。
- 你可以同时使用备忘录模式和迭代器来获取当前迭代器的状态，并且在需要的时候进行回滚。
- 可以同时使用访问者模式和迭代器来遍历复杂数据结构，并对其中的元素执行所需操作，即使这些元素所属的类完全不同。

### 3.2.5. 进阶阅读

如果您想了解迭代器模式在框架源码中的应用，可猛击阅读以下文章：
* [《迭代器模式在 JDK 源码中的应用》](http://c.biancheng.net/view/vip_8497.html)
* [《迭代器模式在 MyBatis 源码中的应用》](http://c.biancheng.net/view/vip_8498.html)